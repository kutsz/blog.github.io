<!DOCTYPE html> <!-- The new doctype -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>OOP</title>

</head>

<body>

<form action="resultPost.php" method="post" name="form1" target="blank">

<p>Введите ваше имя: <br><input name="name" type="text" size="20"></p>
<p>Введите вашу фамилию: <br><input name="lastname" type="text" size="20"></p>
<p><input name="submit" type="submit" value="Отправить"></p>

</form>

<br>
<a href = "server.php" target = "blank">Страница server.php</a>
<?php
  https://secure.php.net/manual/ru/language.oop5.php



Классы/Объекты          http://php.net/manual/ru/ref.classobj.php

__autoload — Attempt to load undefined class
call_user_method_array — Вызывает метод объекта с массивом параметров [устаревшее]
call_user_method — Вызывает метод указанного объекта [устаревшее]
class_alias — Создает псевдоним для указанного класса
class_exists — Проверяет, был ли объявлен класс
get_called_class — Имя класса, полученное с помощью позднего статического связывания
get_class_methods — Возвращает массив имен методов класса
get_class_vars — Возвращает объявленные по умолчанию свойства класса
get_class — Возвращает имя класса, к которому принадлежит объект
get_declared_classes — Возвращает массив с именами объявленных классов
get_declared_interfaces — Возвращает массив всех объявленных интерфейсов
get_declared_traits — Returns an array of all declared traits
get_object_vars — Возвращает свойства указанного объекта
get_parent_class — Возвращает имя родительского класса для объекта или класса
interface_exists — Проверяет, определен ли интерфейс
is_a — Проверяет, принадлежит ли объект к данному классу или содержит данный класс в числе своих предков
is_subclass_of — Проверяет, содержит ли объект в своем дереве предков указанный класс
method_exists — Проверяет, существует ли метод в данном классе
property_exists — Проверяет, содержит ли объект или класс указанный атрибут
trait_exists — Checks if the trait exists
....................................................................................
Класс - это базовое понятие в объектно-ориентированном программировании (ООП). Классы образуют синтаксическую базу ООП. Их можно рассматривать как своего рода "контейнеры" для логически связанных данных и функций (обычно называемых методами — см. ниже). Если сказать проще, то класс - это своеобразный тип данных.

Экземпляр класса - это объект. Объект - это совокупность данных (свойств) и функций (методов) для их обработки. Свойства и методы называются членами класса. Вообще, объектом является все то, что поддерживает инкапсуляцию.

Если класс можно рассматривать как тип данных, то объект — как переменную (по аналогии). Скрипт может одновременно работать с несколькими объектами одного класса, как с несколькими переменными.

объявление класса должно начинаться с ключевого слова class 
(подобно тому, как объявление функции начинается с ключевого слова function).
///////////////////////////////////////////////
Область видимости свойства или метода может быть определена путем использования следующих ключевых слов в объявлении: public, protected или private.

   Доступ к свойствам и методам класса, объявленным как public (общедоступный), разрешен отовсюду. 
   Модификатор protected (защищенный) разрешает доступ наследуемым и родительским классам. 
   Модификатор private (закрытый) ограничивает область видимости так, что только класс, где объявлен   сам элемент, имеет к нему доступ.

Свойства класса должны быть определены через модификаторы public, private, или protected. Если же свойство определено с помощью var, то оно будет доступно как public свойство.
..................test1........

class A{ }
$c = new A();
 $c->a='to add property';
echo $c->a;// a без $    //  to add property
................................test2............
class A{ static $b = 7; }
$c = new A();
 $c->a='to add property';
echo $c->a;// a без $  //  to add property

echo $c::$b; // 7
..........................................test3..............................

class A{ }
$c = new A();
$b = $c;

$c->a='to add property';
$b->q= 1877;

$b->f=function(){echo 'it it function';}; // ??
$b->f1=function($arg){return $arg**2;}; //??

echo $c->a;

echo $b->q;

echo $b->a;

echo $c->q;


 $b->f;  //?? 
//$res = $b->f(4); // Error

//A::f(); // Error


var_dump($c);
var_dump($b);
var_dump($c===$b); //true

Result of test3::::::::::::::::
to add property
1877
to add property
1877
object(A)#1 (4) {
  ["a"]=>
  string(15) "to add property"
  ["q"]=>
  int(1877)
  ["f"]=>
  object(Closure)#2 (0) {
  }
  ["f1"]=>
  object(Closure)#3 (1) {
    ["parameter"]=>
    array(1) {
      ["$arg"]=>
      string(10) "<required>"
    }
  }
}
object(A)#1 (4) {
  ["a"]=>
  string(15) "to add property"
  ["q"]=>
  int(1877)
  ["f"]=>
  object(Closure)#2 (0) {
  }
  ["f1"]=>
  object(Closure)#3 (1) {
    ["parameter"]=>
    array(1) {
      ["$arg"]=>
      string(10) "<required>"
    }
  }
}
bool(true)


........................................................................

new 

Для создания экземпляра класса используется директива new. Новый объект всегда будет создан, за исключением случаев, когда он содержит конструктор, в котором определен вызов исключения в случае ошибки. Рекомендуется определять классы до создания их экземпляров (в некоторых случаях это обязательно).

Если с директивой new используется строка (string), содержащая имя класса, то будет создан новый экземпляр этого класса. Если имя находится в пространстве имен, то оно должно быть задано полностью.//TODO

Пример #3 Создание экземпляра класса

<?php
$instance = new SimpleClass();

// Это же можно сделать с помощью переменной:
$className = 'Foo';
$instance = new $className(); // Foo()
В контексте класса можно создать новый объект через new self и new parent.

Когда происходит присвоение уже существующего экземпляра класса новой переменной, то эта переменная будет указывать на этот же экземпляр класса. Тоже самое происходит и при передаче экземпляра класса в функцию. Копию уже созданного объекта можно создать через ее клонирование.//TODO

Пример #4 Присваивание объекта

<?php

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;  //TODO

$instance->var = '$assigned будет иметь это значение';

$instance = null; // $instance и $reference становятся null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
Результат выполнения данного примера:

NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned будет иметь это значение"
}
В PHP 5.3.0 введены несколько новых методов создания экземпляров объекта:

Пример #5 Создание новых объектов

<?php
class Test
{
    static public function getNew()
    {
        return new static;
    }
}

class Child extends Test
{}

$obj1 = new Test();
$obj2 = new $obj1;
var_dump($obj1 !== $obj2);

$obj3 = Test::getNew();
var_dump($obj3 instanceof Test);

$obj4 = Child::getNew();
var_dump($obj4 instanceof Child);

Результат выполнения данного примера:

bool(true)
bool(true)
bool(true)

extends 

Класс может наследовать методы и свойства другого класса используя ключевое слово extends при его описании. Невозможно наследовать несколько классов, один класс может наследовать только один базовый класс.

Наследуемые методы и свойства могут быть переопределены (за исключением случаев, когда метод класса объявлен как final) путем объявления их с теми же именами, как и в родительском классе. Существует возможность доступа к переопределенным методам или статическим методам путем обращения к ним через parent::             //TODO

Когда переопределяются методы число и типы аргументов должны оставаться такими же как и были, иначе PHP вызовет ошибку уровня E_STRICT. Это не относится к конструктору, который можно переопределить с другими параметрами.

Пример #6 Простое наследование классов

<?php
class ExtendClass extends SimpleClass
{
    // Переопределение метода родителя
    function displayVar()
    {
        echo "Расширенный класс\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();


Расширенный класс
значение по умолчанию
::class 

Начиная с версии PHP 5.5 можно использовать ключевое слово class для разрешения имени класса. //TODO
С помощью конструкции ClassName::class можно получить строку с абсолютным именем класса ClassName. Обычно это довольно полезно при работе с классами, использующими пространства имен.

Пример #7 Разрешение имени класса

<?php
namespace NS {
    class ClassName {
    }

    echo ClassName::class;
}

Результат выполнения данного примера:

NS\ClassName

..................
	class ShopProduct {
		public $title;
		public $producerMainName;
		public $producerFirstName;
		protected $price;
		private $discount = 0;

	public function __construct ($title,$firstName,$mainName,$price){
		$this->title = $title;
		$this->producerFirstName = $firstName;
		$this->producerMainName = $mainName;
		$this->price = $price;
	}

	public function getProducder(){
		return "{$this->producerFirstName}"."{$this->producerMainName}";
	}

	public function getSummaryLine(){
		$base = "{$this->title}( {$this->producerMainName},";
		$base .= "{$this->producerFirstName}";
		return $base;
	{
	public function getPrice(){
		return ($this->price - $this->discount);
	}

	public function setDiscount($num){
		$this->discount = $num;
	}
	public function getDiscount(){
		return $this->discount;
	}

	}

//..........

	class CDProduct extends ShopProduct{
		public $playLength;

	public function __construct ($title,$firstName,$mainName,$price, $playLength){

	 	parent::__construct ($title,$firstName,$mainName,$price);

		$this->playLength = $playLength;
	
	}
	public function getPlayLength(){
		return $this->playLength;
	}

	public function getSummaryLine(){
		$base = "{$this->title}( {$this->producerMainName},";
		$base .= "{$this->producerFirstName}";
		$base .= ":Время звучания - {$this->playLength}";
		return $base;
	{
	}

//.................
	class BookProduct extends ShopProduct{
		public $numPages;

	public function __construct ($title,$firstName,$mainName,$price, $numPages){

	 	parent::__construct ($title,$firstName,$mainName,$price);

		$this->numPages = $numPages;
	
	}
	public function getPlayLength(){
		return $this->numPages;
	}

	public function getSummaryLine(){
		$base = parent::getSummaryLine();
		$base .= ":$this->numPages стр.";
		return $base;
	{
	}
//////////////////////////........................................


class Counter{
private static $count = 0;
public $speed; 
function __construct (){
self::$count++;
}
function __destruct (){
self::$count--;
} 
function getCount (){
 return self::$count;
}

 public function tripTime($distance){
$time =  $distance / $this->speed;
return $time;
}

}
 $counter = new Counter;
$dist=100;
 $time  = $counter -> tripTime($dist);
/////////////////////////////
Переменные, которые являются членами класса, называются "свойства".  //другие термины, такие как "атрибуты" или "поля"
Они определяются с помощью ключевых слов public, protected, или private  // Модификаторы доступа 

В пределах методов класса доступ к нестатическим свойствам может быть получен с помощью -> (объектного оператора):
 $this->property (где property - имя свойства). 
Доступ к статическим свойствам (методам) может быть получен с помощью :: (двойного двоеточия): 
self::$property.

$this  - доступ к объекту
self - доступ к классу(в пределах класса)

Доступ к const в пределах класса,без создания объекта:       self::WHEELS;  

Оператор разрешения области видимости (также называемый "Paamayim Nekudotayim") или просто "двойное двоеточие" - это лексема, позволяющая обращаться к статическим свойствам, константам и перегруженным свойствам или методам класса.

Если метод или свойство характеризует класс использ. static

Статическая переменная существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение программы выходит из этой области видимости.//TODO
Объявление свойств и методов класса статическими позволяет обращаться к ним без создания экземпляра класса. Атрибут класса, объявленный статическим, не может быть доступен посредством экземпляра класса (но статический метод может быть вызван).//TODO
Так как статические методы вызываются без создания экземпляра класса, то псевдо-переменная $this не доступна внутри метода, объявленного статическим.
Доступ к статическим свойствам класса не может быть получен через оператор ->.

Содержащиеся в них значения хранятся на протяжении всего времени жизни сценария.//TODO//TODO

Статические методы сами не могут получать доступ ни к каким обычным свойствам класса, потому что такие свойства принадлежат объектам. Однако из статических методов можно обращаться к статическим свойствам.

Чтобы обратиться к статическому элементу класса нужно указать имя класса после которого указывается два двоеточия, а затем имя статического свойства или метода//TODO
 Статическое свойство доступно каждому экземпляру этого класса.
	<?php
	 
	  class Test {
	    static public $num = 1;
	     
	    static public function sayHi() {
	      self::$num++;
	      echo '<br>Число: '. self::$num;
	    }
	  }
	   
	  $obj = new Test;
	   
           Test::$num;
            Test::sayHi();

	  // доступ к статическому свойству из объекта
	  echo $obj::$num;
	  // вызов статического метода из объекта
	  $obj::sayHi();
	  // второй способ вызова статического метода
	  $obj->sayHi();  // такой способ не рекомендуется использовать, чтобы не запутаться
	 
	?>
........................................
Пример статического метода

<?php
	class Foo {
	    public static function aStaticMethod() {
		// ...
	    }
	}

	Foo::aStaticMethod();
	$classname = 'Foo';
	$classname::aStaticMethod(); // Начиная с PHP 5.3.0
?>
.......................................................



<?php
	class Foo
	{
	    public static $my_static = 'foo';

	    public function staticValue() {
		return self::$my_static;
	    }
	public static function aStaticMethod() {
		// ...
	    }
	}

	class Bar extends Foo
	{
	    public function fooStatic() {
		return parent::$my_static;
	    }
	}


	print Foo::$my_static . "\n";
	Foo::aStaticMethod();
	$foo = new Foo();
	print $foo->staticValue() . "\n";
	print $foo->my_static . "\n";      // Не определено свойство my_static

	print $foo::$my_static . "\n"; // Начиная с PHP 5.3.0
	$classname = 'Foo';
	print $classname::$my_static . "\n"; // Начиная с PHP 5.3.0
	$classname::aStaticMethod(); // Начиная с PHP 5.3.0
	print Bar::$my_static . "\n";
	$bar = new Bar();
	print $bar->fooStatic() . "\n";
?>

/////////////////
<?php
$a = 1;
include 'b.inc';
?>
Здесь переменная $a будет доступна внутри включенного скрипта b.inc. Однако определение (тело) пользовательской функции задает локальную область видимости данной функции. Любая используемая внутри функции переменная по умолчанию ограничена локальной областью видимости функции. 
Например:
<?php
$a = 1; /* глобальная область видимости */ 

function test()
{ 
    echo $a; /* ссылка на переменную локальной области видимости */ 
} 

test();
?>
.......................................................
Ключевое слово global 

<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
?>
массива $GLOBALS
<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
} 

Sum();
echo $b;

$GLOBALS - это ассоциативный массив, ключом которого является имя, а значением - содержимое глобальной переменной. Обратите внимание, что $GLOBALS существует в любой области видимости, это объясняется тем, что $GLOBALS является суперглобальным 
//http://php.net/manual/ru/language.variables.superglobals.php
Суперглобальными переменными являются:

$GLOBALS
$_SERVER
$_GET
$_POST
$_FILES
$_COOKIE
$_SESSION
$_REQUEST
$_ENV


	$GLOBALS — Ссылки на все переменные глобальной области видимости

	Переменная $_SERVER - это массив, содержащий информацию, такую как заголовки, пути и местоположения скриптов. Записи в этом массиве создаются веб-сервером.
	$_SERVER -- $HTTP_SERVER_VARS [удалено] — Информация о сервере и среде исполнения
	echo $_SERVER['SERVER_NAME'];

	$_GET -- $HTTP_GET_VARS [deprecated] — GET-переменные HTTP
	$_POST -- $HTTP_POST_VARS [deprecated] — HTTP POST variables
	$_FILES -- $HTTP_POST_FILES [устаревшее] — Переменные файлов, загруженных по HTTP
	$_REQUEST — Переменные HTTP-запроса (Ассоциативный массив (array), который по умолчанию содержит данные переменных $_GET, $_POST и $_COOKIE.)
	$_SESSION -- $HTTP_SESSION_VARS [устаревшее] — Переменные сессии
	$_ENV -- $HTTP_ENV_VARS [устаревшее] — Переменные окружения
	$_COOKIE -- $HTTP_COOKIE_VARS [устаревшее] — HTTP Куки

///////////////////////
"Волшебные" константы                     http://php.net/manual/ru/language.constants.predefined.php

PHP предоставляет большой список предопределенных констант для каждого выполняемого скрипта. Многие из этих констант определяются различными модулями и будут присутствовать только в том случае, если эти модули доступны в результате динамической загрузки или в результате статической сборки.

Есть восемь волшебных констант, которые меняют свое значение в зависимости от контекста, в котором они используются.//TODO
 Например, значение __LINE__ зависит от строки в скрипте, на которой эта константа указана. Специальные константы нечувствительны к регистру и их список приведен ниже:

__LINE__	Текущий номер строки в файле.
__FILE__	Полный путь и имя текущего файла с развернутыми симлинками (символическая ссылка). Если используется внутри подключаемого файла, то возвращается имя данного файла.
__DIR__	        Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). Возвращаемое
                 имя директории не оканчивается на слеш, за исключением корневой директории.
__FUNCTION__	Имя функции.
__CLASS__	Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, Foo\Bar). Обратите внимание, что начиная с PHP5.4 __CLASS__
                 также работает в трейтах. При использовании в методах трейтов __CLASS__ является именем класса, в котором эти методы используется.
__TRAIT__	Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, Foo\Bar).
__METHOD__	Имя метода класса.
__NAMESPACE__	Имя текущего пространства имен.



/////////////////////
Конструктор - это метод вызываемый при создании объекта.  // $obj = new Class;               __construct() 
Деструктор - это метод вызываемый при уничтожении  объекта.  //    __destruct()

"Волшебные" константы                     http://php.net/manual/ru/language.constants.predefined.php
Спец.псевдоконстанты:

_CLASS_  - имя класса     (Class)
_METHOD_ - класс::метод     (Class::__construct() )

В целях обратной совместимости, если PHP 5 не может обнаружить объявленный метод __construct() и этот метод не наследуется от родительских классов, то вызов конструктора произойдет по устаревшей схеме, через обращение к методу, имя которого соответствует имени класса. 
Начиная с версии PHP 5.3.3, методы с именами, совпадающими с последним элементом имени класса, находящимся в пространстве имен, больше не будут считаться конструкторами. Это изменение не влияет на классы, не находящиеся в пространстве имен.
///////////////////////
Конструкторы и деструкторы 

Конструктор 

void __construct ([ mixed $args = "" [, $... ]] )
PHP 5 позволяет объявлять методы-конструкторы. Классы, в которых объявлен метод-конструктор, будут вызывать этот метод при каждом создании нового объекта, так что это может оказаться полезным, например, для инициализации какого-либо состояния объекта перед его использованием.

Замечание: Конструкторы в классах-родителях не вызываются автоматически, если класс-потомок определяет собственный конструктор.//TODO
 Чтобы вызвать конструктор, объявленный в родительском классе, следует обратиться к методу parent::__construct() внутри конструктора класса-потомка.//TODO
 Если в классе-потомке не определен конструктор, то он может наследоваться от родительского класса как обычный метод (если он не определен как приватный).//TODO
Пример #1 Использование унифицированных конструкторов

<?php
class BaseClass {
   function __construct() {
       print "Конструктор класса BaseClass\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "Конструктор класса SubClass\n";
   }
}

class OtherSubClass extends BaseClass {
    // inherits BaseClass's constructor
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();

В целях обратной совместимости, если PHP 5 не может обнаружить объявленный метод __construct() и этот метод не наследуется от родительских классов, то вызов конструктора произойдет по устаревшей схеме, через обращение к методу, имя которого соответствует имени класса. Может возникнуть только одна проблема совместимости старого кода, если в нём присутствуют классы с методами __construct(), использующиеся для других целей.

В отличие от других методов, PHP не будет генерировать ошибку уровня E_STRICT, если __construct() будет перекрыт методом с другими параметрами, отличными от тех, которые находятся в родительском __construct().

Начиная с версии PHP 5.3.3, методы с именами, совпадающими с последним элементом имени класса, находящимся в пространстве имен, больше не будут считаться конструкторами. Это изменение не влияет на классы, не находящиеся в пространстве имен.

Пример #2 Конструкторы в классах, находящихся в пространстве имен

<?php
namespace Foo;
class Bar {
    public function Bar() {
        // конструктор в версиях PHP 5.3.0-5.3.2
        // обычный метод, начиная с версии PHP 5.3.3
    }
}

Деструкторы 

void __destruct ( void )

PHP 5 предоставляет концепцию деструкторов, сходную с теми, что применяются в других ОО языках, таких, как C++. Деструктор будет вызван при освобождении всех ссылок на определенный объект или при завершении скрипта (порядок выполнения деструкторов не гарантируется).//TODO

Пример #3 Пример использования деструктора

<?php
class MyDestructableClass {
   function __construct() {
       print "Конструктор\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Уничтожается " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();

Как и в случае с конструкторами, деструкторы, объявленные в родительском классе, не будут вызваны автоматически. Для вызова деструктора, объявленном в классе-родителе, следует обратиться к методу parent::__destruct() в теле деструктора-потомка. Также класс-потомок может унаследовать деструктор из родительского класса, если он не определен в нем.

Деструктор будет вызван даже в том случае, если скрипт был остановлен с помощью функции exit(). Вызов exit() в деструкторе предотвратит запуск всех последующих функций завершения.//TODO

Замечание:
Деструкторы, вызываемые при завершении скрипта, вызываются после отправки HTTP-заголовков. Рабочая директория во время фазы завершения скрипта может отличаться в некоторых SAPI (например, в Apache).
Замечание:
Попытка бросить исключение в деструкторе (вызванного во время завершения скрипта) влечет за собой фатальную ошибку.
//////////////


 extends 

Класс может наследовать методы и свойства другого класса используя ключевое слово extends при его описании. Невозможно наследовать несколько классов, один класс может наследовать только один базовый класс.

class Par{
 public $color = 'White';
     function displayVar(){      
                     echo '%%**%%^^78899#####';
			echo '<br>';

			print_r($this->color);
			echo '<br>'; 

			$col = $this->color;
                        echo $col;
			echo '<br>';
     }
}

class Ext extends Par{
public $color = [23,434,778,0];
    const SMTH = 798;
    function displayVar(){
                $smth = self::SMTH; 
                echo "Расширенный класс";
		echo '<br>';

		var_dump($this->color);
		echo '<br>';

		echo $this->color;
		echo '<br>';

		return $smth;
    }
}


$par =new Par;
echo $par->displayVar();  
echo '<br>';
$ext =new Ext;
echo $ext->displayVar();
echo '<br>';

....................result......
%%**%%^^78899#####
White
White

Расширенный класс
array(4) { [0]=> int(23) [1]=> int(434) [2]=> int(778) [3]=> int(0) } 
Array
798
....................................................................................
Наследуемые методы и свойства могут быть переопределены (за исключением случаев, когда метод класса объявлен как final) путем объявления их с теми же именами, как и в родительском классе.//TODO
............
Ключевое слово "final" 

PHP 5 представляет ключевое слово final, разместив которое перед объявлениями методов класса, можно предотвратить их переопределение в дочерних классах. Если же сам класс определяется с этим ключевым словом, то он не сможет быть унаследован.//TODO

Пример #1 Пример окончательных (final) методов

<?php
class BaseClass {
   public function test() {
       echo "Вызван метод BaseClass::test()\n";
   }
   
   final public function moreTesting() {
       echo "Вызван метод BaseClass::moreTesting()\n";
   }
}

class ChildClass extends BaseClass {
   public function moreTesting() {
       echo "Вызван метод ChildClass::moreTesting()\n";
   }
}
// Выполнение заканчивается фатальной ошибкой: Cannot override final method BaseClass::moreTesting()
// (Метод BaseClass::moretesting() не может быть переопределён)
?>
Пример #2 Пример окончательного (final) класса

<?php
final class BaseClass {
   public function test() {
       echo "Вызван метод BaseClass::test()\n";
   }

   // В данном случае неважно, укажете ли вы этот метод как final или нет
   final public function moreTesting() {
       echo "BaseClass::moreTesting() called\n";
   }
}

class ChildClass extends BaseClass {
}
// Выполнение заканчивается фатальной ошибкой: Class ChildClass may not inherit from final class (BaseClass)
// (Класс ChildClass не может быть унаследован от окончательного класса (BaseClass))

....................
 Существует возможность доступа к переопределенным методам или статическим методам путем обращения к ним через parent::
	class ExtendClass extends SimpleClass
	{
	    // Переопределение метода родителя
	    function displayVar()
	    {
		echo "Расширенный класс\n";
		$smth = parent::displayVar() * 22; // Наследуемые методы могут быть записаны так,displayVar() может содержать много строк кода
                     return    $smth;  (    or return  parent::displayVar() * 22;)             
	    }
	}

Видео Зинченко теория №14 ООП#2  time 19m00sec
..................


////////////////////////////////////////////////////////////////////////////
Пространства имен объявляются с помощью зарезервированного слова namespace. Файл, содержащий пространство имен, должен содержать его объявление в начале перед любым другим кодом, кроме зарезервированного слова declare.
declare (directive)
    statement
Тик - это событие, которое случается каждые N низкоуровневых операций, выполненных парсером внутри блока declare. Значение N задается, используя ticks=N внутри секции directive блока declare.
Кодировка скрипта может быть указана для каждого скрипта используя директиву encoding.

<?php
namespace NS {
    class ClassName {
    }

    echo ClassName::class;
}
?>

Результат выполнения данного примера:

NS\ClassName
<?php
namespace MyProject;

echo '"', __NAMESPACE__, '"'; // выводит "MyProject"

///////////////

Псевдо-переменная $this доступна в том случае, если метод был вызван в контексте объекта. $this является ссылкой на вызываемый объект. Обычно это тот объект, которому принадлежит вызванный метод, но может быть и другой объект, если метод был вызван статически из контекста другого объекта

Для создания экземпляра класса используется директива new.
В контексте класса можно создать новый объект через new self и new parent.

Когда происходит присвоение уже существующего экземпляра класса новой переменной, то эта переменная будет указывать на этот же экземпляр класса. Тоже самое происходит и при передаче экземпляра класса в функцию. Копию уже созданного объекта можно создать через ее клонирование.//TODO

Клонирование объектов
Создание копии объекта с абсолютно идентичными свойствами не всегда является приемлемым вариантом.
Копия объекта создается с использованием ключевого слова clone (который вызывает метод __clone() объекта, если это возможно). Вызов метода __clone() не может быть осуществлён непосредственно.

$copy_of_object = clone $object;
При клонировании объекта, PHP 5 выполняет неполную копию всех свойств объекта. Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.
По завершении клонирования, если у класса был определен метод __clone(), то этот метод __clone() вызывается у свежесозданной копии объекта, для возможного изменения всех необходимых свойств.  void __clone ( void )

<?

class SubObject
{
     static $instances = 0;
     public $instance;

     public function __construct() {
	$this->instance = ++self::$instances;
     }

     public function __clone() {
	$this->instance = ++self::$instances;
     }
}

class MyCloneable
{
     public $object1;
     public $object2;

     function __clone()
     {
      // Принудительно копируем this->object, иначе
      // он будет указывать на один и тот же объект.
        $this->object1 = clone $this->object1;
     }
}

	$obj = new MyCloneable();

	$obj->object1 = new SubObject();
	$obj->object2 = new SubObject();

	$obj2 = clone $obj;


	print("Оригинальный объект:\n");
	print_r($obj);

	print("Клонированный объект:\n");
	print_r($obj2);


Результат выполнения данного примера:

Оригинальный объект:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 1
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
							Клонированный объект:
							MyCloneable Object
							(
							    [object1] => SubObject Object
								(
								    [instance] => 3
								)

							    [object2] => SubObject Object
								(
								    [instance] => 2
								)

							)




...............................................................................................
///////////////////////////////////////////////////////////////////////////////////////////////
http://php.net/manual/ru/language.oop5.magic.php#object.tostring
Магические методы 

Имена методов __construct(),  __destruct(),  __call(),  __callStatic(),  __get(),  __set(),  __isset(),  __unset(),  __sleep(),  __wakeup(),  __toString(),  __invoke(),         __set_state(),  __clone() и  __debugInfo() зарезервированы для "магических" методов в PHP. Не стоит называть свои методы этими именами, если вы не хотите использовать их "магическую" функциональность.PHP оставляет за собой право все методы, начинающиеся с __, считать "магическими". Не рекомендуется использовать имена методов с __ в PHP, если вы не желаете использовать соответствующий "магический" функционал.

_________________
__invoke()                        mixed __invoke ([ $... ] )

//Функторы в C++ являются сокращением от "функциональные объекты".  Объект, который действует как функция.
Метод __invoke() вызывается, когда скрипт пытается выполнить объект как функцию.

class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);
var_dump(is_callable($obj));

// result
int(5)
bool(true)
________________________
__toString()               public string __toString ( void )

Метод __toString() позволяет классу решать самостоятельно, как он должен реагировать при преобразовании в строку.
Например, что напечатает echo $obj;. Этот метод должен возвращать строку, иначе выдастся неисправимая ошибка E_RECOVERABLE_ERROR.
Внимание
Нельзя бросить исключение из метода __toString(). Попытка это сделать закончится фатальной ошибкой.
// Объявление простого класса
class TestClass
{
    public $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    public function __toString()
    {
        return $this->foo;
    }
}

$class = new TestClass('Привет');
echo $class;      // Привет

Ранее, до PHP 5.2.0, метод __toString() вызывался только непосредственно в сочетании с функциями echo или print. Начиная с PHP 5.2.0, он вызывается в любом строчном контексте (например, в printf() с модификатором %s), но не в контекстах других типов (например, с %d модификатором).
 Начиная с PHP 5.2.0, преобразование объекта в строку при отсутствии метода __toString() вызывает ошибку E_RECOVERABLE_ERROR.//TODO
___________________________________________
__sleep() и __wakeup()  // http://php.net/manual/ru/language.oop5.magic.php#object.sleep

public array __sleep ( void )
void __wakeup ( void )

Функция serialize() проверяет, присутствует ли в вашем классе метод с "магическим" именем __sleep(). Если это так, то этот метод выполняется прежде любой операции сериализации. Он может очистить объект и предполагается, что будет возвращен массив с именами всех переменных объекта, который должен быть сериализован. Если метод ничего не возвращает кроме NULL, то это значит, что объект сериализован и выдается предупреждение E_NOTICE.

Замечание:
Недопустимо возвращать в __sleep() имена приватных свойств объекта в родительский класс. Это приведет к предупреждению E_NOTICE. Вместо этого вы можете использовать интерфейс Serializable.
Рекомендованное использование __sleep() состоит в завершении работы над данными, ждущими обработки или других подобных задач очистки. Кроме того, этот метод можно выполнять в тех случаях, когда нет необходимости сохранять полностью очень большие объекты.

С другой стороны, функция unserialize() проверяет наличие метода с "магическим" именем __wakeup(). Если такой имеется, то он может воссоздать все ресурсы объекта, принадлежавшие ему.

Обычно __wakeup() используется для восстановления любых соединений с базой данных, которые могли быть потеряны во время операции сериализации и выполнения других операций повторной инициализации.

Пример #1 Sleep и wakeup

<?php
class Connection
{
    protected $link;
    private $dsn, $username, $password;
    
    public function __construct($dsn, $username, $password)
    {
        $this->dsn = $dsn;
        $this->username = $username;
        $this->password = $password;
        $this->connect();
    }
    
    private function connect()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
    
    public function __sleep()
    {
        return array('dsn', 'username', 'password');
    }
    
    public function __wakeup()
    {
        $this->connect();
    }
}

_________________________
 // http://php.net/manual/ru/class.serializable.php
Интерфейс Serializable
Интерфейс для индивидуальной сериализации.

Классы, которые реализуют этот интерфейс не поддерживают больше __sleep() и __wakeup(). Метод serialize вызывается всякий раз, когда необходима сериализация экземпляру класса. Этот метод не вызывает __destruct() и не имеет никаких побочных действий кроме тех, которые запрограммированы внутри него. Когда данные десериализованы, класс известен и соответствующий метод unserialize() вызывается как конструктор вместо вызова __construct(). Если вам необходимо вызвать стандартный конструктор, вы можете это сделать в этом методе.

Обзор интерфейсов 

Serializable {
/* Методы */
abstract public string serialize ( void )
abstract public void unserialize ( string $serialized )
}


Пример #1 Основы использования

<?php
class obj implements Serializable {
    private $data;
    public function __construct() {
        $this->data = "My private data";
    }
    public function serialize() {
        return serialize($this->data);
    }
    public function unserialize($data) {
        $this->data = unserialize($data);
    }
    public function getData() {
        return $this->data;
    }
}

$obj = new obj;
$ser = serialize($obj);

var_dump($ser);

$newobj = unserialize($ser);

var_dump($newobj->getData());

Результатом выполнения данного примера будет что-то подобное:

string(38) "C:3:"obj":23:{s:15:"My private data";}"
string(15) "My private data"


Serializable::serialize — Представляет объект в виде строки
Serializable::unserialize — Создает объект
___________________________________________
__________________________________________________________________________________
Перегрузка  //http://php.net/manual/ru/language.oop5.overloading.php#object.call

Перегрузка в PHP означает возможность динамически "создавать" свойства и методы. Эти динамические сущности обрабатываются с помощью "волшебных" методов, которые можно создать в классе для различных видов действий.

Методы перегрузки вызываются при взаимодействии с теми свойствами или методами, которые не были объявлены или не видны в текущей области видимости. Далее в этом разделе мы будем использовать термины "недоступные свойства" или "недоступные методы" для отражения этой комбинации объявления и области видимости.

Все методы перегрузки должны быть объявлены как public.

Замечание:
Ни один аргумент не может быть передан по ссылке в эти "волшебные" методы.
Замечание:
Интерпретация "перегрузки" в PHP отличается от остальных объектно-ориентированных языков. Традиционно перегрузка означает возможность иметь множество одноименных методов с разным количеством или различными типами аргументов.

Перегрузка свойств 

public void __set ( string $name , mixed $value )
public mixed __get ( string $name )
public bool __isset ( string $name )
public void __unset ( string $name )
___________________________________________

____________________________________________


____________________________________________

____________________________________________
Сериализация объектов  //http://php.net/manual/ru/language.oop5.serialization.php
_______________________________________________
Итераторы объектов  //http://php.net/manual/ru/language.oop5.iterations.php
______________________________________________
https://secure.php.net/manual/ru/language.oop5.overloading.php#object.unset   ????
///////////////////////////////

Resource - это специальная переменная, содержащая ссылку на внешний ресурс. Ресурсы создаются и используются специальными функциями. 
Поскольку тип resource содержит специальные указатели на открытые файлы, соединения с базой данных, области изображения и тому подобное, преобразование в этот тип не имеет смысла.
Для определения того, является ли переменная ресурсом можно использовать функцию is_resource(), а функция get_resource_type() поможет получить тип данного ресурса.

Благодаря системе подсчета ссылок, введенной в PHP 4 Zend Engine, определение отсутствия ссылок на ресурс происходит автоматически, после чего он освобождается сборщиком мусора. Поэтому, очень редко требуется освобождать память вручную.
......................
Константы классов
Константы также могут быть объявлены и в пределах одного класса. Отличие переменных и констант состоит в том, что при объявлении последних или при обращении к ним не используется символ $.
Значение должно быть неизменяемым выражением, не (к примеру) переменной, свойством, результатом математической операции или вызовом функции.
Начиная с версии PHP 5.3.0, стало возможным обратиться к классу с помощью переменной. Значение переменной не должно быть ключевым словом (например, self, parent или static).
<?php
class MyClass
{
    const CONSTANT = 'значение константы';

    function showConstant() {
        echo  self::CONSTANT . "\n";
    }
}

echo MyClass::CONSTANT . "\n";

$classname = "MyClass";
echo $classname::CONSTANT . "\n"; // начиная с версии PHP 5.3.0

$class = new MyClass();
$class->showConstant();

echo $class::CONSTANT."\n"; // начиная с версии PHP 5.3.0

...........................................
Автоматическая загрузка классов
Большинство разработчиков объектно-ориентированных приложений используют такое соглашение именования файлов, в котором каждый класс хранится в отдельно созданном для него файле. Одной из наиболее при этом досаждающих деталей является необходимость писать в начале каждого скрипта длинный список подгружаемых файлов.
В PHP 5 это делать не обязательно. Можно определить функцию __autoload(), которая будет автоматически вызвана при использовании ранее неопределенного класса или интерфейса. Вызов этой функции - последний шанс для интерпретатора загрузить класс прежде, чем он закончит выполнение скрипта с ошибкой.
Подсказка
spl_autoload_register() предоставляет более гибкую альтернативу для автоматической загрузки классов. По этой причине использовать __autoload() не рекомендуется, а сама функция в будущем может перестать поддерживаться или быть удалена.
В этом примере функция пытается загрузить классы MyClass1 и MyClass2 из файлов MyClass1.php и MyClass2.php соответственно.

<?php
function __autoload($class_name) {
    include $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2(); 

............................
Область видимости 

Область видимости свойства или метода может быть определена путем использования следующих ключевых слов в объявлении: public, protected или private. Доступ к свойствам и методам класса, объявленным как public (общедоступный), разрешен отовсюду. Модификатор protected (защищенный) разрешает доступ наследуемым и родительским классам. Модификатор private (закрытый) ограничивает область видимости так, что только класс, где объявлен сам элемент, имеет к нему доступ.

Область видимости свойства 
Свойства класса должны быть определены через модификаторы public, private, или protected. Если же свойство определено с помощью var, то оно будет доступно как public свойство.

/**
 * Определение MyClass
 */
class MyClass
{
    public $public = 'Общий';
    protected $protected = 'Защищенный';
    private $private = 'Закрытый';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // Работает
echo $obj->protected; // Неисправимая ошибка
echo $obj->private; // Неисправимая ошибка
$obj->printHello(); // Выводит Общий, Защищенный и Закрытый


/**
 * Определение MyClass2
 */
class MyClass2 extends MyClass
{
    // Мы можем переопределить public и protected методы, но не private
    protected $protected = 'Защищенный2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // Работает
echo $obj2->protected; // Неисправимая ошибка
echo $obj2->private; // Неопределен
$obj2->printHello(); // Выводит Общий, Защищенный2 и Неопределен

..........................







...............
Абстрактные классы

PHP 5 поддерживает определение абстрактных классов и методов. Класс, который содержит по крайней мере один абстрактный метод, должен быть определен как абстрактный. Следует помнить, что нельзя создать экземпляр абстрактного класса. Методы, объявленные абстрактными, несут, по существу, лишь описательный смысл и не могут включать реализации.
При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в классе-потомке; кроме того, область видимости этих методов должна совпадать (или быть менее строгой). Например, если абстрактный метод объявлен как protected, то реализация этого метода должна быть либо protected либо public, но никак не private. Более того, сигнатуры методов должны совпадать, т.е. контроль типов (type hint) и количество обязательных аргументов должно быть одинаковым. К примеру, если в дочернем классе указан необязательный параметр, которого нет в сигнатуре абстрактного класса, то в данном случае конфликта сигнатур не будет. Это правило также применяется к конструкторам начиная с версии PHP 5.4, ранее сигнатуры конструкторов могли отличаться.

Абстрактный метод - метод класса, реализация для которого отсутствует.
Абстрактные классы - могут иметь обычные методы и абстрактный методы.Если содержит хоть 1н абстр.метод
то должен быть объявлен как абстрактный.

___________________________________________________________
Абстрактный класс                               Интерфейс

свойства                                         --
методы реализации                                --
объявляет методы без реализации                  объявляет методы без реализации
создание экземпляра невозможно                   создание экземпляра невозможно
наследуется(extends)                             реализуется(implements)
наследник имеет только 1го родителя              наследник может реализовать методы нескольких
                                                  интерфейсов
--                                               все методы должны быть public


 --------------                     Применение:                     ------------------
Если можем реализоваить общие методы.             Только описать работу класса потомка
_______________________________________________________
.......................Пример #1 Пример абстрактного класса
<?php
	abstract class AbstractClass
	{
	   /* Данный метод должен быть определён в дочернем классе */
	    abstract protected function getValue();
	    abstract protected function prefixValue($prefix);

	   /* Общий метод */
	    public function printOut() {
		print $this->getValue() . "\n";
	    }
	}

	class ConcreteClass1 extends AbstractClass
	{
	    protected function getValue() {
		return "ConcreteClass1";
	    }

	    public function prefixValue($prefix) {
		return "{$prefix}ConcreteClass1";
	    }
	}

	class ConcreteClass2 extends AbstractClass
	{
	    public function getValue() {
		return "ConcreteClass2";
	    }

	    public function prefixValue($prefix) {
		return "{$prefix}ConcreteClass2";
	    }
	}

	$class1 = new ConcreteClass1;
	$class1->printOut();                                // ConcreteClass1
	echo $class1->prefixValue('FOO_') ."\n";           // FOO_ConcreteClass1

	$class2 = new ConcreteClass2;
	$class2->printOut();                                // ConcreteClass2
	echo $class2->prefixValue('FOO_') ."\n";           // FOO_ConcreteClass2

..............Пример #2 Пример абстрактного класса

<?php
	abstract class AbstractClass
	{
	    // Наш абстрактный метод должен определять только необходимые аргументы
	    abstract protected function prefixName($name);

	}

	class ConcreteClass extends AbstractClass
	{

	    // Наш дочерний класс может также определять необязательные аргументы, не указанные в сигнатуре родительского метода
	    public function prefixName($name, $separator = ".") {
		if ($name == "Pacman") {
		    $prefix = "Mr";
		} elseif ($name == "Pacwoman") {
		    $prefix = "Mrs";
		} else {
		    $prefix = "";
		}
		return "{$prefix}{$separator} {$name}";
	    }
	}

	$class = new ConcreteClass;
	echo $class->prefixName("Pacman"), "\n";              // Mr. Pacman
	echo $class->prefixName("Pacwoman"), "\n";            // Mrs. Pacwoman

Код, предназначенный для прежних версий PHP, должен работать без изменений, если в нём отсутствуют классы или функции, именованные 'abstract'.
................................................................
http://php.net/manual/ru/language.oop5.interfaces.php

Интерфейсы объектов

Интерфейс - это инструмент, который указ.какие методы должен включ. класс, без необходимости описания их
 функционала.

Интерфейсы объектов позволяют создавать код, который указывает, какие методы должен реализовать класс, без необходимости описывания их функционала.

Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова interface. Тела методов интерфейсов должны быть пустыми.

Все методы, определенные в интерфейсы должны быть публичными, что следует из самой природы интерфейса.

Для реализации интерфейса используется оператор implements. Класс должен реализовать все методы, описанные в интерфейсе; иначе произойдет фатальная ошибка. При желании классы могут реализовывать более одного интерфейса за раз, реализуемые интерфейсы должны разделяться запятой.

Замечание:
Класс не может реализовать два интерфейса, содержащих одноименную функцию, так как это повлечет за собой неоднозначность.
Замечание:
Интерфейсы могут быть унаследованы друг от друга, так же как и классы, с помощью оператора extends.
Замечание:
Сигнатуры методов в классе, реализующем интерфейс, должны точно совпадать с сигнатурами, используемыми в интерфейсе, в противном случае будет вызвана фатальная ошибка.

Константы (Constants) 

Интерфейсы могут содержать константы. Константы интерфейсов работают точно так же, как и константы классов, за исключением того, что они не могут быть перекрыты наследующим классом или интерфейсом.
<?php

// Объявим интерфейс 'iTemplate'
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}

// Реализуем интерфейс
// Это сработает нормально
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

// Это не будет работать
// Fatal error: Class BadTemplate contains 1 abstract methods
// and must therefore be declared abstract (iTemplate::getHtml)
// (Фатальная ошибка: Класс BadTemplate содержит 1 абстрактный метод
// и поэтому должнен быть объявлен абстрактным (iTemplate::getHtml))
class BadTemplate implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
}
?>
Пример #2 Расширяемые интерфейсы

<?php
interface a
{
    public function foo();
}

interface b extends a
{
    public function baz(Baz $baz);
}

// Это сработает
class c implements b
{
    public function foo()
    {
    }

    public function baz(Baz $baz)
    {
    }
}

// Это не сработает и выдаст фатальную ошибку
class d implements b
{
    public function foo()
    {
    }

    public function baz(Foo $foo)
    {
    }
}
?>
Пример #3 Множественное наследование интерфейсов

<?php
interface a
{
    public function foo();
}

interface b
{
    public function bar();
}

interface c extends a, b
{
    public function baz();
}

class d implements c
{
    public function foo()
    {
    }

    public function bar()
    {
    }

    public function baz()
    {
    }
}
?>
Пример #4 Интерфейсы с константами

<?php
interface a
{
    const b = 'Константа интерфейса';
}

// Выведет: Константа интерфейса
echo a::b;


// Вот это, однако, не будет работать, так как  
// константы перекрывать нельзя.
class b implements a
{
    const b = 'Class constant';
}

Интерфейс, совместно с контролем типов, предоставляет отличный способ проверки того, что определенный объект содержит определенный набор методов. Смотрите также оператор instanceof и контроль типов.
///////////////////////////////////////////////////////
.........................................
Исключения 

Содержание 

Наследование исключений
Модель исключений (exceptions) в PHP 5 схожа с используемыми в других языках программирования. Исключение можно сгенерировать (как говорят, "выбросить") при помощи оператора throw, и можно перехватить (или, как говорят, "поймать") оператором catch. Код генерирующий исключение, должен быть окружен блоком try, для того чтобы можно было перехватить исключение. Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.

Генерируемый объект должен принадлежать классу Exception или наследоваться от Exception. Попытка сгенерировать исключение другого класса приведет к неисправимой ошибке.

catch

Можно использовать несколько блоков catch, перехватывающих различные классы исключений. Нормальное выполнение (когда не генерируются исключения в блоках try или когда класс сгенерированного исключения не совпадает с классами, объявленными в соответствующих блоках catch) будет продолжено за последним блоком catch. Исключения так же могут быть сгенерированы (или вызваны еще раз) оператором throw внутри блока catch.

При генерации исключения код следующий после описываемого выражения исполнен не будет, а PHP предпримет попытку найти первый блок catch, перехватывающий исключение данного класса. Если исключение не будет перехвачено, PHP выдаст сообщение об ошибке: "Uncaught Exception ..." (Неперехваченное исключение), если не был определен обработчик ошибок при помощи функции set_exception_handler().

finally

В PHP 5.5 и более поздних версиях также можно использовать блок finally после или вместо блока catch. Код в блоке finally всегда будет выполняться после кода в блоках try и catch, вне зависимости было ли брошено исключение или нет, перед тем как продолжится нормальное выполнение кода. whether an exception has been thrown, and before normal execution resumes.

Примечания

Замечание:
Внутренние функции PHP в основном используют сообщения об ошибках, и только новые объектно-ориентированные расширения используют исключения. Однако, ошибки можно легко преобразовать в исключения с помощью класса ErrorException.
Подсказка
Стандартная библиотека PHP (SPL) предоставляет хороший набор встроенных классов исключений.
Примеры

Пример #3 Выброс исключений

<?php
function inverse($x) {
    if (!$x) {
        throw new Exception('Деление на ноль.');
    }
    return 1/$x;
}

try {
    echo inverse(5) . "\n";
    echo inverse(0) . "\n";
} catch (Exception $e) {
    echo 'Выброшено исключение: ',  $e->getMessage(), "\n";
}

// Продолжение выполнения
echo "Hello World\n";
?>
Результат выполнения данного примера:

0.2
Выброшено исключение: Деление на ноль.
Hello World
Пример #4 Вложенные исключения

<?php
function inverse($x) {
    if (!$x) {
        throw new Exception('Деление на ноль.');
    }
    return 1/$x;
}

try {
    echo inverse(5) . "\n";
} catch (Exception $e) {
    echo 'Поймано исключение: ',  $e->getMessage(), "\n";
} finally {
    echo "Первое finally.\n";
}

try {
    echo inverse(0) . "\n";
} catch (Exception $e) {
    echo 'Поймано исключение: ',  $e->getMessage(), "\n";
} finally {
    echo "Второе finally.\n";
}

// Продолжение нормального выполнения
echo "Hello World\n";
?>
Результат выполнения данного примера:

0.2
Первое finally.
Поймано исключение: Деление на ноль.
Второе finally.
Hello World
Пример #5 Вложенные исключения

<?php

class MyException extends Exception { }

class Test {
    public function testing() {
        try {
            try {
                throw new MyException('foo!');
            } catch (MyException $e) {
                // повторный выброс исключения
                throw $e;
            }
        } catch (Exception $e) {
            var_dump($e->getMessage());
        }
    }
}

$foo = new Test;
$foo->testing();


Результат выполнения данного примера:

string(4) "foo!"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Полиморфизм - это возможность создавать разные реализации используя одинаковый интерфейс.

...................................

ООП расшифровывается как объектно-ориентированное программирование. Это парадигма (совокупность идей и понятий) программирования, в которой основными концепциями являются понятия объектов и классов.

Абстракция — абстрагирование, это способ описания общих характеристик объекта.

Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе, и скрыть детали реализации от пользователя.

Наследование — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого
               производится наследование, называется базовым, родительским. Новый класс — потомком или дочерним классом.

Полиморфизм(polymorphism )— это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Класс является описываемой на языке терминологии исходного кода моделью ещё не существующей сущности (объекта). Фактически он описывает устройство объекта, являясь своего рода чертежом.

Объект — это экземпляр класса, совокупность данных (свойств) и функций (методов) для обработки данных.



Позднее статическое связывание      // http://php.net/manual/ru/language.oop5.late-static-bindings.php        //TODO

.............................................................................

Контроль типа 

PHP 5 предоставляет возможность использовать контроль типов. На данный момент функции имеют возможность заставлять параметры быть либо объектами (путем указания имени класса в прототипе функции), либо интерфейсами, либо массивами (начиная с PHP 5.1), или колбеком с типом callable (начиная с PHP 5.4). Однако, если NULL использовался как значение параметра по умолчанию, то это будет также допустимо в качестве аргумента для последующего вызова.

Если класс или интерфейс указан для контроля типа, то все его потомки или реализации также допустимы.

Контроль типа не может быть использован со скалярными типами, такими как int или string. Ресурсы и Трейты также недопустимы.

Пример #1 Пример контроля типов

<?php
// Тестовый класс
class MyClass
{
    /**
     * Тестовая функция
     *
     * Первый параметр должен быть объектом типа OtherClass
     */
    public function test(OtherClass $otherclass) {
        echo $otherclass->var;
    }


    /**
     * Другая тестовая функция
     *
     * Первый параметр должен быть массивом
     */
    public function test_array(array $input_array) {
        print_r($input_array);
    }
    
    /**
     * Первый параметр должен быть итератором
     */
    public function test_interface(Traversable $iterator) {
        echo get_class($iterator);
    }
    
    /**
     * Первый параметр должен быть типа callable
     */
    public function test_callable(callable $callback, $data) {
        call_user_func($callback, $data);
    }
}

// Другой тестовый класс
class OtherClass {
    public $var = 'Hello World';
}
?>
В случае передачи аргумента неправильного типа результатом будет фатальная ошибка.

<?php
// Экземпляры каждого класса
$myclass = new MyClass;
$otherclass = new OtherClass;

// Ошибка: Аргумент 1 должен быть экземпляром класса OtherClass
$myclass->test('hello');

// Ошибка: Аргумент 1 должен быть экземпляром класса OtherClass
$foo = new stdClass;
$myclass->test($foo);

// Ошибка: Аргумент 1 не должен быть null
$myclass->test(null);

// Работает: Выводит Hello World
$myclass->test($otherclass);

// Ошибка: Аргумент 1 должен быть массив
$myclass->test_array('a string');

// Работает: Выводит массив
$myclass->test_array(array('a', 'b', 'c'));

// Работает: Выводит ArrayObject
$myclass->test_interface(new ArrayObject(array()));

// Работает: Выводит int(1)
$myclass->test_callable('var_dump', 1);

Также, контроль типов работает и с функциями:

<?php
// Пример класса
class MyClass {
    public $var = 'Hello World';
}

/**
 * Тестовая функция
 *
 * Первый параметр должен быть объект класса MyClass
 */
function myFunction(MyClass $foo) {
    echo $foo->var;
}

// Это работает
$myclass = new MyClass;
myFunction($myclass);
?>
Контроль типов допускает значения NULL:

<?php

/* Прием значения NULL */
function test(stdClass $obj = NULL) {

}

test(NULL);
test(new stdClass);


//////////////////////////////////////////////////////
Оператор проверки типа // http://php.net/manual/ru/language.operators.type.php

Оператор instanceof используется для определения того, является ли текущий объект экземпляром указанного класса.

Пример #1 Использование instanceof с классами

<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);

Результат выполнения данного примера:

bool(true)
bool(false)
...................................

Оператор instanceof также может быть использован для определения, наследует ли определенный объект какому-либо классу:

Пример #2 Использование instanceof с наследуемыми классами

<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);

Результат выполнения данного примера:

bool(true)
bool(true)

........................................................
Для проверки непринадлежности объекта некоторому классу, используйте логический оператор not.

Пример #3 Использование instanceof для проверки того, что объект не является экземпляром класса

<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));

Результат выполнения данного примера:

bool(true)
.................................

Ну и наконец, instanceof может быть также использован для проверки реализации объектом некоторого интерфейса:

Пример #4 Использование instanceof для класса

<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);

Результат выполнения данного примера:

bool(true)
bool(true)

.........................................
Хотя instanceof обычно используется с прямо указанным именем класса, он также может быть использован с другим объектом или строковой переменной:

Пример #5 Использование instanceof с другими переменными

<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b это объект класса MyClass
var_dump($a instanceof $c); // $c это строка 'MyClass'
var_dump($a instanceof $d); // $d это строка 'NotMyClass'

Результат выполнения данного примера:

bool(true)
bool(true)
bool(false)
...............................
Оператор instanceof не генерирует никаких ошибок, если проверяемая переменная не является объектом. В этом случае он просто возвращает FALSE. Константы, тем не менее, не допускаются.

Пример #6 Пример использования оператора instanceof для проверки других переменных

<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a это целое типа integer
var_dump($b instanceof stdClass); // $b это NULL
var_dump($c instanceof stdClass); // $c это значение типа resource
var_dump(FALSE instanceof stdClass);

Результат выполнения данного примера:

bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given

...................................
Есть несколько подводных камней, которых следует остерегаться. До версии PHP 5.1.0, instanceof вызывал __autoload() если имя класса не существовало. Вдобавок, если класс не был загружен, происходила фатальная ошибка. Это можно было обойти с помощью динамической ссылки на класс или использования строковой переменной с именем класса:

Пример #7 Избежание поиска класса и фатальных ошибок с instanceof в PHP 5.0

<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // нет фатальной ошибки

Результат выполнения данного примера:

bool(false)
Оператор instanceof был добавлен в PHP 5. До этого времени использовалась функция is_a(), но позже is_a() была помечена устаревшей в пользу instanceof. Учтите, что с версии PHP 5.3.0, is_a() больше не является устаревшей.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
///////////////////////////////////////////
Клонирование объектов // https://secure.php.net/manual/ru/language.oop5.cloning.php
Создание копии объекта с абсолютно идентичными свойствами не всегда является приемлемым вариантом. Хорошим примером необходимости копирования конструкторов может послужить ситуация, когда у вас есть объект, представляющий собой окно GTK и содержащий ресурс-идентификатор этого окна; когда вы создаете копию этого объекта, вам может понадобиться, чтобы копия объекта содержала ресурс-идентификатор нового окна. 
Другим примером может послужить ситуация, когда ваш объект содержит ссылку на какой-либо другой используемый объект и, когда вы создаёте копию родительского объекта, вам нужно также создать новый экземпляр этого другого объекта, так, чтобы копия объекта-контейнера содержала собственный отдельный экземпляр содержащегося объекта.

Копия объекта создается с использованием ключевого слова clone (который вызывает метод __clone() объекта, если это возможно). Вызов метода __clone() не может быть осуществлён непосредственно.

$copy_of_object = clone $object;
При клонировании объекта, PHP 5 выполняет неполную копию всех свойств объекта. Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.

void __clone ( void )
По завершении клонирования, если у класса был определен метод __clone(), то этот метод __clone() вызывается у свежесозданной копии объекта, для возможного изменения всех необходимых свойств.
<?php
class SubObject
{
    static $instances = 0;
    public $instance;

    public function __construct() {
        $this->instance = ++self::$instances;
    }

    public function __clone() {
        $this->instance = ++self::$instances;
    }
}

class MyCloneable
{
    public $object1;
    public $object2;

    function __clone()
    {
        // Принудительно копируем this->object, иначе
        // он будет указывать на один и тот же объект.
        $this->object1 = clone $this->object1;
    }
}

$obj = new MyCloneable();

$obj->object1 = new SubObject();
$obj->object2 = new SubObject();

$obj2 = clone $obj;


print("Оригинальный объект:\n");
print_r($obj);

print("Клонированный объект:\n");
print_r($obj2);

Результат выполнения данного примера:

Оригинальный объект:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 1
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
Клонированный объект:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 3
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)










................

Клонирование объекта в PHP (метод clone)

Клонирование объекта приводит к созданию новой копии объекта, при этом конструктор объекта не вызывается, в чём можно убедиться, поместив в конструктор вывод отладочной записи. Пример:


class MethodClone {

	public $_newElement;

	function __construct() {
		$this->_newElement = __CLASS__;
		echo 'Конструктор класса - '. $this->_newElement;
	}
}

$_Class_MethodClone = new MethodClone();
$_new_MethodClone = clone $_Class_MethodClone;
В результате работы скрипта в окно браузера будет выведена лишь одна запись "Конструктор класса - MethodClone". Тем не менее, в процессе создания нового объекта может потребоваться выполнить ряд действий. Для этого PHP предоставляет специальный метод "__clone()", который можно переопределить в классе.

При создании нового объекта в конструкторе статическая переменная "$_newElement" увеличивается на единицу. Однако, как было продемонстрировано выше, при клонировании конструктор не вызывается, и в системе появляются неучтённые объекты. Перегрузка метода "__clone()" позволяет исправить такую ситуацию.


class MethodClone {

	public static $_newElement = 0;
	public $work;

	public function __construct() {
		$this->work = ++self::$_newElement;
	}

	public function __clone() {
		$this->work = ++self::$_newElement;
	}

}

$ob = new MethodClone();

echo '<pre>';
print_r($ob);
echo '</pre>';

$ob2 = clone $ob;

echo '<pre>';
print_r($ob2);
echo '</pre>';
Результат:


MethodClone Object
(
[work] => 1
)
MethodClone Object
(
[work] => 2
)
Метод "__clone()" не вмешивается в работу процесса клонирования, то есть разработчик не должен реализовывать механизм клонирования самостоятельно, он может лишь использовать метод "__clone()" для реакции на процесс клонирования.

Важной деталью, является то, что метод "__clone()" выполняется для нового объекта. Все изменения объекта, которые производятся в методе "__clone()", будут отражаться на новом, а не на старом объекте.

Приведём ещё пример, где в процессе клонирования единственному члену "$_newElement", присваивается значение "Клон", при этом изменения касаются лишь нового объекта.


class MethodClone {

	public $_newElement;

	public function __construct() {
		$this->_newElement = __CLASS__;
	}

	public function __clone() {
		$this->_newElement = '<div>Клон</div>';
	}

}

$_Class_MethodClone = new MethodClone();
$_new_MethodClone = clone $_Class_MethodClone;

echo $_new_MethodClone->_newElement; # Результат: "Клон";
echo $_Class_MethodClone->_newElement; # Результат: "MethodClone";

.......................

PHP. Клонирование объектов и ООП-метод __clone()
Сегодня столкнулся с одной интересной задачей: мне надо было дважды подсчитать количество документов по условию и с группировкой данных. Вот запрос (запрос с искажениями, сокращен для лучшей читабельности):
<?php
// Формируем запрос
$q = $modx->newQuery('modResource');
$q->select(array( 'modResource.*'));

// Добавляем группировку
$q->groupby('parent');

// Считаем
$count = $modx->getCount('modResource', $q);

// Добавляем новую группировку
$q->groupby('pagetitle');

// Опять считаем
$count = $modx->getCount('modResource', $q);

Казалось бы, все замечательно, но давайте сформируем конечный SQL-запрос после второго метода группировки:
SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY parent, pagetitle

И вот здесь уже и кроется проблема. Метод xPDOQuery::groupby() не замещает поле, по которому надо сгруппировать, а добавляет его. То есть вместо того, чтобы сначала посчитать с группировкой по полю parent, а потом по полю pagetitle, после второго вызова ->groupby() у нас в условии группировки появилось два поля. А нам нужно только одно.

Конечно, если у нас запрос не большой, то можно и просто второй запрос накидать. А если запрос большой? Да еще и условия всякие? А еще и лень справедливо давит… В общем неплохо было бы просто объект $q скопировать в другую переменную, например $q2, и только после этого $q сгруппировать по parent и посчитать результат, и $q2 сгруппировать по pagetitle и посчитать результат с новым условием группировки. Тогда мы посчитаем количество записей в $q2, и не примешаем лишнюю группировку к объекту $q.

Давайте попробуем:
<?php
// Формируем запрос
$q = $modx->newQuery('modResource');
$q->select(array( 'modResource.*'));

// Выводим SQL для $q
$q->prepare();
print $q->toSQL();
print '<br /><br />'; 

// Копируем объект-переменную
$q2 = $q;

// Добавляем новую группировку
$q2->groupby('pagetitle');
 
// Выводим SQL для $q
$q2->prepare();
print $q2->toSQL();
print '<br /><br />'; 

// Добавляем группировку
$q->groupby('parent');

// Опять выводим SQL для $q
$q->prepare();
print $q->toSQL();
print '<br /><br />'; 

// Опять выводим SQL для $q2
$q2->prepare();
print $q2->toSQL();
print '<br /><br />'; 

То есть мы сформировали запрос, потом скопировали $q в переменную $q2, после чего уже добавили группировку отдельно для $q и отдельно для $q2. По идее мы должны для разных объектов получить различные условия группировки. Но что мы видим?
SELECT modResource.* FROM `modx_site_content` AS `modResource` 

SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY pagetitle 

SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY pagetitle, parent 

SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY pagetitle, parent 


То есть мы видим, что на выходе мы получили абсолютно одинаковые SQL-запросы для обоих объектов. Почему так произошло? Потому что в современном PHP при присвоении одного объекта из переменной другой переменной, объект не копируется (то есть не передается значение), а присваивается только ссылка на объект, и меняя любую из переменных, меняется единственный общий объект. В общем все почти как в Javascript. Так вот, для копирования (клонирования) объектов существует специальный операнд clone. Вот так будет выглядеть наш конечный запрос:
<?php
// Формируем запрос
$q = $modx->newQuery('modResource');
$q->select(array( 'modResource.*'));

// Выводим SQL для $q
$q->prepare();
print $q->toSQL();
print '<br /><br />'; 

// Копируем объект-переменную
$q2 = clone $q;

// Добавляем новую группировку
$q2->groupby('pagetitle');
 
// Выводим SQL для $q
$q2->prepare();
print $q2->toSQL();
print '<br /><br />'; 

// Добавляем группировку
$q->groupby('parent');

// Опять выводим SQL для $q
$q->prepare();
print $q->toSQL();
print '<br /><br />'; 

// Опять выводим SQL для $q2
$q2->prepare();
print $q2->toSQL();
print '<br /><br />'; 
Вот теперь мы получили уникальные SQL-запросы для каждого объекта в отдельности.
SELECT modResource.* FROM `modx_site_content` AS `modResource` 

SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY pagetitle 

SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY parent 

SELECT modResource.* FROM `modx_site_content` AS `modResource` GROUP BY pagetitle 

И теперь мы можем посчитать собственные результаты для этих запросов.

И напоследок кратко о методе __clone(); Если этот метод объявлен в классе, то он будет вызван на клонируемом объекте автоматически (именно на копии). Это может понадобиться для автоматического переопределения каких-либо свойств склонированного объекта.

Документация по clone: www.php.net/manual/ru/language.oop5.cloning.php

.................................................................................................

Traits   // http://php.net/manual/en/language.oop5.traits.php#language.oop5.traits
http://anton.shevchuk.name/php/php-traits/
https://php.ru/manual/language.oop5.traits.html


Трейты 

Начиная с версии 5.4.0 PHP вводит инструментарий для повторного использования кода, называемый трейтом.

Трейты (англ. traits) - это механизм обеспечения повторного использования кода в языках с поддержкой единого наследования, таких как PHP. Трейты предназначены для уменьшения некоторых ограничений единого наследования, позволяя разработчику повторно использовать наборы методов свободно, в нескольких независимых классах и реализованных с использованием разных архитектур построения классов. Семантика комбинации трейтов и классов определена таким образом, чтобы снизить уровень сложности, а также избежать типичных проблем, связанных с множественным наследованием и c т.н. mixins.

Трейт очень похож на класс, но предназначен для группирования функционала хорошо структурированным и последовательным образом. Невозможно создать самостоятельный экземпляр трейта. Это дополнение к обычному наследованию и позволяет сделать горизонтальную композицию поведения, то есть применение членов класса без необходимости наследования.

Пример #1 Пример использования трейта

<?php
trait ezcReflectionReturnInfo {
    function getReturnType() { /*1*/ }
    function getReturnDescription() { /*2*/ }
}

class ezcReflectionMethod extends ReflectionMethod {
    use ezcReflectionReturnInfo;
    /* ... */
}

class ezcReflectionFunction extends ReflectionFunction {
    use ezcReflectionReturnInfo;
    /* ... */
}

Приоритет ¶

Наследуемый член из базового класса переопределяется членом, находящимся в трейте. Порядок приоритета следующий: члены из текущего класса переопределяют методы в трейте, которые в свою очередь переопределяют унаследованные методы.

Пример #2 Пример приоритета старшинства

Наследуемый метод от базового класса переопределяется методом, вставленным в MyHelloWorld из трейта Trait. Поведение такое же как и для методов, определенных в классе MyHelloWorld. Порядок приоритета такой: методы из текущего класса переопределяют методы трейта, которые в свою очередь переопределяют методы из базового класса.

<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();

Результат выполнения данного примера:

Hello World!

Пример #3 Пример альтернативного порядка приоритета

<?php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

class TheWorldIsNotEnough {
    use HelloWorld;
    public function sayHello() {
        echo 'Hello Universe!';
    }
}

$o = new TheWorldIsNotEnough();
$o->sayHello();

Результат выполнения данного примера:

Hello Universe!

Несколько трейтов ¶

Несколько трейтов могут быть вставлены в класс путем их перечисления в директиве use, разделяя запятыми.

Пример #4 Пример использования нескольких трейтов

<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World';
    }
}

class MyHelloWorld {
    use Hello, World;
    public function sayExclamationMark() {
        echo '!';
    }
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
$o->sayExclamationMark();

Результат выполнения данного примера:

Hello World!

Разрешение конфликтов ¶

Если два трейта вставляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт явно не разрешен.

Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтных методов.

Так как предыдущий оператор позволяет только исключать методы, оператор as может быть использован для включения одного из конфликтующих методов под другим именем.

Пример #5 Пример разрешения конфликтов

В этом примере Talker использует трейты A и B. Так как в A и B есть конфликтные методы, он определяет использовать вариант smallTalk из трейта B, и вариант bigTalk из трейта A.

Класс Aliased_Talker применяет оператор as чтобы получить возможность использовать имплементацию bigTalk из B под дополнительным псевдонимом talk.

<?php
trait A {
    public function smallTalk() {
        echo 'a';
    }
    public function bigTalk() {
        echo 'A';
    }
}

trait B {
    public function smallTalk() {
        echo 'b';
    }
    public function bigTalk() {
        echo 'B';
    }
}

class Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}

class Aliased_Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
        B::bigTalk as talk;
    }
}

Изменение видимости метода ¶

Используя синтаксис оператора as можно также настроить видимость метода в выставке класса.

Пример #6 Пример изменения видимости метода

<?php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

// Изменение видимости класса sayHello
class MyClass1 {
    use HelloWorld { sayHello as protected; }
}

// Создание псевдонима метода с измененной видимостью
// видимость sayHello не изменилась
class MyClass2 {
    use HelloWorld { sayHello as private myPrivateHello; }
}
?>
Трейты, скомпонованные из трейтов ¶

Аналогично тому, как классы могут использовать трейты, также могут и трейты использовать другие трейты. Используя один или более трейтов в определении другого трейта, он может частично или полностью состоять из членов, описанных в этих трейтах.

Пример #7 Пример трейтов, скомпонованных из трейтов

<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World!';
    }
}

trait HelloWorld {
    use Hello, World;
}

class MyHelloWorld {
    use HelloWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
?>
Результат выполнения данного примера:

Hello World!
Абстрактные члены трейтов ¶

Трейты поддерживают использование абстрактных методов для того, чтобы устанавливать требования при выставке класса.

Пример #8 Экпресс требования с абстрактными методами

<?php
trait Hello {
    public function sayHelloWorld() {
        echo 'Hello'.$this->getWorld();
    }
    abstract public function getWorld();
}

class MyHelloWorld {
    private $world;
    use Hello;
    public function getWorld() {
        return $this->world;
    }
    public function setWorld($val) {
        $this->world = $val;
    }
}
?>
Статические члены трейта ¶

Трейты могут определять и статические свойства и статические методы.

Пример #9 Статические переменные

<?php
trait Counter {
    public function inc() {
        static $c = 0;
        $c = $c + 1;
        echo "$c\n";
    }
}

class C1 {
    use Counter;
}

class C2 {
    use Counter;
}

$o = new C1(); $o->inc(); // echo 1
$p = new C2(); $p->inc(); // echo 1
?>
Пример #10 Статические методы

<?php
trait StaticExample {
    public static function doSomething() {
        return 'Что-либо делаем';
    }
}

class Example {
    use StaticExample;
}

Example::doSomething();
?>
Свойства ¶

Трейты могут также определять свойства.

Пример #11 Определение свойств

<?php
trait PropertiesTrait {
    public $x = 1;
}

class PropertiesExample {
    use PropertiesTrait;
}

$example = new PropertiesExample;
$example->x;
?>
Если трейт определяет свойство, то класс не может определить свойство с таким же именем, иначе будет сгенерирована ошибка. Это будет ошибка E_STRICT, если определение класса совместимо (такая же область видимости и начальные значения) или фатальная ошибка в ином случае.

Пример #12 Разрешение конфликтов

<?php
trait PropertiesTrait {
    public $same = true;
    public $different = false;
}

class PropertiesExample {
    use PropertiesTrait;
    public $same = true; // Строгое следование стандартам
    public $different = true; // Фатальная ошибка
}

............................
////////////////////////////////////
Класс - это базовое понятие в объектно-ориентированном программировании (ООП). Классы образуют синтаксическую базу ООП. Их можно рассматривать как своего рода "контейнеры" для логически связанных данных и функций (обычно называемых методами — см. ниже). Если сказать проще, то класс - это своеобразный тип данных.

Экземпляр класса - это объект. Объект - это совокупность данных (свойств) и функций (методов) для их обработки. Свойства и методы называются членами класса. Вообще, объектом является все то, что поддерживает инкапсуляцию.

Если класс можно рассматривать как тип данных, то объект — как переменную (по аналогии). Скрипт может одновременно работать с несколькими объектами одного класса, как с несколькими переменными.







/////////////////////////////////////////////


</body>
</html>
