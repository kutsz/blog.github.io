 
 Возможности PHP     //http://php.net/manual/ru/intro-whatcando.php
Общие инструкции по установке  //  http://php.net/manual/ru/install.general.php

PHP originally stood for Personal Home Page.
PHP which is now officially known as 'Hypertext Preprocessor' was released in the year 1995.
PHP was originally created by Rasmus Lerdorf in 1995. He wrote the original Common Gateway Interface (CGI) binaries.



<!DOCTYPE html> <!-- The new doctype -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Первая PHP страница</title>

</head>

<body>
<?php
 Тип данных - это описание, определяющее свойства и особенности работы с данными.

Функции для работы с переменными                  https://secure.php.net/manual/ru/ref.var.php
....
Большенство из них возвращает  или TRUE , или FALSE 

	boolval — Get the boolean value of a variable
	doubleval — Псевдоним floatval
	floatval — Возвращает значение переменной в виде числа с плавающей точкой
	intval — Возвращает целое значение переменной
	strval — Возвращает строковое значение переменной

	gettype — Возвращает тип переменной
	settype — Присваивает переменной новый тип

	isset — Определяет, была ли установлена переменная значением отличным от NULL
	unset — Удаляет переменную

	empty — Проверяет, пуста ли переменная

	debug_zval_dump — Выводит строковое представление внутреннего значения zend
	get_defined_vars — Возвращает массив всех определенных переменных
	get_resource_type — Возвращает тип ресурса
	import_request_variables — Импортирует переменные GET/POST/Cookie в глобальную область видимости

	is_array — Определяет, является ли переменная массивом
        is_object — Проверяет, является ли переменная объектом
	is_resource — Проверяет, является ли переменная ресурсом
        is_null — Проверяет, является ли значение переменной равным NULL

	is_scalar — Проверяет, является ли переменная скалярным значением
	is_string — Проверяет, является ли переменная строкой
	is_callable — Проверяет, может ли значение переменной быть вызвано в качестве функции

	is_numeric — Проверяет, является ли переменная числом или строкой, содержащей число

	is_bool — Проверяет, является ли переменная булевой

	is_float — Проверяет, является ли переменная числом с плавающей точкой
  	is_double — Псевдоним is_float
        is_real — Псевдоним is_float

	is_int — Проверяет, является ли переменная переменной целочисленного типа
	is_integer — Псевдоним is_int
	is_long — Псевдоним is_int
	
	
	
	serialize — Генерирует пригодное для хранения представление переменной
         (сколь угодно сложный объект можно упаковать в строку)
	unserialize — Создает PHP-значение из хранимого представления

	//Отладочные ф-ции 
	print_r — Выводит удобочитаемую информацию о переменной
	var_dump — Выводит информацию о переменной
	var_export — Выводит в браузер или возвращает интерпретируемое строковое представление переменной

///////////////////////////////////////////
Хотя в PHP и нет необходимости инициализировать переменные, это считается очень хорошей практикой. 
Неинициализированные переменные принимают значение по умолчанию в зависимости от их типа, который определяется из контекста их первого использования: 

 булевы принимают значение FALSE, 
 целые и числа с плавающей точкой - ноль, 
 строки (например, при использовании в echo) - пустую строку, 
  а массивы становятся пустыми массивами.


 Инициализация (Initialize)   // Присваивание начальных значений переменным программы.Приведение областей памяти в состояние, 
                              // исходное для последующей обработки или размещения данных

 Переменная присвоить значение                //   The variable to assign a value
         
объявление переменной без инициализации
........................................
Опера́нд (англ. operand) в языках программирования ― аргумент операции; данные, которые обрабатываются командой; грамматическая конструкция, обозначающая выражение, задающее значение аргумента операции. Иногда операндом называют место, позицию в тексте, где должен стоять аргумент операции. //TODO

Операнд – то, к чему применяется оператор
	Унарным называется оператор, который применяется к одному выражению   
	Бинарным называется оператор, который применяется к двум операндам

Константа – это переменная, которая никогда не меняется
.......................................
 {2(Опера́нд)          +[Оператором]               43(Опера́нд)}   операция   // выражение
.....................................
Оператором называется нечто, принимающее одно или более значений (или выражений, если говорить на жаргоне программирования), и вычисляющее новое значение (таким образом, вся конструкция может рассматриваться как выражение).//TODO

Операторы можно сгруппировать по количеству принимаемых ими значений. 
 Унарные операторы принимают только одно значение, например, ! (оператор логического отрицания) или ++ (инкремент). 
 Бинарные операторы принимают два значения; это, например, знакомые всем арифметические операторы + (плюс) и - (минус), большинство поддерживаемых в PHP операторов входят именно в эту категорию. 
 Ну и, наконец, есть всего один тернарный оператор, ? :, принимающий три значения, обычно его так и называют -- "тернарный оператор" (хотя, возможно, более точным названием было бы "условный оператор").//TODO
................................................
Переменная - это область оперативной памяти, доступ к которой осуществляется по имени.
 Все данные, с которыми работает программа, хранятся в виде переменных (исключение — константа, которая, впрочем, может содержать  число или строку или массив(PHP 7)). 
Такого понятия, как указатель (как в Си), в PHP не существует — при присвоении переменная копируется один-в-один, какую бы сложную структуру она ни имела. Тем не менее, в PHP, начиная с версии 4, существует понятие ссылок — жестких и символических.
Переменные в PHP — это особые объекты, которые могут содержать в буквальном смысле все, что угодно.
Отличительным преимуществом PHP является то, что в PHP не нужно ни описывать переменные явно, ни указывать их тип. Интерпретатор все это делает сам. Однако иногда он может ошибаться (например, если в текстовой строке на самом деле задано десятичное число), поэтому изредка возникает необходимость явно указывать, какой же тип имеет то или иное выражение.
Чуть чаще возникает потребность узнать тип переменной (например, переданной в параметрах функции) прямо во время выполнения программы.
    
PHP поддерживает 8 простых типов данных (переменных):

Четыре скалярных типа: 

boolean (двоичные данные)
integer (целые числа)
float (числа с плавающей точкой или 'double')
string (строки)

Два смешанных типа:

array (массивы)
object (объекты)

И два специальных типа:

resource (ресурсы)
NULL ("пустой" тип)

Существуют также несколько псевдотипов:

mixed (смешанный)
number (числовой)
callback (обратного вызова)

//////////////////////////////////
NULL 

Специальное значение NULL представляет собой переменную без значения. // TODO
NULL - это единственно возможное значение типа null.

Переменная считается null, если:                        // TODO

	ей была присвоена константа NULL.

	ей еще не было присвоено никакого значения.   

	она была удалена с помощью unset().


Существует только одно значение типа null - регистронезависимая константа NULL.


$var = NULL;       

Смотрите также функции is_null() и unset().

Приведение переменной к null с использованием (unset) $var не удаляет переменную и ее значение. 
Данное выражение только возвращает NULL
___________
NULL означает отсутствие, неизвестность информации. Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни нулю.(Wiki)

echo (NULL == FALSE)?"ok":"not ok"; // ok
echo (NULL === FALSE)?"ok":"not ok"; // not ok

echo (NULL == "")?"ok":"not ok"; // ok
echo (NULL === "")?"ok":"not ok"; // not ok

.............................


.............
	#1
	$n = 8;
	var_dump($n);  // int(8)
	unset($n);  
	var_dump($n); // PHP Notice:  Undefined variable: n in /home/valentin/t.php on line 105   //  NULL

	/*
	int(8)
	PHP Notice:  Undefined variable: n in /home/valentin/t.php on line 105
	NULL
	*/
	....
	#2
	$n;
	var_dump($n);
	unset($n);
	var_dump($n);

	/*   
	PHP Notice:  Undefined variable: n in /home/valentin/t.php on line 103
	NULL
	PHP Notice:  Undefined variable: n in /home/valentin/t.php on line 105
	NULL
	*/
/////////////////////////////////
  Разные Функции                   // http://php.net/manual/ru/ref.misc.php
////////////////////

die — Эквивалент функции exit
exit — Выводит сообщение и прекращает выполнение текущего скрипта

$filename = '/path/to/data-file';
$file = fopen($filename, 'r')
    or exit("Невозможно открыть файл ($filename)");


//нормальный выход из программы
exit;
exit();
exit(0);

//выход с кодом ошибки
exit(1);
exit(0376); //восьмеричный
//////////////////////////////

Переменные переменных    // http://php.net/manual/ru/language.variables.variable.php

Иногда бывает удобно иметь переменными имена переменных. То есть, имя переменной, которое может быть определено и изменено динамически. 
Обычная переменная определяется примерно таким выражением:
<?php
$a = 'hello';
Переменная переменной берет значение переменной и рассматривает его как имя переменной.// TODO
 В вышеприведенном примере hello может быть использовано как имя переменной при помощи двух знаков доллара. То есть:
$$a = 'world';
Теперь в дереве символов PHP определены и содержатся две переменные: $a, содержащая "hello", и $hello, содержащая "world". Таким образом, выражение
echo "$a ${$a}";                          // TODO
выведет то же, что и
echo "$a $hello";
то есть, они оба выведут: hello world

Для того чтобы использовать переменные переменных с массивами, вы должны решить проблему двусмысленности. То есть, если вы напишете $$a[1], обработчику необходимо знать, хотите ли вы использовать $a[1] в качестве переменной, либо вам нужна как переменная $$a, а затем ее индекс [1]. 
Синтаксис для разрешения этой двусмысленности таков: ${$a[1]} для первого случая и ${$a}[1] для второго.    // TODO

К свойствам класса также можно получить доступ динамически. Переменное имя свойства будет разрешено в том контексте, в котором произойдет вызов к нему. Например, в случае выражения $foo->$bar, локальная область видимости будет просканирована на наличие переменной $bar, значение которой будет использовано в качестве имени свойства объекта $foo. Это также работает и в том случае, если $bar осуществляет доступ к элементу массива.

Фигурные скобки могут также использоваться, чтобы четко разграничить имя свойства. Они наиболее полезны при получении доступа к значениям внутри свойства, которое содержит массив, когда имя свойства состоит из нескольких частей, либо когда имя свойства содержит символы, которые иначе не действительны (например, из функции json_decode() или из SimpleXML).   // TODO



//////////////////////////

	$a = "100";
	$b = "200";

	echo " $a  + $b <br> ";      //  100 + 200         // TODO     

	echo " $a . $b <br> ";       //  100 . 200
	
	echo  $a  + $b;              // 300

	echo  $a . $b ;              //  100200
	
	echo  1  - "100";            // -99
	
	for ($i = 1; $i <= 5; $i++) {
	    	echo "<li>$i в квадрате = " . ($i*$i);
		echo " , $i в кубе = " . ($i*$i*$i) . "\n";
	} 
...........................
$t = date("H");

if ($t < "10") {
    echo "Have a good morning!";
} elseif ($t < "20") {
    echo "Have a good day!";
} else {
    echo "Have a good night!";
}
echo "<br>...........................<br>";
$x = 1;
  
while($x <= 5) {
   echo "The number is: $x <br>";
   $x++;
} 

echo "<br>.........................................HEREDOC..........<br>";
//          $x === $y	               Returns true if $x is equal to $y, and they are of the same type
echo <<< TEXT
<h1>This is a heading</h1>
"Внимание"
Очень важно отметить, что строка с закрывающим идентификатором не должна содержать других символов, за исключением точки с запятой (;). Это означает, что идентификатор не должен вводиться с отступом и что не может быть никаких пробелов или знаков табуляции до или после точки с запятой. Важно также понимать, что первым символом перед закрывающим идентификатором должен быть символ новой строки, определенный в вашей операционной системе. Например, в UNIX системах, включая Mac OS X, это \n. После закрывающего идентификатора также сразу должна начинаться новая строка.

<br>.................................................................<br>
TEXT;

$favcolor = "red";

switch ($favcolor) 
{
     case "red":

         echo "Your favorite color is red!";
	$x = 1;
  
	while($x <= 5) {
   	echo "The number is: $x <br>";
   	$x++;
	} 

         break;
     case "blue":
         echo "Your favorite color is blue!";
         break;
     case "green":
         echo "Your favorite color is green!";
         break;
     default:
         echo "Your favorite color is neither red, blue, nor green!";
}
..............................

break прерывает выполнение текущей структуры for, foreach, while, do-while или switch.


break принимает необязательный числовой аргумент, который сообщает ему выполнение какого количества вложенных структур необходимо прервать. Значение по умолчанию 1, только ближайшая структура будет прервана.

<?php
$arr = array('один', 'два', 'три', 'четыре', 'стоп', 'пять');
while (list(, $val) = each($arr)) {
    if ($val == 'стоп') {
        break;    /* Тут можно было написать 'break 1;'. */
    }
    echo "$val<br />\n";
}

/* Использование дополнительного аргумента. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "Итерация 5<br />\n";
        break 1;  /* Выйти только из конструкции switch. */
    case 10:
        echo "Итерация 10; выходим<br />\n";
        break 2;  /* Выходим из конструкции switch и из цикла while. */
    default:
        break;
    }
}

История изменений break
Версия	Описание
5.4.0	break 0; больше не допускается. В предыдущих версиях это воспринималось точно также как и break 1;.
5.4.0	Удалена возможность передачи переменных (например, $num = 2; break $num;) в виде числового аргумента.
..........................

continue используется внутри циклических структур для пропуска оставшейся части текущей итерации цикла и, при соблюдении условий, начала следующей итерации.

Замечание: В PHP, структура switch считается циклической, и внутри нее может использоваться continue. Если continue не передано аргументов, то он ведет себя аналогично break. Если switch расположен внутри цикла, continue 2 продолжит выполение внешнего цикла со следующей итерации.

continue принимает необязательный числовой аргумент, который указывает на скольких уровнях вложенных циклов будет пропущена оставшаяся часть итерации. Значением по умолчанию является 1, при которой пропускается оставшаяся часть текущего цикла.

<?php
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // пропуск четных чисел
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Снаружи<br />\n";
    while (1) {
        echo "В середине<br />\n";
        while (1) {
            echo "Внутри<br />\n";
            continue 3;
        }
        echo "Это никогда не будет выведено.<br />\n";
    }
    echo "Это тоже.<br />\n";
}
?>
Пропуск точки запятой после continue может привести к путанице. Пример как не надо делать.

<?php
for ($i = 0; $i < 5; ++$i) {
    if ($i == 2)
        continue
    print "$i\n";
}

Ожидается, что результат будет такой:

0
1
3
4
Но, в PHP до версии 5.4.0, этот скрипт выведет следующее:

2

Потому что выражение continue print "$i\n"; воспринимается как единое выражение, и print вызывается только тогда, когда выражение $i == 2 истинно. (Возвращаемое значение от print передается к continue как числовой аргумент.)

Замечание:
Начиная с PHP 5.4.0, вышеприведенный пример вызовет ошибку E_COMPILE_ERROR.



Изменения, касающиеся оператора continue
Версия	Описание
5.4.0	continue 0; больше не допускается. В предыдущих версиях это воспринималось точно также как и continue 1;.
5.4.0	Убрана возможность задавать переменную (например, $num = 2; continue $num;) в качестве числового аргумента.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
echo "<br>................................................ARRAY......МАССИВ........................................................<br>";
In PHP, the array() function is used to create an array

	array(
	    key  => value,                                      // элемент ( индекс - значение)
	    key2 => value2,                                     // element (index(key)=(int or string) => value = any type(любой тип))
	    key3 => value3,                                     // index(key) != (array,object)  // warning
	    ...
	)

Запятая после последнего элемента массива необязательна и может быть опущена. Обычно это делается для однострочных массивов, т.е. array(1, 2) предпочтительней array(1, 2, ). Для многострочных массивов с другой стороны обычно используется завершающая запятая, так как позволяет легче добавлять новые элементы в конец массива.

Начиная с PHP 5.4 возможно использовать короткий синтаксис определения массивов, который заменяет языковую конструкцию array() на [].

	$array = array(
	    "foo" => "bar",
	    "bar" => "foo",
	);

	// Начиная с PHP 5.4
	$array = [
	    "foo" => "bar",
	    "bar" => "foo",
	];

key может быть либо типа integer, либо типа string. value может быть любого типа.

Дополнительно с ключом key будут сделаны следующие преобразования:  // TODO

Строки, содержащие целое число будут преобразованы к типу integer. 
Например, ключ со значением "8" будет в действительности сохранен со значением 8. С другой стороны, значение "08" не будет преобразовано, так как оно не является корректным десятичным целым.
Числа с плавающей точкой (тип float) также будут преобразованы к типу integer, т.е. дробная часть будет отброшена. Например, ключ со значением 8.7 будет в действительности сохранен со значением 8.
Тип bool также преобразовываются к типу integer. Например, ключ со значением true будет сохранен со значением 1 и ключ со значением false будет сохранен со значением 0.
Тип null будет преобразован к пустой строке. Например, ключ со значением null будет в действительности сохранен со значением "".

Массивы (тип array) и объекты (тип object) не могут использоваться в качестве ключей. При подобном использовании будет генерироваться предупреждение: Недопустимый тип смещения (Illegal offset type).

$a = [true => 'bool', 11.33 => '1.33',NULL => 'null',08=>'08','smth','04'=>04,'smth2'];

print_r($a);      // Array([1] => bool [11] => 1.33 [] => null [0] => 08 [12] => smth [04] => 4 [13] => smth2)

var_dump($a);     // array(5) { [1]=>string(4) "bool"  [11]=>string(4) "1.33"  [""]=>string(4) "null"  [0]=>string(2) "08"   [12]=>string(4) "smth"
                   // ["04"]=>int(4)  [13]=> string(5) "smth2" }

Если несколько элементов в объявлении массива используют одинаковый ключ, то только последний будет использоваться, а все другие будут перезаписаны.//TODO
	$array = array(
	    1    => "a",
	    "1"  => "b",
	    1.5  => "c",
	    true => "d",
	);
	var_dump($array);                //     array(1) {  [1]=> string(1) "d"  }
Так как все ключи в вышеприведенном примере преобразуются к 1, значение будет перезаписано на каждый новый элемент и останется только последнее присвоенное значение "d". 						 
	..............................................
	$array = array(
	    "foo" => "bar",
	    "bar" => "foo",
	    77  => -100,
	    -100  => 100,
                     "smth",
	);
	#Array([foo] => bar [bar] => foo [77] => -100 [-100] => 100 [78] => smth)
	/*
	array(5) {
	  ["foo"]=>string(3) "bar"
	  ["bar"]=>string(3) "foo"
	  [77]=>int(-100)
	  [-100]=>int(100)
	  [78]=>string(4) "smth"                              ////#
	}
	*/
	...................................
	$array = array(
		 "a",
		 "b",
	    6 => "c",
		 "d",
	);

	// Array([0] => a [1] => b [6] => c [7] => d)

....................................
	$array = array(
	    "foo" => "bar",
	    42    => 24,
	    "multi" => array(
		 "dimensional" => array(
		     "array" => "foo"
		 )
	    )
	);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);
..................................
 $arr[key] = value;
    $arr[] = value;
    // key может быть integer или string
    // value может быть любым значением любого типа

Если массив $arr еще не существует, он будет создан. Таким образом, это еще один способ определить массив array. Однако такой способ применять не рекомендуется, так как если переменная $arr уже содержит некоторое значение (например, значение типа string из переменной запроса), то это значение останется на месте и [] может на самом деле означать доступ к символу в строке. Лучше инициализировать переменную путем явного присваивания значения.


....
	$arr = array(5 => 1, 12 => 2);

	$arr[] = 56;    // В этом месте скрипта это
		        // то же самое, что и $arr[13] = 56;

	$arr["x"] = 42; // Это добавляет к массиву новый
		        // элемент с ключом "x"
		        
	unset($arr[5]); // Это удаляет элемент из массива

	unset($arr);    // Это удаляет массив полностью



Массивы в PHP могут содержать ключи типов integer и string одновременно, так как PHP не делает различия между индексированными и ассоциативными массивами.

	$a = array(1 => 'один', 2 => 'два', 3 => 'три');
	unset($a[2]);
	/* даст массив, представленный так: $a = array(1 => 'один', 3 => 'три');
	   а НЕ так:              $a = array(1 => 'один', 2 => 'три');
	*/

	$b = array_values($a);
	// Теперь $b это array(0 => 'один', 1 => 'три')

Функция unset() позволяет удалять ключи массива. Обратите внимание, что массив НЕ будет переиндексирован. Если вы действительно хотите поведения в стиле "удалить и сдвинуть", можно переиндексировать массив используя       array_values().

Всегда заключайте в кавычки строковый литерал в индексе ассоциативного массива. К примеру, пишите $foo['bar'], а не $foo[bar].    // TODO
Замечание: // TODO
Это не означает, что нужно всегда заключать ключ в кавычки. Нет необходимости заключать в кавычки константы или переменные, поскольку это помешает PHP обрабатывать их.

	error_reporting(E_ALL);  // Показываем все ошибки
	ini_set('display_errors', true);
	ini_set('html_errors', false);
	// Простой массив:
	$array = array(1, 2);
	$count = count($array);
	for ($i = 0; $i < $count; $i++) {
	    echo "\nПроверяем $i: \n";
	    echo "Плохо: " . $array['$i'] . "\n";
	    echo "Хорошо: " . $array[$i] . "\n";
	    echo "Плохо: {$array['$i']}\n";
	    echo "Хорошо: {$array[$i]}\n";
	}
.........................
$names = array ("john", "nathan", array ("vikash", "ankit"),"ankesh");
echo (count($names,1)); //6
If mode parameter in count is set to true, count() will recursively count the array.
echo (count($names));    //4
.............

	$arr = array('fruit' => 'apple', 'veggie' => 'carrot');
	/ Верно
	print $arr['fruit'];  // apple
	print $arr['veggie']; // carrot

	// Давайте определим константу, чтобы продемонстрировать, что
	// происходит. Мы присвоим константе с именем fruit значение 'veggie'.
	define('fruit', 'veggie');

	// Теперь обратите внимание на разницу
	print $arr['fruit'];  // apple
	print $arr[fruit];    // carrot
//??
Замечание: //TODO
 Повторим, внутри строки (string), заключенной в двойные кавычки, корректно не окружать индексы массива кавычками, поэтому "$foo[bar]" является верной записью. Более подробно почему - смотрите вышеприведенные примеры, а также раздел обработка переменных в строках.

....Преобразование в массив 

Для любого из типов: integer, float, string,resource, boolean , преобразование значения в массив дает результатом массив с одним элементом (с индексом 0), являющимся скалярным значением, с которого вы начали. Другими словами, (array)$scalarValue - это точно то же самое, что и array($scalarValue).

Если вы преобразуете в массив объект (object), вы получите в качестве элементов массива свойства (переменные-члены) этого объекта.
 Ключами будут имена переменных-членов, с некоторыми примечательными исключениями: 
целочисленные свойства станут недоступны; 
к закрытым полям класса (private) спереди будет дописано имя класса; 
к защищенным полям класса (protected) спереди будет добавлен символ '*'.
 Эти добавленные значения с обоих сторон также имеют нулевые байты. Это может вызвать несколько неожиданное поведение:
class A {
    private $A; // Это станет '\0A\0A'
}

class B extends A {
    private $A; // Это станет '\0B\0A'
    public $AA; // Это станет 'AA'
}

var_dump((array) new B());

Вышеприведенный код покажет 2 ключа с именем 'AA', хотя один из них на самом деле имеет имя '\0A\0A'.

Если вы преобразуете в массив значение NULL, вы получите пустой массив.

Сравнение 

Массивы можно сравнивать при помощи функции array_diff() и операторов массивов. //TODO
(PHP 4 >= 4.0.1, PHP 5, PHP 7)

array_diff — Вычислить расхождение массивов
array array_diff ( array $array1 , array $array2 [, array $... ] )

Сравнивает array1 с одним или несколькими другими массивами и возвращает значения из array1, которые отсутствуют во всех других массивах.// TODO
array1  // Исходный массив
array2 // Массив, с которым идет сравнение

....
Дополнительные массивы, с которыми осуществляется сравнение
Возвращает array, содержащий элементы array1, отсутствующие в любом из всех остальных массивах.
$array1 = array("a" => "green", "red", "blue", "red");
$array2 = array("b" => "green", "yellow", "red");
$result = array_diff($array1, $array2);

print_r($result);
Множественные совпадения в $array1 обрабатываются как одно. Результат будет следующим :

Array
(
    [1] => blue
)

...................
$array1 = array("b" => "green", "yellow", "red");
$array2 = array("b" => "green", "yellow", "red");
$result = array_diff($array1, $array2);
print_r($result);                          // Array()

.................
Замечание:// TODO
Два элемента считаются одинаковыми тогда и только тогда, если (string) $elem1 === (string) $elem2. Другими словами, когда их строковое представление идентично.
Замечание:
Обратите внимание, что эта функция обрабатывает только одно измерение n-размерного массива. Естественно, вы можете обрабатывать и более глубокие уровни вложенности, например, используя array_diff($array1[0], $array2[0]);.

							Операторы, работающие с массивами
Пример				Название								Результат

$a + $b				Объединение					Объединение массива $a и массива $b.

$a == $b			Равно						TRUE в случае, если $a и $b содержат одни и те
                                                                                    же пары ключ/значение. // TODO

$a === $b			Тождественно равно				TRUE в случае, если $a и $b содержат одни и те
                                                                                же паты ключ/значение в том же самом порядке и 												того же типа.

$a != $b			Не равно					TRUE, если массив $a не равен массиву $b.

$a <> $b			Не равно					TRUE, если массив $a не равен массиву $b.

$a !== $b			Тождественно не равно				TRUE, если массив $a не равен тождественно
                                                                                          массиву $b.

// TODO
Оператор + возвращает левый массив, к которому был присоединен правый массив. Для ключей, которые существуют в обоих массивах, будут использованы значения из левого массива, а соответствующие им элементы из правого массива будут проигнорированы.
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Объединение $a и $b
echo "Объединение of \$a and \$b: \n";
var_dump($c);
/*
array(3) {
  ["a"] => string(5) "apple"
  ["b"] => string(6) "banana"
  ["c"] => string(6) "cherry"
}
*/
$c = $b + $a; // Объединение $b и $a
echo "Объединение of \$b and \$a: \n";
var_dump($c);
/*
array(3) {
  ["a"] => string(4) "pear"
  ["b"] => string(10) "strawberry"
  ["c"] => string(6) "cherry"
}

*/
При сравнении элементы массива считаются идентичными, если совпадает и ключ, и соответствующее ему значение.
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)

Функции для работы с массивам       http://php.net/manual/ru/ref.array.php
      
/////////////////
............................Примеры 

The array type in PHP is very versatile(разносторонний). Here are some examples: Тип массив в PHP является очень гибким, вот несколько примеров:

<?php
// это
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                           4        // ключом будет 0
          );

$b = array('a', 'b', 'c');

// . . .полностью соответствует
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        =  4;        // ключом будет 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// после выполнения этого кода, $a будет массивом
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round', 'name' => 'apple', 0 => 4), 
//а $b будет  array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c').
?>
Пример #8 Использование array()

<?php
// Массив как карта (свойств)
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// исключительно числовые ключи
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// это то же самое, что и array(0 => 7, 1 => 8, ...)

$switching = array(         10, // ключ = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // ключ = 6 (максимальным числовым индексом было 5)
                    '8'  =>  2, // ключ = 8 (число!)
                    '02' => 77, // ключ = '02'
                    0    => 12  // значение 10 будет перезаписано на 12
                  );
                  
// пустой массив
$empty = array();         
?>
Пример #9 Коллекция

<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Вам нравится $color?\n";
}

?>
Результат выполнения данного примера:

Вам нравится red?
Вам нравится blue?
Вам нравится green?
Вам нравится yellow?
Изменение значений массива напрямую стало возможным с версии PHP 5 путем передачи их по ссылке. До этого необходим следующий обходной прием:

Пример #10 Изменение элемента в цикле

<?php
// PHP 5
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* это нужно для того, чтобы последующие записи в
$color не меняли последний элемент массива */

// Обходной прием для старых версий
foreach ($colors as $key => $color) {
    $colors[$key] = strtoupper($color);
}

print_r($colors);
?>
Результат выполнения данного примера:

Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
Следующий пример создает массив, начинающийся с единицы.

Пример #11 Индекс, начинающийся с единицы

<?php
$firstquarter  = array(1 => 'Январь', 'Февраль', 'Март');
print_r($firstquarter);
?>
Результат выполнения данного примера:

Array 
(
    [1] => 'Январь'
    [2] => 'Февраль'
    [3] => 'Март'
)
Пример #12 Заполнение массива

<?php       // TODO
// заполняем массив всеми элементами из директории
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle); 
?>
Массивы упорядочены. Вы можете изменять порядок элементов, используя различные функции сортировки. Для дополнительной информации смотрите раздел функции для работы с массивами. 
Вы можете подсчитать количество элементов в массиве с помощью функции count().

Пример #13 Сортировка массива

<?php
sort($files);
print_r($files);
?>
Поскольку значение массива может быть чем угодно, им также может быть другой массив. Таким образом вы можете создавать рекурсивные и многомерные массивы.

Пример #14 Рекурсивные и многомерные массивы

<?php
$fruits = array ( "фрукты"  => array ( "a" => "апельсин",
                                       "b" => "банан",
                                       "c" => "яблоко"
                                     ),
                  "числа"   => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "дырки"   => array (      "первая",
                                       5 => "вторая",
                                            "третья"
                                     )
                );

// Несколько примеров доступа к значениям предыдущего массива
echo $fruits["дырки"][5];    // напечатает "вторая"
echo $fruits["фрукты"]["a"]; // напечатает "апельсин"
unset($fruits["дырки"][0]);  // удалит "первая"

// Создаст новый многомерный массив
$juices["apple"]["green"] = "good"; 

//TODO
Обратите внимание, что при присваивании массива всегда происходит копирование значения. Чтобы скопировать массив по ссылке, вам нужно использовать оператор ссылки.

<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 изменился,
             // $arr1 все еще array(2, 3)
             
$arr3 = &$arr1;
$arr3[] = 4; // теперь $arr1 и $arr3 одинаковы


//////////////////////  TODO
array_diff — Вычислить расхождение массивов
array_intersect — Вычисляет схождение массивов
array_merge — Сливает один или большее количество массивов
array_unique — Убирает повторяющиеся значения из массивa
....
is_array — Определяет, является ли переменная массивом  // Возвращает TRUE, если переменная var является массивом array, или FALSE в противном случае.
..............................................................
explode — Разбивает строку с помощью разделителя

array explode ( string $delimiter , string $string [, int $limit ] )
Возвращает массив строк, полученных разбиением строки string с использованием delimiter в качестве разделителя.
delimiter  // Разделитель.
string  //  Входная строка.
limit  //Если аргумент limit является положительным, возвращаемый массив будет содержать максимум limit элементов, при этом последний элемент будет содержать остаток строки
         string.
Если параметр limit отрицателен, то будут возвращены все компоненты кроме последних -limit.Если limit равен нулю, то он расценивается как 1.
// Пример 1
$pizza  = "кусок1 кусок2 кусок3 кусок4 кусок5 кусок6";
$pieces = explode(" ", $pizza);
echo $pieces[0]; // кусок1
echo $pieces[1]; // кусок2

// Пример 2
$data = "foo:*:1023:1000::/home/foo:/bin/sh";
list($user, $pass, $uid, $gid, $gecos, $home, $shell) = explode(":", $data);
echo $user; // foo
echo $pass; // *
.......................................................................
implode — Объединяет элементы массива в строку

string implode ( string $glue , array $pieces )
string implode ( array $pieces )

glue // По умолчанию равен пустой строке.
pieces // Массив объединяемых строк.

$array = array('имя', 'почта', 'телефон');
$comma_separated = implode(",", $array);

echo $comma_separated; // имя,почта,телефон

// Пустая строка при использовании пустого массива:
var_dump(implode('hello', array())); // string(0) ""

........................................................................
split — Разбиение строки на массив по регулярному выражению // УСТАРЕЛА
Функция split() является устаревшей начиная с PHP 5.3.0. Предлагается использовать вместо неё функцию preg_split(). В случае, когда нет необходимости использовать регулярные выражения, эффективнее использовать explode(), которая не использует дополнительные ресурсы для разбора регулярного выражения.
........................................................................
preg_split — Разбивает строку по регулярному выражению //TODO

array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )
pattern // Искомый шаблон, строка.
subject // Входная строка.
limit //Если указан, функция возвращает не более, чем limit подстрок, оставшаяся часть строки будет возвращена в последней подстроке. Специальное значение limit, равное -1, 0 или NULL подразумевает отсутствие ограничения, и, в качестве фактического стандарта в PHP, можно использовать NULL для пропуска параметра flags.
flags // flags может быть любой комбинацией следующих флагов (объединенных с помощью побитового оператора |):

PREG_SPLIT_NO_EMPTY // Если указан этот флаг, функция preg_split() вернет только непустые подстроки.
PREG_SPLIT_DELIM_CAPTURE // Если указан этот флаг, выражение, заключенное в круглые скобки в разделяющем шаблоне, также извлекается из заданной строки и возвращается функцией.
PREG_SPLIT_OFFSET_CAPTURE // Если указан этот флаг, для каждой найденной подстроки будет указана ее позиция в исходной строке. Необходимо помнить, что этот флаг меняет формат возвращаемого массива: каждый элемент будет содержать массив, содержащий в индексе с номером 0 найденную подстроку, а смещение этой подстроки в параметре subject - в индексе 1.
Возвращает массив, состоящий из подстрок заданной строки subject, которая разбита по границам, соответствующим шаблону pattern.

Получение подстрок из заданного текста
// разбиваем строку по произвольному числу запятых и пробельных символов,
// которые включают в себя  " ", \r, \t, \n и \f
$keywords = preg_split("/[\s,]+/", "hypertext language, programming");
print_r($keywords);

Array
(
    [0] => hypertext
    [1] => language
    [2] => programming
)

Разбиваем строку на составляющие символ
$str = 'string';
$chars = preg_split('//', $str, -1, PREG_SPLIT_NO_EMPTY);
print_r($chars);

Array
(
    [0] => s
    [1] => t
    [2] => r
    [3] => i
    [4] => n
    [5] => g
)

Разбиваем строку с указанием смещения для каждой из найденных подстрок
$str = 'hypertext language programming';
$chars = preg_split('/ /', $str, -1, PREG_SPLIT_OFFSET_CAPTURE);
print_r($chars);

Array
(
    [0] => Array
        (
            [0] => hypertext
            [1] => 0                  //позиция в исходной строке
        )

    [1] => Array
        (
            [0] => language
            [1] => 10                // позиция в исходной строке
        )

    [2] => Array
        (
            [0] => programming
            [1] => 19                 // позиция в исходной строке
        )

)

....................................................................
array_reverse — Возвращает массив с элементами в обратном порядке
array_multisort — Сортирует несколько массивов или многомерные массивы
array_replace — Замена элементов массива элементами других переданных массивов
array_search — Осуществляет поиск данного значения в массиве и возвращает соответствующий ключ в случае удачи 
..............................................................................
list — Присваивает переменным из списка значения подобно массиву
array list ( mixed $var1 [, mixed $... ] )

---- Подобно array(), это не функция, а языковая конструкция. list() используется для того, чтобы присвоить списку переменных значения за одну операцию.

var1 // Переменная.
Возвращает присвоенный массив.
$info = array('кофе', 'коричневый', 'кофеин');

// Составить список всех переменных
list($drink, $color, $power) = $info;
echo "$drink - $color, а $power делает его особенным.\n";

// Составить список только некоторых из них
list($drink, , $power) = $info;
echo "В $drink есть $power.\n";

// Или только третья
list( , , $power) = $info;
echo "Мне нужен $power!\n";

// list() не работает со строками
list($bar) = "abcde";
var_dump($bar); // NULL

Пример использования list() // TODO ..................................

<table>

 <tr>
  <th>Имя работника</th>
  <th>Зарплата</th>
 </tr>

<?php
$result = $pdo->query("SELECT id, name, salary FROM employees");
while (list($id, $name, $salary) = $result->fetch(PDO::FETCH_NUM)) {
    echo " <tr>\n" .
          "  <td><a href=\"info.php?id=$id\">$name</a></td>\n" .
          "  <td>$salary</td>\n" .
          " </tr>\n";
}

?>

</table>
........................................

Использование list() с индексами массива
<?php
$info = array('кофе', 'коричневый', 'кофеин');

list($a[0], $a[1], $a[2]) = $info;

var_dump($a);
Внимание
---- list() присваивает значения начиная с крайнего правого параметра. Если вы используете простые переменные, можете не беспокоиться об этом. Но если вы используете индексные массивы, вы можете ожидать, что в результате выполнения функции list() вы получите тот же порядок элементов, что и в исходном массиве: слева направо; однако это не так. Они будут присвоены в обратном порядке.
Внимание
Изменение массива во время выполнения функции list() (например, использование list($a, $b) = $b) приводит к непредсказуемому поведению.
Замечание:
---- list() работает только с массивами, индексами которых являются числа и нумерация которых начинается с 0.//TODO

///////////////////////
Indexed arrays - Arrays with a numeric index
Associative arrays - Arrays with named keys
Multidimensional arrays - Arrays containing one or more arrays

$cars = array("Volvo", "BMW", "Toyota");
echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".<br>";
print($cars[1]);
$h2 = count($cars);    // кол-во элементов массива
echo "<br> Array has $h2 elements";
$h3 = $h2 + 4;
echo "<br> Array does't has " .$h3. " elements";
echo "<br>......................<br>";
$age = array("Peter"=>"35", "Ben"=>"37", "Joe"=>"43"); // ассоциативный масссив
echo "Peter is " . $age['Peter'] . " years old.<br>";
print($age['Ben']);
echo "<br>......................<br>";
foreach($age as $key => $key_value) {
    echo "Key=" . $key  . ", Value=" . $key_value;
    echo "<br>";
}

echo "<br>.......Multidimensional Arrays.......................................................<br>";

$cars1 = array
  (
  array("Volvo",22,18),
  array("BMW",15,13),
  array("Saab",5,2),
  array("Land Rover",17,'sss'=>15)
  );

echo '<pre>';
print_r($cars1);
echo '</pre>';
echo "<br>............cars1[2].....<br>";

echo '<pre>';
print_r($cars1[2]);
echo '</pre>';

echo '<pre>';
print_r($cars1[3]['sss']);
echo '</pre>';


for ($row = 0; $row < count($cars1); $row++) {
  echo "<p><b>Row number $row</b></p>";
  echo "<ul>";
  for ($col = 0; $col < count($cars1[$row]); $col++) {
    echo "<li>".$cars1[$row][$col]."</li>";
  }
  echo "</ul>";
}
// exit("<p> Работа программы завершена </p>");



$objects=array(
'Банка содовой' => array('Форма'=> 'Цилиндр',
			'Цвет'=> 'Красный',
			'Материал' => 'Металл'),
'Блокнот' => array('Форма'=> 'Прямоугольник',
		   'Цвет'=> 'Белый',
	           'Материал' => 'Бумага'),
'Яблоко' => array('Форма'=> 'Шар',
	          'Цвет'=> 'Красный',
	          'Материал' => 'Фрукт'),
'Апельсин' => array('Форма'=> 'Шар',
	            'Цвет'=> 'Оранжевый',
	            'Материал' => 'Фрукт'),
'Телефонная книга' => array('Форма'=> 'Прямоугольник',
	                    'Цвет'=> 'Желтый',
	                    'Материал' => 'Бумага')  );
echo $objects['Банка содовой']['Форма'];

foreach ($objects as $obj_key => $obj)                        // TODO
{
echo "$obj_key:<br>";
while (list ($key,$value)=each ($obj))
{
echo "$key = $value ";
}
echo "<br />";
}
....................
each — Возвращает текущую пару ключ/значение из массива и смещает его указатель.
После выполнения each(), указатель массива перемещается к следующему его элементу, пока не будет достигнут конец массива. Для повторного обхода массива при помощи each необходимо использовать функцию reset().
ach() обычно используется совместно с list() для обхода массива, как в этом примере:

Пример #2 Обход массива функцией each()

<?php
$fruit = array('a' => 'apple', 'b' => 'banana', 'c' => 'cranberry');

reset($fruit);
while (list($key, $val) = each($fruit)) {
    echo "$key => $val\n";
}

////////////////////////////////////// рекурсия ////////////////////////////////////////////////////////////
<!DOCTYPE html>
<!-- The new doctype -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Recursion</title>

</head>

<body>

	<?php 

$arrayName = array(  //1 ......................
	'Автотехника' =>
	array(                  //2
		'Вело' =>  array(              //3
			'Велосипеды' =>array(
				'(товар) Extream' => 10, //4
				'(товар) Author' => 4    //4
				),
			 
		'Самокаты' => 12   //3
	), 
'Авто' =>  array(    //2
	'Opel' => array(    //3
		'(товар) Vivaro' => 5   //4
	),
	'(товар) Honda' => 10,    //3
	'(товар) Audi' => 11    //3
),
'(товар) Аксессуары' => 7        //2
),
'Фототехника' =>  array(               //1
	'(товар) Фотокамеры' => 10,    //2
	'(товар) Видеокамеры' => 10   //2
	),
'(товар) Другое' => 10   //1
);

echo '<pre>';
print_r($arrayName );
echo '</pre>';

 echo "<br>";
//.......
	function sum ($arrayName,$level = 0){                              // TODO

	static $count;
	static $items;
	 if (is_array($arrayName)) {
	 	$level++;
	 	foreach ($arrayName as $element) {
	 		sum($element, $level);
	 	}
	 } else{
	 	$count++;
	 	$items += $arrayName;

	 }
	return array ('count' => $count, 'items' => $items);
	}
$result = sum($arrayName);
print_r($result);


</body>
</html>
////////////////////////////////////
Навигация по массивам в PHP

Навигация по массива дает возможно узнать текущий , следующий, предыдущий, последний элемента массива.

Для определения текущего элемента массива используют функцию current:

<?php
echo "Now is: ", current($arr), "<br>";
?>
Для определения следующего элемента массива используют функцию next:

<?php
echo "Next is: ", next($arr), "<br>";
?>
Для определения предыдущего элемента массива используют функцию prev:

<?php
echo "Previously is: ", prev($arr), "<br>";
?>
Для определения последнего элемента массива используют функцию end:

<?php
echo "The end is: ", end($arr), "<br>";
?>
Для определения первого (возврата указателя) элемента массива используют функцию reset:

<?php
echo "First is: ", reset($arr), "<br>";
?>
Пример навигации по массивам:

<?php
$arr[0] = "PHP"; 
$arr[1] = "HTML"; 
$arr[2] = "CSS";

echo "Now is: ", current($arr), "<br>";
echo "Next is: ", next($arr), "<br>";
echo "Previously is: ", prev($arr), "<br>";
echo "The end is: ", end($arr), "<br>";
echo "First is: ", reset($arr), "<br>";

Отображение в браузере:

Now is: PHP
Next is: HTML
Previously is: PHP
The end is: CSS
First is: PHP

/////////////////////////////////////////////////////////
(Котеров с.279(252))
Кажая ф-ция добавляется во внутреннюю таблицу ф-ций PHP тогда,когда управление доходит до участка программы, содержащего определение этой ф-ции.// ????
	function father($a){
	     function child($b){
	     }

        }
//1   OK
father(10);
child(20);  // тело ф-ции пропускается,имя фиксируется

//2    
child(20);   // процесс выполнения программы недошел до определения ф-ции  
father(10);

//3                
father(10);
father(10);     // Error  повторное определение child()
// Fatal error: Cannot redeclare child() (previously declared in /home/valentin/t.php:4) in /home/valentin/t.php on line 4
...........................................
Технология отложенного копирования (Котеров с.284(257))   // TODO   at the end


...........................


Управление функциями              http://php.net/manual/ru/ref.funchand.php

call_user_func_array — Вызывает пользовательскую функцию с массивом параметров                 // TODO
call_user_func — Вызывает пользовательскую функцию, указанную в первом параметре                  // TODO

create_function — Создаёт анонимную (лямбда) функцию
forward_static_call_array — Call a static method and pass the arguments as array
forward_static_call — Call a static method
func_get_arg — Возвращает элемент из списка аргументов
func_get_args — Возвращает массив, содержащий аргументы функции
func_num_args — Возвращает количество аргументов, переданных функции
function_exists — Возвращает TRUE, если указанная функция определена
get_defined_functions — Возвращает массив всех определённых функций
register_shutdown_function — Регистрирует функцию, которая выполнится по завершении работы скрипта
register_tick_function — Регистрирует функцию для выполнения при каждом тике
unregister_tick_function — Удаляет функцию из списка зарегистрированных для выполнения при каждом тике
..................
call_user_func()  запускает на выполнение подпрограмму, имя которой указ. в ее 1м параметре, и передает ей аргументы, заданные в остальных.
В качестве 1го параметра ф-ции может быть передано не только строковое значение, но и массив из двух элемнтов:
- имя класса (или ссылку на объект класса)
- имя метода класса

function A($i) {echo "Вызвана A($i)\n";}
function B($i) {echo "Вызвана B($i)\n";}
function C($i) {echo "Вызвана C($i)\n";}

$F = "A";          // или $F = "B"  или  $F = "C"

call_user_func($F, 101); // вызов ф-ции, имя которой хранится в $F


..........................
call_user_func_array() предназ.для вызова подпрограмм, когда на момент вызова точно неизвестно, сколько именно аргументов им следует передать.
В отличие от call_user_func(), параметры вызыв. подпрограмме передаются не последовательно, а в виде одного-единственного списка.








echo "<br>................................................Function..............<br>";

function familyName($fname, $year) {
    echo "$fname Refsnes. Born in $year <br>";
}
familyName("Hege", "1975");

function setHeight($minheight = 50) {
    echo "The height is : $minheight <br>";
}
setHeight(350);
setHeight(); // will use the default value of 50

function sum($x, $y) {
    $z = $x + $y;
    return $z;
}
echo "5 + 10 = " . sum(5, 10) . "<br>";
$h = sum(123,44);
echo $h;
echo "<br>......................<br>";

function l(){
echo "<a href='http://www.w3schools.com'> Школа </a>";
}
l();

echo "<br>......................<br>";

function f($link,$title){
echo "<a href='$link'> $title </a>";
}
f('http://www.w3schools.com','School');
.........................php7
function add2ints(int $x, int $y):int
{
    $z = $x + $y;
    if ($z===0)
    {
        return (int)0; // ??
    }
    return $z;
}

$a = add2ints(3, 4);
echo is_null($a) ? 0 : $a;             // 7
echo "\n";
$b = add2ints(-2, 2);
echo is_null($b) ? 0 : $b;                // 0

echo "<br>........................................................<br>";


$w = " Слово ";
$w = trim($w); // обрезает пробелы
echo $w;
echo "<br>........................................................<br>";

$info = array('кофе', 'коричневый', 'кофеин');
//Составить список всех переменных
list($drink, $color, $power) = $info;
echo "$drink - $color, а $power делает его особенным.\n";

echo "<br>........................................................<br>";

$d = date("d-m-Y");
echo "$d <br>";
$d1 = date("r");
echo $d1;
http://php.net/manual/ru/function.date.php

echo"<br>.............isset....unset...................................<br>";
$z1 = isset($w); // 1  если существет
$z2 = isset($tttt); // возвр. постоту если не существ.
echo $z2;
echo $z1;

$v = 10;
unset($v); // уничтожает переменную
echo "<br>$v";


echo "<br>.......srting...............<br>";
// кодировка ,файл для настройки сервера(.htaccess(AddDefaultCharset utf-8))                    ?????????
$d = 10;
echo 'Это пример строки $d';
echo "<br>";
echo "Это пример строки $d\"Ковычки\" ****<br>";
// В 80х или 90х годах
$h = 80;
$y = 90;
echo "В $hх или {$y}х годах\n"; // $hx не раб.          {$y} OK

echo "<br>.......оператор склеивания(точка)..............<br>";
$firstname = 'Виктор';
$lastname = 'Зинченко';
$fullname = $firstname . $lastname;
echo $fullname ;
echo "<br>";
$fullname = $firstname.' '.$lastname;
echo $fullname;
echo "<br>";
$test = 'Первая часть';
$test .= 'Вторая часть';
echo $test;
echo "<br>.......null..............<br>";
$a = null;
echo gettype($a);
unset($a);
echo "<br>";
echo gettype($a);
echo "<br>.......приведение типов..............<br>";
echo "<br>.......Возможны преобразоваия в такие типы : integer,boolean,float,string,array,object,unset(null).............<br>";
$a = "5 человек";
$a = (integer)$a;
echo $a;
echo "<br>";
echo "<br>.......неявное преобразование..............<br>";
/*
$s = "5 человек"; // string
$f = 10; // integer
$c = $s + $f // $c - integer
echo $c;
// выдает ошибку ?????
*/
echo "<br>.......if..............<br>";

$array = array();

if($array){
echo "Массив с элементами";

} else {
echo "Массив без элементов";
}

echo "<br>.......тернарный оператор.............<br>";

$status = false;
echo ($status) ? "Вкл.":"Откл.";
$w = ($status) ? "Вкл.":"Откл.";


In PHP 7, a new feature, null coalescing(сливающихся) operator (??) 

// fetch the value of $_GET['user'] and returns 'not passed' if username is not passed
   $username = $_GET['username'] ?? 'not passed';
   print($username);

   // Equivalent code using ternary operator
   $username = isset($_GET['username']) ? $_GET['username'] : 'not passed';
   print($username);

   // Chaining ?? operation
   $username = $_GET['username'] ?? $_POST['username'] ?? 'not passed';
   print($username);

...............................................................



function add2ints(int $x, int $y):int
{
    $z = $x + $y;
    if ($z===0)
    {
        return null; // ??
    }
    return $z;
}

$a = add2ints(3, 4);
echo is_null($a) ? 'Null' : $a;
$b = add2ints(-2, 2);
echo is_null($b) ? 'Null' : $b;




function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));


echo "<br>.......Предопределенные константы.............<br>";

echo __FILE__ ."<br>";
echo __LINE__ ."<br>";
echo PHP_VERSION ."<br>";
echo PHP_OS ."<br>";

echo "<br>.......Определение констант(define).............<br>";
define("pi", 3.14);
//if(defined(pi))   // bool defind(type $name)
echo sin(pi/4)."<br>";

echo "<br>.......Отладочные ф-ции  .............<br>";
$a = array('a'=> 'apple', 'b'=>'banana');
echo "<pre>";  print_r($a); echo "</pre>";

$b = array(1, array("a","bc"));
echo "<pre>";  var_dump($b); echo "</pre>";

$c = array(1, array("Hello World","d'BCC"));
echo "<pre>";  var_export($c); echo "</pre>";

class SomeClass{
private $x = 100;
public $s = 200;
}
$obj = new SomeClass();
echo "<pre>";  var_export($obj); echo "</pre>";

echo "<br>.......Преобразования  .............<br>";
$s = "123";
$i = (int)$s;
//$i = intval($s);
echo "$s:".gettype($s). ", $i:".gettype($i);
/*
echo "<br>...................<br>";
include(‘add.php’);
include(‘add.php’);
echo add(2, 2);                       //// error

include_once(‘add.php’);
include_once(‘add.php’);
echo add(2, 2);                            //// 4

echo "<br>...................<br>";
require_once('add_wrong.php');
echo add(2, 2);                             ////  include и include_once
*/
echo "<br>...................<br>";
$test=function_exists("test_this");
if ($test == TRUE)
{
echo "Функция test_this существует.";
}
else
{
echo "Функция test_this не найдена.";
//call_different_function();
}

Функция sort() выполняет сортировку массива
Числовые значения сортируются как числа,а строки – в алфавитном порядке.Эта функция назначает элементам массива новые ключи. Она удаляет все имевшиеся ключи, которые,возможно, назначили вы, вместо того чтобы переупорядочить их.
Возможные значения второго необязательного параметра sort_flags , позволяющего влиять на процедуру сортировки. 

Функция asort() работает точно так же, как функция sort , но при этом учитывает взаимосвязь между значениями и их ключами. Как правило, для сортировки ассоциативных массивов применяют именно эту функцию.
bool asort ( array &$array [, int $sort_flags = SORT_REGULAR ] )
array
Входной массив.

sort_flags
Вы можете изменить поведение сортировки, используя дополнительный параметр sort_flags, подробнее см. sort().
Возвращает TRUE в случае успешного завершения или FALSE в случае возникновения ошибки.
Флаги сортировки:

SORT_REGULAR - обычное сравнение элементов (без изменения типов)
SORT_NUMERIC - числовое сравнение элементов
SORT_STRING - строковое сравнение элементов
SORT_LOCALE_STRING - сравнивает элементы как строки с учетом текущей локали. Используется локаль, которую можно изменять с помощью функции setlocale()
SORT_NATURAL - сравнение элементов как строк, используя естественное упорядочение, аналогичное упорядочению в функции natsort()
SORT_FLAG_CASE - может быть объединен (побитовое ИЛИ) с константами SORT_STRING или SORT_NATURAL для сортировки строк без учета регистра.
Например:
	$capitals = array(“US” => “Washington”, “UK” => “London”, “Austria” => “Vienna”);
	asort($capitals);
	// $capitals = {“UK” => “London”, “Austria” => “Vienna”, “US” => “Washington”}

/*	sort($capitals); 
Array
(
    [0] => “London”
    [1] => “Vienna”
    [2] => “Washington”
)
*/
ksort() сортирует ассоциированный массив по значению ключей.

ksort($capitals);
// $capitals = {“Austria” => “Vienna”, “UK” => “London”, “US” => “Washington”}



https://secure.php.net/manual/ru/array.constants.php

$ar = [11,-1,77,8];
asort($ar);
Array
(
    [1] => -1
    [3] => 8
    [0] => 11
    [2] => 77
)
sort($ar);
Array
(
    [0] => -1
    [1] => 8
    [2] => 11
    [3] => 77
)

..................................
Определить текущее количество элементов в массиве можно с помощью функции count() .
 Функция count идентична функции sizeof() , они взаимозаменяемы.
........................................extract()............................................
Извлечение переменных из ассоциативного массива с помощью функции   extract()

функция extract() принимает в качестве параметра массив и создает локальные переменные
Функция extract может автоматически добавлять символ подчеркивания в начало имен переменных, предотвращая возможное замещение
уже используемой переменной. Символом подчеркивания в создаваемых именах переменных автоматически отделяются имя ключа и префикс.

extract($array,EXTR_PREFIX_ALL,"префикс");



$Apple="Компьютер";
$shapes=array('SodaCan' => 'Цилиндр',
              'NotePad' => 'Прямоугольник',
              'Apple' => 'Шар',
              'Orange' => 'Шар',
              'PhoneBook' => 'Прямоугольник');

extract($shapes,EXTR_PREFIX_ALL,"shapes");
// Теперь будут установлены переменные $shapes_SodaCan, $shapes_NotePad,
// $shapes_Apple, $shapes_Orange и $shapes_PhoneBook
echo "Apple – это $Apple.<br />";
echo "Shapes_Apple – это $shapes_Apple";
echo "<br />";
echo "Shapes_NotePad – это $shapes_NotePad";

Пример 6.10 выведет:

Apple – это Компьютер
Shapes_Apple – это Шар
Shapes_NotePad – это Прямоугольник
..............................compact()............................................
Функция compact действует противоположно функции extract

Она принимает в виде отдельных параметров переменные, массивы или комбинации тех и других и создает ассоциативный массив, ключами которо-
го служат имена переменных, а значениями элементов – значения переменных.
$SodaCan = 'Cylinder';
$NotePad =  'Rectangle';
$shapes=compact('SodaCan', 'NotePad');

..............
reset(массив)  // Принимает в качестве аргумента массив и переустанавливает указатель текущей позиции в начало массива.//TODO

array_push(массив, элементы)  // Добавляет один или больше элементов в конец существующего массива.
Например, инструкция  array_push($shapes, "камень", "бумага","ножницы"); добавит в массив $shapes три указанных элемента.

array_pop(массив)  // Удаляет и возвращает последний элемент массива.
Например, инструкция $last_element=array_pop($shapes); удалит из массива $shapes последний элемент, присвоив его значение переменной $last_element .

array_unshift(массив, элементы) // Добавляет один или больше элементов в начало существующего массива. 
Например, инструкция array_unshift($shapes, "камень", "бумага", "ножницы"); добавит в начало массива $shapes три указанных элемента.

array_shift(массив)  // Удаляет и возвращает первый элемент массива.
 Например, инструкция $first_element=array_shift($shapes); удалит первый элемент из массива $shapes , присвоив его значение переменной $first_element .


array_merge(массив1, массив2) // Объединяет два массива в один массив и возвращает новый массив.
Например, инструкция $combined_array=array_merge($shapes, $sizes); объединит элементы двух массивов и присвоит новый массив переменной $combined_array .

array_keys(массив) // Возвращает массив, содержащий все ключи исходного массива.  //TODO
Например, инструкция $keys=array_keys($shapes); запишет в массив $keys значения ключей, такие как "Яблоко" и "Блокнот" в массиве из примера 6.2.

array_values(массив) // Возвращает массив с числовыми индексами, содержащий все значения элементов исходного массива.//TODO
Например, инструкция $values=ar­ray_values($shapes); запишет в массив $values такие значения элементов, как "Шар" и "Прямоугольник" в массиве из примера 6.2.

shuffle(массив)  //  Переупорядочивает элементы массива случайным образом.
В процессе переупорядочивания значения ключей исходного массива будут утеряны, поскольку на выходе получится массив с числовым индексами.

array_unique — Убирает повторяющиеся значения из массива
...............................
array_count_values — Подсчитывает количество всех значений массива
Возвращает ассоциативный массив со значениями array в качестве ключей и их количества в качестве значений.
Пример:
$array = array(1, "hello", 1, "world", "hello");
print_r(array_count_values($array));

Array
(
    [1] => 2
    [hello] => 2
    [world] => 1
)


...................
count_chars — Возвращает информацию о символах, входящих в строку
Пример:
$data = "Two Ts and one F.";

foreach (count_chars($data, 1) as $i => $val) {
   echo "\"" , chr($i) , "\" встречается в строке $val раз(а).\n";
}
" " встречается в строке 4 раз(а).
"." встречается в строке 1 раз(а).
"F" встречается в строке 1 раз(а).
"T" встречается в строке 2 раз(а).
"a" встречается в строке 1 раз(а).
"d" встречается в строке 1 раз(а).
"e" встречается в строке 1 раз(а).
"n" встречается в строке 2 раз(а).
"o" встречается в строке 2 раз(а).
"s" встречается в строке 1 раз(а).
"w" встречается в строке 1 раз(а).
.......................................
array_flip — Меняет местами ключи с их значениями в массиве
array_reverse — Возвращает массив с элементами в обратном порядке

.........
https://secure.php.net/manual/ru/book.array.php

.................................................................

// Получение первого символа строки
$str = 'This is a test.';
$first = $str[0];

// Получение третьего символа строки
$third = $str[2];

// Получение последнего символа строки
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Изменение последнего символа строки
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';
....................

isset() - Определяет, была ли установлена переменная значением отличным от NULL

bool isset ( mixed $var [, mixed $... ] )
Определяет, была ли установлена переменная значением отличным от NULL

Если переменная была удалена с помощью unset(), то она больше не считается установленной. isset() вернет FALSE, если проверяемая переменная имеет значение NULL. Следует помнить, что NULL-байт ("\0") не является эквивалентом константе PHP NULL.

Если были переданы несколько параметров, то isset() вернет TRUE только в том случае, если все параметры определены. Проверка происходит слева направо и заканчивается, как только будет встречена неопределенная переменная.
Возвращает TRUE, если var определена и значение отличное от NULL, и FALSE в противном случае.

.................................................................................................
empty() - Проверяет, пуста ли переменная

bool empty ( mixed $var )
Проверяет, считается ли переменная пустой. Переменная считается пустой, если она не существует или её значение равно FALSE. empty() не генерирует предупреждение если переменная не существует.
Замечание:
До PHP 5.5 empty() проверяет только переменные, и попытка проверить что-то еще вызовет ошибку синтаксиса. Другими словами, следующий код не будет работать: empty(trim($name)). Используйте вместо него trim($name) == false.
Если переменная не существует, предупреждение не генерируется. Это значит, что empty() фактически является точным эквивалентом конструкции !isset($var) || $var == false

Возвращаемые значения 

Возвращает FALSE, если var существует, и содержит непустое и ненулевое значение. В противном случае возвращает TRUE.

Следующие значения воспринимаются как пустые:

"" (пустая строка)
0 (целое число)
0.0 (дробное число)
"0" (строка)
NULL
FALSE
array() (пустой массив)
$var; (переменная объявлена, но не имеет значения)
.....................
  Простое сравнение empty() и isset().

<?php
$var = 0;

// Принимает значение true, потому что $var пусто
if (empty($var)) {
    echo '$var или 0, или пусто, или вообще не определена';
}

// Принимает значение true, потому что $var определена
if (isset($var)) {
    echo '$var определена, даже если она пустая';
}
................
    empty() и строковые индексы
$expected_array_got_string = 'somestring';
var_dump(empty($expected_array_got_string['some_key']));
var_dump(empty($expected_array_got_string[0]));
var_dump(empty($expected_array_got_string['0']));
var_dump(empty($expected_array_got_string[0.5]));
var_dump(empty($expected_array_got_string['0.5']));
var_dump(empty($expected_array_got_string['0 Mostel']));

bool(true)
bool(false)
bool(false)
bool(false)
bool(true)
bool(true)

PHP Warning:  Illegal string offset 'ertert' in /home/valentin/t.php on line 120

echo $expected_array_got_string['ertert'];              // s

Замечание: Поскольку это языковая конструкция, а не функция, она не может вызываться при помощи переменных функций.
Замечание:
При использовании функции empty() на недоступных (необъявленных) свойствах объекта будет вызван встроенный метод объекта __isset(), если он определен.

..................................
__unset()
array_splice() - Удаляет часть массива и заменяет её чем-нибудь ещё  //TODO

unset — Удаляет переменную                           https://secure.php.net/manual/ru/function.unset.php
void unset ( mixed $var [, mixed $... ] )
unset() удаляет перечисленные переменные.
Поведение unset() внутри пользовательской функции может отличаться, в зависимости от того, какой тип имеет переменная, которую необходимо удалить.

----Если переменная, объявленная глобальной, удаляется внутри функции, то будет удалена только локальная переменная. Переменная в области видимости вызова функции сохранит то же значение, что и до вызова unset().
function destroy_foo() 
{
    global $foo;
    unset($foo);
}

$foo = 'bar';
destroy_foo();
echo $foo;          // bar

----Если необходимо удалить глобальную переменную внутри функции, то для этого нужно использовать массив $GLOBALS:


function foo() 
{
    unset($GLOBALS['bar']);           //TODO
}

$bar = "something";
foo();

Если переменная, которая передается ПО ССЫЛКЕ, удаляется внутри функции, то будет удалена только локальная переменная. Переменная в области видимости вызова функции сохранит то же значение, что и до вызова unset().

function f(&$v)                    //TODO
{
    unset($v);
}

$b = "something";
f($b);
echo $b;   // something


Если статическая переменная удаляется внутри функции, unset() удалит переменную только в контексте дальнейшего выполнения функции. При последующем вызове предыдущее значение переменной будет восстановлено.
.............................
// удаляем одну переменную
unset($foo);

// удаляем один элемент массива
unset($bar['quux']);

// удаляем несколько переменных
unset($foo1, $foo2, $foo3);

Пример #2 Использование приведения типа (unset)

Приведение типа (unset) часто путают с функцией unset(). Приведение типа (unset) приводит только к значению NULL и было добавлено исключительно для полноты реализации. Оно не меняет значение приводимой переменной.

<?php
$name = 'Felipe';

var_dump((unset) $name);  // NULL
var_dump($name);       //  string(6) "Felipe"
................

echo — Выводит одну или более строк

    void echo ( string $arg1 [, string $... ] )
Выводит все аргументы.

На самом деле echo - это не функция, а конструкция языка, поэтому заключать аргументы в скобки необязательно. echo (в отличии от других языковых конструкций) не ведет себя как функция, поэтому не всегда может быть использована в контексте функции. Вдобавок, если вы хотите передать более одного аргумента в echo, эти аргументы нельзя заключать в скобки.

echo имеет также краткую форму, представляющую собой знак равенства, следующий непосредственно за открывающим тэгом. До версии PHP 5.4.0, этот сокращенный синтаксис допускался только когда включена директива конфигурации short_open_tag.

I have <?=$foo?> foo.

Эта функция не возвращает значения после выполнения.
<?php
echo "Привет мир!";

echo "Это займет
несколько строк. Переводы строки тоже
выводятся";

echo "Это займет\nнесколько строк. Переводы строки тоже\nвыводятся";

echo "Экранирование символов делается \"Так\".";

// с echo можно использовать переменные ...
$foo = "foobar";
$bar = "barbaz";

echo "foo - это $foo"; // foo - это foobar

// ... и массивы
$baz = array("value" => "foo");

----echo "это {$baz['value']} !"; // это foo !      //TODO

//echo "это $baz['value'] !"; // syntax error       //TODO
// echo "это $baz[value] !"; // это foo !           //TODO

// При использовании одиночных кавычек выводится имя переменной, а не значение      //TODO
echo 'foo - это $foo'; // foo - это $foo

// Если вы не используете другие символы, можно вывести просто значения переменных
echo $foo;          // foobar
echo $foo,$bar;     // foobarbarbaz

// Некоторые предпочитают передачу нескольких аргументов вместо конкатенации
echo 'Эта ', 'строка ', 'была ', 'создана ', 'несколькими параметрами.', chr(10);
echo 'Эта ' . 'строка ' . 'была ' . 'создана ' . 'с помощью конкатенации.' . "\n";

echo <<<END
Здесь используется синтаксис "here document" для вывода
нескольких строк с подстановкой переменных $variable.
Заметьте, что закрывающий идентификатор должен
располагаться в отдельной строке. никаких пробелов!
END;

// Следующая строка неверна, так как echo не является функцией              //TODO
($some_var) ? echo 'true' : echo 'false';

// Но это можно записать по другому
($some_var) ? print 'true' : print 'false'; // print также является конструкцией языка,
                                            // но ведет себя как функция, поэтому она
                                            // может быть использована в этом контексте.
echo $some_var ? 'true': 'false'; // echo вынесен за пределы выражения
.....................................
print - Выводит строку                        int print ( string $arg )
Выводит arg.
print не является "настоящей" функцией (это конструкция языка), поэтому заключать аргументы в скобки необязательно.
Возвращает 1, всегда.//TODO

print("Привет мир!");

print "print() можно использовать и без скобок.";

print "Это займет
несколько строк. Переводы строки тоже
выводятся";

print "Это займет\nнесколько строк. Переводы строки тоже\nвыводятся";

print "Экранирование символов делается \"Так\".";

// с print можно использовать переменные ...
$foo = "foobar";
$bar = "barbaz";

print "foo - это $foo"; // foo - это foobar

// ... и массивы
$bar = array("value" => "foo");

----print "это {$bar['value']} !"; // это foo !

// При использовании одиночных кавычек выводится имя переменной, а не значение
print 'foo - это $foo'; // foo - это $foo

// Если вы не используете другие символы, можно вывести просто значения переменных
print $foo;          // foobar

print <<<END
Здесь используется синтаксис "here document" для вывода
нескольких строк с подстановкой переменных $variable.
Заметьте, что закрывающий идентификатор должен
располагаться в отдельной строке, никаких пробелов!
END;

....
printf() - Выводит отформатированную строку                          int printf ( string $format [, mixed $args [, mixed $... ]] )
Выводит строку, отформатированную в соответствии с аргументом format.
Возвращает длину выведенной строки               //TODO
Описание параметра format смотрите в описании функции sprintf().        https://secure.php.net/manual/ru/function.sprintf.php

$len = printf("wej kllk k\n"); // wej kllk k

printf("%d",$len);  // 11
....
vprintf — Выводит отформатированную строку
Эта функция подобна printf(), но она принимает не переменное число аргументов, а массив.Возвращает длину выведенной строки
vprintf("%04d-%02d-%02d", explode('-', '1988-8-1')); // 1988-08-01                         //TODO

....
flush() - Сброс системного буфера вывода
....
Heredoc синтаксис
....
trim — Удаляет пробелы (или другие символы) из начала и конца строки             string trim ( string $str [, string $character_mask = " \t\n\r\0\x0B" ] )
Эта функция возвращает строку str с удаленными из начала и конца строки пробелами. Если второй параметр не передан, trim() удаляет следующие символы:

" " (ASCII 32 (0x20)), обычный пробел.
"\t" (ASCII 9 (0x09)), символ табуляции.
"\n" (ASCII 10 (0x0A)), символ перевода строки.
"\r" (ASCII 13 (0x0D)), символ возврата каретки.
"\0" (ASCII 0 (0x00)), NUL-байт.
"\x0B" (ASCII 11 (0x0B)), вертикальная табуляция.  //??

$text   = "\t\tThese are a few words :) ...  ";
$binary = "\x09Example string\x0A";  //??
$hello  = "Hello World";
var_dump($text, $binary, $hello);

/*
string(32) "		These are a few words :) ...  "
string(16) "	Example string
"
string(11) "Hello World"
*/
print "\n";

$trimmed = trim($text);
var_dump($trimmed); // string(11) "Hello World"

$trimmed = trim($text, " \t.");
var_dump($trimmed);  // string(28) "These are a few words :) ..."                  string(24) "These are a few words :)"

$trimmed = trim($hello, "Hdle");
var_dump($trimmed); // string(5) "o Wor"

$trimmed = trim($hello, 'HdWr');
var_dump($trimmed);    // string(9) "ello Worl"

// удаляем управляющие ASCII-символы с начала и конца $binary
// (от 0 до 31 включительно)
$clean = trim($binary, "\x00..\x1F");
var_dump($clean);   // string(14) "Example string"

Обрезание значений массива с помощью trim()

function trim_value(&$value)
{
    $value = trim($value);
}

$fruit = array('apple','banana ', ' cranberry ');
var_dump($fruit);

array_walk($fruit, 'trim_value');
var_dump($fruit);
..................
array_walk — Применяет заданную пользователем функцию к каждому элементу массива        bool array_walk ( array &$array , callable $callback [, mixed $userdata = NULL ] )
Применяет пользовательскую функцию callback к каждому элементу массива array.
array_walk() не подвержена влиянию внутреннего указателя массива array. array_walk() обойдёт все элементы массива независимо от позиции указателя.
array // Входной массив.
callback // Обычно функция callback принимает два параметра. В качестве первого параметра идет значение элемента массива array, а ключ - в качестве второго.

Замечание:
Если требуется, чтобы функция callback изменила значения в массиве, определите первый параметр callback как ссылку. Тогда все изменения будут применены к элементам оригинального массива.
Замечание:
Множество встроенных функций (например, strtolower()) выводят предупреждение, если им передано больше параметров, чем они ожидают, или которые не могут непосредственно использоваться в callback.
Потенциально изменены могут быть только значения массива array; структура самого массива не может быть изменена, то есть нельзя добавить, удалить или поменять порядок элементов. Если callback-функция не соответствует этому требованию, поведение данной функции станет неопределённым и непредсказуемым.

userdata
Если указан необязательный параметр userdata, он будет передан в качестве третьего параметра в callback-функцию callback.

Возвращает TRUE в случае успешного завершения или FALSE в случае возникновения ошибки.

Ошибки 

Если функция callback требует больше параметров, чем передано на самом деле, каждый раз, когда array_walk() будет вызывать callback, будет генерироваться ошибка уровня E_WARNING.
ЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮ
class Category
{
	
	public static function getCategoriesList()
	{
	$db = Db::getConnection();
	//$categoryList = array();
	$categoryList = [];
	$result = $db->query('SELECT * FROM categories');

	$i = 0;
	while($row = $result->fetch()) {
		$categoryList[$i]['id'] = $row['id'];
		$categoryList[$i]['title'] = $row['title'];
		$categoryList[$i]['meta_d'] = $row['meta_d'];
		$categoryList[$i]['meta_k'] = $row['meta_k'];
		$categoryList[$i]['text'] = $row['text'];

		$i++;

	}
	return $categoryList;
	}
}


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 	Строки  // http://php.net/manual/ru/language.types.string.php#language.types.string.syntax.nowdoc

Строка - это набор символов, где символ - это то же самое, что и байт.
 Это значит, что PHP поддерживает ровно 256 различных символов, а также то, что в PHP нет встроенной поддержки Unicode.
Замечание: Строки (string) не могут быть размером более 2 Гб (2147483647 байт).//TODO

	Одинарные кавычки 
Простейший способ определить строку - это заключить ее в одинарные кавычки (символ ').                                   //'
Чтобы использовать одинарную кавычку внутри строки, проэкранируйте ее обратной косой чертой (\). Если необходимо написать саму обратную косую черту, продублируйте ее (\\). //TODO
Все остальные случаи применения обратной косой черты будут интерпретированы как обычные символы: это означает, что если вы попытаетесь использовать другие управляющие последовательности, такие как \r или \n, они будут выведены как есть вместо какого-либо особого поведения.
Замечание: В отличие от синтаксиса двойных кавычек и heredoc, переменные и управляющие последовательности для специальных символов, заключенных в одинарные кавычки, не обрабатываются.//TODO
// Выводит: Однажды Арнольд сказал: "I'll be back"
echo 'Однажды Арнольд сказал: "I\'ll be back"';
// Выводит: Переменные $expand также $either не разворачиваются
echo 'Переменные $expand также $either не разворачиваются';

echo 'Также вы можете вставлять в строки
символ новой строки вот так,
это нормально';
// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\\*.*?';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\*.*?';

// Выводит: Это не будет развернуто: \n новая строка
echo 'Это не будет развернуто: \n новая строка';

	Двойные кавычки 

Если строка заключена в двойные кавычки (""), PHP распознает большее количество управляющих последовательностей для специальных символов:

Управляющие последовательности
	Последовательность				Значение
	\n				новая строка (LF или 0x0A (10) в ASCII)
	\r				возврат каретки (CR или 0x0D (13) в ASCII)
	\t				горизонтальная табуляция (HT или 0x09 (9) в ASCII)
	\v				вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5)
	\e				escape-знак (ESC или 0x1B (27) в ASCII) (с версии PHP 5.4.4)
	\f				подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5)
	\\				обратная косая черта
	\$				знак доллара
	\"			       "двойная кавычка
	\[0-7]{1,3}			последовательность символов, соответствующая регулярному выражению символа в восьмеричной системе счисления
	\x[0-9A-Fa-f]{1,2}		последовательность символов, соответствующая регулярному выражению символа в шестнадцатеричной системе счисления

Как и в строке, заключенной в одинарные кавычки, экранирование любого символа выведет также и саму обратную косую черту. До версии PHP 5.1.1, обратная косая черта в \{$var} не печаталась.

	Heredoc 

Третий способ определения строк - это использование heredoc-синтаксиса: <<<. После этого оператора необходимо указать идентификатор, затем перевод строки. После этого идет сама строка, а потом этот же идентификатор, закрывающий вставку.
Строка должна начинаться с закрывающего идентификатора, т.е. он должен стоять в первом столбце строки. Кроме того, идентификатор должен соответствовать тем же правилам именования, что и все остальные метки в PHP: содержать только буквенно-цифровые символы и знак подчеркивания, и не должен начинаться с цифры (знак подчеркивания разрешается).

Внимание
Очень важно отметить, что строка с закрывающим идентификатором не должна содержать других символов, за исключением точки с запятой (;). Это означает, что идентификатор не должен вводиться с отступом и что не может быть никаких пробелов или знаков табуляции до или после точки с запятой. Важно также понимать, что первым символом перед закрывающим идентификатором должен быть символ новой строки, определенный в вашей операционной системе. Например, в UNIX системах, включая Mac OS X, это \n. После закрывающего идентификатора также сразу должна начинаться новая строка.
Если это правило нарушено и закрывающий идентификатор не является "чистым", считается, что закрывающий идентификатор отсутствует и PHP продолжит его поиск дальше. Если в этом случае верный закрывающий идентификатор так и не будет найден, то это вызовет ошибку парсинга с номером строки в конце скрипта.
Heredoc не может быть использован для инициализации полей класса. Начиная с версии PHP 5.3, это ограничение распространяется только на heredoc, содержащие внутри себя переменные.
Пример #1 Неверный пример

/*
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
?>
*/
Heredoc-текст ведет себя так же, как и строка в двойных кавычках, при этом их не имея. Это означает, что вам нет необходимости экранировать кавычки в heredoc, но вы по-прежнему можете использовать вышеперечисленные управляющие последовательности. Переменные обрабатываются, но с применением сложных переменных внутри heredoc нужно быть также внимательным, как и при работе со строками.
<?php
$str = <<<EOD
Пример строки,
охватывающей несколько строчек,
с использованием heredoc-синтаксиса.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<EOT
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOT;

Результат выполнения данного примера:

Меня зовут "МоеИмя". Я печатаю Foo.
Теперь, я вывожу Bar2.
Это должно вывести заглавную букву 'A': A

Замечание:
В отличие от heredoc, nowdoc может быть использован в любом контексте со статическими данными. Типичный пример инициализации полей класса или констант:
Пример #7 Пример использования статичных данных

<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}


Использование двойных кавычек в heredoc


echo <<<"FOOBAR"
Привет, мир!
FOOBAR;



Nowdoc 

Nowdoc - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. 
Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок. Эта конструкция идеальна для внедрения PHP-кода или других больших блоков текста без необходимости его экранирования. В этом он немного похож на SGML-конструкцию <![CDATA[ ]]> тем, что объявляет блок текста, не предназначенный для обработки.

Nowdoc указывается той же последовательностью <<<, что используется в heredoc, но последующий за ней идентификатор заключается в одинарные кавычки, например, <<<'EOT'. Все условия, действующие для heredoc идентификаторов также действительны и для nowdoc, особенно те, что относятся к закрывающему идентификатору.

Пример #6 Пример использования nowdoc

$str = <<<'EOD'
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc.
EOD;
....................................Обработка переменных....................

Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри нее обрабатываются.
Существует два типа синтаксиса: простой и сложный. Простой синтаксис более легок и удобен. Он дает возможность обработки переменной, значения массива (array) или свойства объекта (object) с минимумом усилий.

Сложный синтаксис может быть определен по фигурным скобкам, окружающим выражение.

Простой синтаксис

Если интерпретатор встречает знак доллара ($), он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. Если вы хотите точно определить конец имени, заключайте имя переменной в фигурные скобки.
$juice = "apple";
echo "He drank some $juice juice.".PHP_EOL;
Аналогично могут быть обработаны элемент массива (array) или свойство объекта (object). В индексах массива закрывающая квадратная скобка (]) обозначает конец определения индекса. Для свойств объекта применяются те же правила, что и для простых переменных.
<?php
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";
    
    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // Won't work                   's' at the end

Сложный (фигурный) синтаксис

Он называется сложным не потому, что труден в понимании, а потому что позволяет использовать сложные выражения.
Любая скалярная переменная, элемент массива или свойство объекта, отображаемое в строку, может быть представлена в строке этим синтаксисом. 
Просто запишите выражение так же, как и вне строки, а затем заключите его в { и }.
 Поскольку { не может быть экранирован, этот синтаксис будет распознаваться только когда $ следует непосредственно за {.
 Используйте {\$, чтобы напечатать {$. Несколько поясняющих примеров:
<?php
// Показываем все ошибки
error_reporting(E_ALL);

	$great = 'здорово';

	// Не работает, выводит: Это { здорово}
	echo "Это { $great}";

	// Работает, выводит: Это здорово
	echo "Это {$great}";
	echo "Это ${great}";

	// Работает
	echo "Этот квадрат шириной {$square->width}00 сантиметров.";

	// Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок //TODO
	echo "Это работает: {$arr['key']}";

	// Работает
	echo "Это работает: {$arr[4][3]}";

	// Это неверно по той же причине, что и $foo[bar] вне
	// строки. Другими словами, это по-прежнему будет работать,
	// но поскольку PHP сначала ищет константу foo, это вызовет
	// ошибку уровня E_NOTICE (неопределенная константа).
	echo "Это неправильно: {$arr[foo][3]}";

	// Работает. При использовании многомерных массивов внутри  //TODO
	// строк всегда используйте фигурные скобки
	echo "Это работает: {$arr['foo'][3]}";

	// Работает.
	echo "Это работает: " . $arr['foo'][3];

	echo "Это тоже работает: {$obj->values[3]->name}";

	echo "Это значение переменной по имени $name: {${$name}}";    //TODO

	echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";//TODO

	echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}";

	// Не работает, выводит: Это то, что возвращает getName(): {getName()}
	echo "Это то, что возвращает getName(): {getName()}";
	?>
	С помощью этого синтаксиса также возможен доступ к свойствам объекта внутри строк.

	<?php
	class foo {
	    var $bar = 'I am bar.';
	}

	$foo = new foo();
	$bar = 'bar';
	$baz = array('foo', 'bar', 'baz', 'quux');
	echo "{$foo->$bar}\n";
	echo "{$foo->$baz[1]}\n";

	Результат выполнения данного примера:

	I am bar.
	I am bar.

Замечание:
Функции, вызовы методов, статические переменные классов, а также константы классов работает внутри {$}, начиная с версии PHP 5. Однако, указываемое значение будет обработано как имя переменной в том же контексте, что и строка, в которой она определяется. Использование одинарных фигурных скобок ({}) не будет работать для доступа к значениям функций, методов, констант классов или статических переменных класса.
<?php
	// Показываем все ошибки
	error_reporting(E_ALL);

	class beers {
	    const softdrink = 'rootbeer';
	    public static $ale = 'ipa';
	}

	$rootbeer = 'A & W';
	$ipa = 'Alexander Keith\'s';

	// Это работает, выводит: Я бы хотел A & W
	echo "Я бы хотел {${beers::softdrink}}\n";

	// Это тоже работает, выводит: Я бы хотел Alexander Keith's
	echo "Я бы хотел {${beers::$ale}}\n";

Доступ к символу в строке и его изменение //TODO

Символы в строках можно использовать и модифицировать, определив их смещение относительно начала строки, начиная с нуля, в квадратных скобках после строки, например, $str[42]. Думайте о строке для этой цели, как о массиве символов. Если нужно получить или заменить более 1 символа, можно использовать функции substr() и substr_replace().

Замечание: К символу в строке также можно обращаться с помощью фигурных скобок, например, $str{42}.
Внимание
Попытка записи в смещение за границами строки дополнит строку пробелами до этого смещения. Нецелые типы будет преобразованы в целые. Неверный тип смещения вызовет ошибку уровня E_NOTICE. Запись по отрицательному смещению вызовет ошибку уровня E_NOTICE, а при чтении вернет пустую строку. Используется только первый символ присваемой строки.
Присвоение пустой строки присваивает нулевой байт (NULL).//TODO
Внимание
Строки в PHP внутренне представляют из себя массивы байт.//TODO
 Как результат, доступ или изменение строки по смещению небезопасно с точки зрения многобайтной кодировки, и должно выполняться только со строками в однобайтных кодировках, таких как, например, ISO-8859-1.
<?php
	// Получение первого символа строки
	$str = 'This is a test.';
	$first = $str[0];

	// Получение третьего символа строки
	$third = $str[2];

	// Получение последнего символа строки
	$str = 'This is still a test.';
	$last = $str[strlen($str)-1]; 

	// Изменение последнего символа строки
	$str = 'Look at the sea';
	$str[strlen($str)-1] = 'e';

Начиная с PHP 5.4 смещение в строке должно задаваться либо целым числом либо строкой, содержащей цифры, иначе будет выдаваться предупреждение. //TODO
Ранее смещение, заданное строкой вида "foo", без предупреждений преобразовывалось в 0.
<?php
	$str = 'abc';

	var_dump($str['1']);                     // string(1) "b"
	var_dump(isset($str['1']));              // bool(true)

	var_dump($str['1.0']);                   // string(1) "b"
	var_dump(isset($str['1.0']));            // bool(true)

	var_dump($str['x']);                     // string(1) "a"
	var_dump(isset($str['x']));              // bool(true)

	var_dump($str['1x']);                    // string(1) "b"
	var_dump(isset($str['1x']));             // bool(true)

Замечание:
Попытка доступа к переменным других типов (исключая массивы или объекты, реализующие определенные интерфейсы) с помощью [] или {} молча вернет NULL.
Замечание:
В PHP 5.5 была добавлена поддержка доступа к символам в строковых литералах с помощью синтаксиса [] или {}.



ЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮ
http://php.net/manual/ru/book.ctype.php
функции символьных типов         //  http://php.net/manual/ru/ref.ctype.php 


Ctype 

ctype_alnum — Проверяет на наличие буквенно-цифровых символов
ctype_alpha — Проверяет на наличие буквенных символов
ctype_cntrl — Проверяет на наличие управляющих символов     [\0, \a, \b, \t, \n, \v, \f, \r]
ctype_digit — Проверяет на наличие цифровых символов в строке
ctype_graph — Проверяет наличие всех печатных символов, кроме пробела
ctype_lower — Проверяет наличие символов в нижнем регистре
ctype_print — Проверяет на наличие печатных символов
ctype_punct — Проверяет на наличие печатных символов, которые в то же время не являются пробельными или буквенно-цифровыми символами
ctype_space — Проверяет наличие пробельных символов
ctype_upper — Проверяет на наличие символов в верхнем регистре
ctype_xdigit — Проверяет наличие шестнадцатеричных цифр

ЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮю


Функции для работы с регулярными выражениями (Perl-совместимые)         // http://php.net/manual/ru/ref.pcre.php

preg_filter     — Производит поиск и замену по регулярному выражению
preg_grep       — Возвращает массив вхождений, которые соответствуют шаблону
preg_last_error — Возвращает код ошибки выполнения последнего регулярного выражения PCRE
preg_match_all  — Выполняет глобальный поиск шаблона в строке
preg_match      — Выполняет проверку на соответствие регулярному выражению  //
preg_quote      — Экранирует символы в регулярных выражениях
preg_replace_callback_array — Perform a regular expression search and replace using callbacks
preg_replace_callback — Выполняет поиск по регулярному выражению и замену с использованием callback-функции
preg_replace — Выполняет поиск и замену по регулярному выражению //
preg_split — Разбивает строку по регулярному выражению

http://php.net/manual/ru/book.pcre.php      // TODO

/////////////////////////////////////////////////////////////////////////////////////
Функции регулярных выражений POSIX                //  http://php.net/manual/ru/ref.regex.php

/////////////////////////////////////////////////////////

URL            // http://php.net/manual/ru/ref.url.php

base64_decode — Декодирует данные, закодированные алгоритмом MIME base64
base64_encode — Кодирует данные алгоритмом MIME base64
get_headers — Возвращает все заголовки из ответа сервера на HTTP-запрос
get_meta_tags — Извлекает из файла содержимое всех мета-тегов и возвращает как ассоциативный массив
http_build_query — Генерирует URL-кодированную строку запроса
parse_url — Разбирает URL и возвращает его компоненты
rawurldecode — Декодирование URL-кодированной строки
rawurlencode — URL-кодирование строки согласно RFC 3986
urldecode — Декодирование URL-кодированной строки
urlencode — URL-кодирование строки
//////////////////////////////////////////////////////////////

функции шифрования/дешифрования строк 
mcrypt    // http://php.net/manual/ru/ref.mcrypt.php
mhash      //  http://php.net/manual/ru/ref.mhash.php

///////////////////////////////////////////////////////////////////////////////////////////////////
https://secure.php.net/manual/ru/ref.strings.php                   Обработка строк

chr — Возвращает символ по его коду
................
count_chars — Возвращает информацию о символах, входящих в строку
mixed count_chars ( string $string [, int $mode = 0 ] )
Подсчитывает количество вхождений каждого из символов с ASII-кодами в диапазоне (0..255) в строке string и возвращает эту информацию в различных форматах.
string   Исследуемая строка.
mode     Смотрите возвращаемые значения.
В зависимости от параметра mode count_chars() возвращает одно из следующих значений:

0 - массив, индексами которого являются ASCII-коды, а значениями - число вхождений соответствующего символа.
1 - то же, что и для 0, но информация о символах с нулевым числом вхождений не включается в массив.
2 - то же, что и для 0, но в массив включается информация только о символах с нулевым числом вхождений.
3 - строка, содержащая все уникальные символы в исследуемой строке.
4 - строка, состоящая из символов, которые не входят в исходную строку.

$data = "Two Ts and one F.";

foreach (count_chars($data, 1) as $i => $val) {
   echo "\"" , chr($i) , "\" встречается в строке $val раз(а).\n";
}

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
substr — Возвращает подстроку
strstr — Находит первое вхождение подстроки

trim — Удаляет пробелы (или другие символы) из начала и конца строки
ltrim — Удаляет пробелы (или другие символы) из начала строки
rtrim — Удаляет пробелы (или другие символы) из конца строки

ucfirst — Преобразует первый символ строки в верхний регистр
lcfirst — Преобразует первый символ строки в нижний регистр

ucwords — Преобразует в верхний регистр первый символ каждого слова в строке

strtok — Разбивает строку на токены
strtolower — Преобразует строку в нижний регистр
strtoupper — Преобразует строку в верхний регистр
strrev — Переворачивает строку задом наперед
strlen — Возвращает длину строки
strcmp — Бинарно-безопасное сравнение строк
join — Псевдоним implode

chr — Возвращает символ по его коду
str_split — Преобразует строку в массив
substr_count — Возвращает число вхождений подстроки
.....................................................
htmlspecialchars — Преобразует специальные символы в HTML-сущности
$new = htmlspecialchars("<a href='test'>Test</a>", ENT_QUOTES);
echo $new; // &lt;a href=&#039;test&#039;&gt;Test&lt;/a&gt;
....
htmlentities – преобразует символы в соответствующие HTML сущности. ////////////////TODO
string htmlentities ( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ini_get("default_charset") [, bool $double_encode = true ]]] )
Эта функция идентична htmlspecialchars() за исключением того, что htmlentities() преобразует все символы в соответствющие HTML-сущности (для тех символов, для которых HTML сущности существуют).

Если же вы хотите раскодировать строку (наоборот), используйте html_entity_decode().
$orig = "I'll \"walk\" the <b>dog</b> now";

$a = htmlentities($orig);

$b = html_entity_decode($a);

echo $a; // I'll &quot;walk&quot; the &lt;b&gt;dog&lt;/b&gt; now

echo $b; // I'll "walk" the <b>dog</b> now

html_entity_decode() является противоположностью функции htmlentities(). Она преобразует все HTML-сущности в строке string в соответствующие символы.
....
addcslashes — Экранирует cтроку слешами в стиле языка C             string addcslashes ( string $str , string $charlist )
Возвращает строку, экранированную обратными слешами перед символами, указанными в параметре charlist.
str // Экранируемая строка.
charlist //Список экранируемых символов. Если charlist содержит символы \n, \r и т.п., они будут преобразованы в стиле C, тогда как другие нецифробуквенные символы с ASCII-кодами ниже 32 и выше 126 будут преобразованы в восьмеричное представление.

Следует быть внимательным при указании диапазона символов в аргументе charlist. Проверяйте, какие символы входят в этот диапазон.
echo addcslashes('foo[ ]', 'A..z');
// выводит:  \f\o\o\[ \]
// Будут экранированы заглавные и строчные английские буквы
// ... а также [\]^_`
Также, если ASCII-код первого символа диапазона больше, чем последнего, диапазон не будет создан. Вместо этого будут экранироваться только первый символ, последний символ и точка. Для определения ASCII-кода символов используйте функцию ord().

echo addcslashes("zoo['.']", 'z..A');
// выводит:  \zoo['\.']

Будьте внимательны при экранировании символов 0, a, b, f, n, r, t и v. Они будут преобразованы в \0, \a, \b, \f, \n, \r, \t и \v, которые являются предопределенными escape-последовательностями в языке Си. Многие из этих последовательностей также определены в других си-подобных языках, включая PHP. Это означает, что вы можете не получить ожидаемого результата, если будете использовать вывод функции addcslashes() для создания кода в этих языках с использованием этих символов в charlist.

Возвращает экранированную строку.

....
stripcslashes — Удаляет экранирование символов, произведенное функцией addcslashes

....
str_ireplace — Регистронезависимый вариант функции str_replace()                 ////////////////TODO

mixed str_ireplace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )

Эта функция возвращает строку или массив, в котором все вхождения search в subject заменены на replace (без учета регистра символов). Если не нужны сложные правила поиска/замены, использование этой функции предпочтительнее preg_replace() с модификатором i.

The str_ireplace() function replaces some characters with some other characters in a string.

str_ireplace(find,replace,string,count)

find	Required. Specifies the value to find
replace	Required. Specifies the value to replace the value in find
string	Required. Specifies the string to be searched
count	Optional. A variable that counts the number of replacements

This function works by the following rules:

If the string to be searched is an array, it returns an array
If the string to be searched is an array, find and replace is performed with every array element
If both find and replace are arrays, and replace has fewer elements than find, an empty string will be used as replace
If find is an array and replace is a string, the replace string will be used for every find value
Note: This function is case-insensitive. Use the str_replace() function to perform a case-sensitive search.

Note: This function is binary-safe.
ex0:
$bodytag = str_ireplace("%body%", "black", "<body text=%BODY%>");
ex1:
echo str_ireplace("WORLD","Peter","Hello world!");
ex2:
$arr = array("blue","red","green","yellow");
print_r(str_ireplace("RED","pink",$arr,$i)); // This function is case-insensitive
echo "Replacements: $i";
ex3:
$find = array("HELLO","WORLD");
$replace = array("B");
$arr = array("Hello","world","!");
print_r(str_ireplace($find,$replace,$arr));

.................................
				 http://php.net/manual/ru/language.types.callable.php

		call_user_func_array — Вызывает пользовательскую функцию с массивом параметров 

mixed call_user_func_array ( callable $callback , array $param_arr )
callback - Вызываемая функция типа callable.
param_arr - Передаваемые в функцию параметры в виде индексированного массива.
...................................


Функции для работы с Многобайтными строками           https://secure.php.net/manual/ru/ref.mbstring.php

mb_strlen($search,'UTF8')

mb_strlen — Получает длину строки             mixed mb_strlen ( string $str [, string $encoding = mb_internal_encoding() ] )
Получает длину строки string.
str  // Строка string, для которой измеряется длина.
encoding //Параметр encoding представляет собой символьную кодировку. Если он опущен, вместо него будет использовано значение внутренней кодировки.

Возвращает количество символов в строке (string) str, имеющих кодировку символов encoding. Многобайтный символ вычисляется как 1.

Возвращает FALSE, если передан недопустимый параметр encoding.
Внимание
Эта функция может возвращать как boolean FALSE, так и не-boolean значение, которое приводится к FALSE. За более подробной информацией обратитесь к разделу Булев тип. Используйте оператор === для проверки значения, возвращаемого этой функцией.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://secure.php.net/manual/ru/ref.filesystem.php    Файловая система 
http://php.net/manual/ru/ref.network.php                  Сетевые Функции          
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
................Преобразование в строку ..............//TODO
Значение может быть преобразовано в строку, с помощью приведения (string), либо функции strval()

Значение boolean TRUE преобразуется в строку "1", а значение FALSE преобразуется в "" (пустую строку). Это позволяет преобразовывать значения в обе стороны - из булева типа в строковый и наоборот.

Целое (integer) или число с плавающей точкой (float) преобразуется в строку, представленную числом, состоящим из его цифр (включая показатель степени для чисел с плавающей точкой).

Массивы всегда преобразуются в строку "Array", так что вы не можете отобразить содержимое массива (array), используя echo или print, чтобы узнать, что он содержит. Чтобы просмотреть отдельный элемент, используйте что-нибудь вроде echo $arr['foo'].

Объекты в PHP 4 всегда преобразовывались в строку "Object". 
Если вы хотите получить имя класса требуемого объекта, используйте    get_class(). 
Начиная с PHP 5, также стал доступен метод    __toString.

Resource всегда всегда преобразуется в string вида "Resource id #1", где 1 является номером ресурса привязанного к resource во время выполнения
Если вы хотите получить тип ресурса, используйте     get_resource_type().

NULL всегда преобразуется в пустую строку.

Большинство значений в PHP может быть преобразовано в строку для постоянного хранения. Этот метод называется сериализацией и может быть выполнен при помощи функции serialize().

...................Преобразование строк в числа ...............//TODO

Если строка не содержит какой-либо из символов '.', 'e', или 'E', и значение числа помещается в пределы целых чисел (определенных PHP_INT_MAX), строка будет распознана как целое число (integer). Во всех остальных случаях она считается числом с плавающей точкой (float).

Значение определяется по начальной части строки. Если строка начинается с верного числового значения, будет использовано это значение. Иначе значением будет 0 (ноль). Верное числовое значение - это одна или более цифр (могущих содержать десятичную точку), по желанию предваренных знаком, с последующим необязательным показателем степени. Показатель степени - это 'e' или 'E' с последующими одной или более цифрами.

Если вы хотите изменить тип переменной, смотрите settype().

Допускаются следующие приведения типов:

	(int), (integer) - приведение к integer
	(bool), (boolean) - приведение к boolean
	(float), (double), (real) - приведение к float
	(string) - приведение к string
	(array) - приведение к array
	(object) - приведение к object
	(unset) - приведение к NULL (PHP 5)

Приведение типа (binary) и поддержка префикса b были добавлены в PHP 5.2.1
$binary = (binary) $string;
$binary = b"binary string";

...............При преобразовании в boolean, следующие значения рассматриваются как FALSE:

само значение boolean FALSE
integer 0 (ноль)
float 0.0 (ноль)
пустая строка "", и строка "0"
массив без элементов
объект без полей (только для PHP 4)
особый тип NULL (включая неустановленные переменные)
Объекты SimpleXML, созданные из пустых тегов

Все остальные значения рассматриваются как TRUE (включая любой resource).
Внимание
-1 рассматривается как TRUE, как и любое другое ненулевое (отрицательное или положительное) число!

.............  Примером автоматического преобразования типа является оператор сложения  '+'   ...............

	$foo = "0";                       // $foo это строка (ASCII 48)
	$foo += 2;                        // $foo теперь целое число (2)
	$foo = $foo + 1.3;                // $foo теперь число с плавающей точкой (3.3)
	$foo = 5 + "10 Little Piggies";   // $foo это целое число (15)
	$foo = 5 + "10 Small Pigs";       // $foo это целое число (15)
	$foo = 1 + "10.5";                // $foo это float (11.5)
	$foo = 1 + "-1.3e3";              // $foo это float (-1299)
	$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
	$foo = 1 + "bob3";                // $foo это integer (1)
	$foo = 1 + "10 Small Pigs";       // $foo это integer (11)
	$foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
	$foo = "10.0 pigs " + 1;          // $foo это float (11)
	$foo = "10.0 pigs " + 1.0;        // $foo это float (11)
......................

 Для преобразования символов в их ASCII коды и обратно используйте функции ord() и chr().
юююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююююю
Подробности реализации строкового типа

Строковый тип (string) в PHP реализован в виде массива байт и целого числа, содержащего длину буфера. Он не содержит никакой информации о способе преобразования этих байт в символы, предоставляя эту задачу программисту. Нет никаких ограничений на содержимое строки, например, байт со значением 0 ("NUL"-байт) может располагаться где угодно (однако, стоит учитывать, что некоторые функции, как сказано в этом руководстве, не являются "бинарно-безопасными", т.е. они могут передавать строки библиотекам, которые игнорируют данные после NUL-байта).//TODO

«NUL» — название символа из кодировки ASCII, имеющего код 0 и используемого для обозначения конца строк.
NULL (Си) — нулевой указатель в языках программирования Си и C++.
NULL (SQL) — специальное значение (псевдозначение), означающее, что значение поля не определено.
.........................
Проблемы безопасности, связанные с нулевым байтом 
http://php.net/manual/ru/security.filesystem.nullbytes.php

Так как для работы с файловой системой PHP использует нижележащие C-функции, то в этом случае возможна крайне неожиданная обработка нулевого байта. Так как нулевой байт означает конец строки в C, то строки, содержащие такой байт, не будут трактоваться полностью, а только до той позиции, в которой находится этот байт.
.........................
/*
Это пришло из C/C++. Некоторые функции в серверных языках обрабатывают данные как функции языка C, т.е. побайтно. Разнообразные подходы к манипулированию данной особенностью и породили класс атак, называемых "Инъекция нулевого байта". В C/C++ нулевой байт означает остановку обработки строки. Байты следующие за ним будут игнорироваться. Если же нулевой байт не обнаружен, длинна строки становится неизвестной до обнаружения следующего разделителя. Из-за таких различий в интерпретации нулевой байт легко позволяет манипулировать поведением приложений. 

Диапазон символов для URL-адреса ограничен US-ASCII от 0x20 до 0x7E (в HEX) или от 32 до 126 (в десятичной системе). Однако в данном диапазоне используются несколько недопустимых символов, которые являются зарезервированными для HTTP-протокола. Именно по этому схема кодирования URL была расширена дополнительными символами ASCII. Нулевой байт кодируется как %00. Это и позволяет злоумышленнику манипулировать скриптом для чтения или записи на основе пользовательских привилегий.
*/
Данная природа строкового типа объясняет почему в PHP нет отдельного типа “byte” - строки играют эту роль. Функции, возвращающие нетекстовые данные - например, произвольный поток данных, считываемый из сетевого сокета - тем не менее возвращают строки.

Принимая во внимание тот факт, что PHP не диктует определенную кодировку для строк, можно задать вопрос, как в таком случае кодируются строковые литералы. Например, строка "á" эквивалентна "\xE1" (ISO-8859-1), "\xC3\xA1" (UTF-8, форма нормализации C), "\x61\xCC\x81" (UTF-8, форма нормализации D) или какому-либо другому возможному представлению?
 
Ответом является следующее: строка будет закодирована тем образом, которым она записана в файле скрипта.

 Таким образом, если скрипт записан в кодировке ISO-8859-1, то и строка будет закодирована в ISO-8859-1 и т.д. Однако, это правило не применяется при включенном режиме Zend Multibyte: в этом случае скрипт может быть записан в любой кодировке (которая указывается ясно или определяется автоматически), а затем конвертируются в определенную внутреннюю кодировку, которая и будет впоследствии использована для строковых литералов. 
Учтите, что на кодировку скрипта (или на внутреннюю кодировку, если включен режим Zend Multibyte) накладываются некоторые ограничения: практически всегда данная кодировка должна быть надмножеством ASCII, например, UTF-8 или ISO-8859-1. Учтите также, что кодировки, зависящие от состояния, где одни и те же значения байт могут быть использованы в начальном и не начальном состоянии сдвига (initial and non-inital shift state), могут вызвать проблемы.

Разумеется, чтобы приносить пользу, строковые функции должны сделать некоторые предположения о кодировке строки. К несчастью, среди PHP-функций довольно большое разнообразие подходов к этому вопросу:

Некоторые функции предполагают, что строка закодирована в какой-либо однобайтовой кодировке, однако, для корректной работы им не требуется интерпретировать байты как определенные символы. Под эту категорию попадают, например, substr(), strpos(), strlen() и strcmp(). Другой способ мышления об этих функциях представляет собой оперирование буферами памяти, т.е. они работают непосредственно с байтами и их смещениями. offsets.

Другие функции ожидают передачу кодировку в виде параметра, возможно, предполагая некоторую кодировку по умолчанию, если параметр с кодировкой не был указан. Такой функцией является htmlentities() и большинство функций из расширения mbstring.

Другие функции используют текущие установки локали (см. setlocale()), но оперируют побайтово). В эту категорию попадают strcasecmp(), strtoupper() и ucfirst(). Это означает, что они могут быть использованы только с однобайтовыми кодировками, в том случае, когда кодировка совпадает с локалью. Например, strtoupper("á") может вернуть "Á", если локаль установлена корректно и буква á закодирована в виде одного байта. Если она закодирована в UTF-8, будет возвращен некорректный результат, и, в зависимости от текущей локали, результирующая строка может быть (или не быть) испорчена.

Наконец, есть функции, подразумевающие, что строка использует определенную кодировку, обычно UTF-8. Сюда попадают большинство функций из расширений intl и PCRE (в последнем случае, только при указании модификатора u). Хотя это и сделано специально, функция utf8_decode() подразумевает кодировку UTF-8, а utf8_encode() - ISO-8859-1.

В конечном счете, написание корректных программ, работающих с Unicode, означает осторожное избегание функций, которые не работают с Unicode и, скорее всего, испортят данные, и использование вместо них корректных функций, обычно из расширений intl и mbstring. Однако, использование функций, способных работать с Unicode, является самым началом. Вне зависимости от тех функций, которые предоставляет язык, необходимо знать спецификацию самого Unicode. Например, если программа предполагает существование в языке только строчных и заглавных букв, то она делает большую ошибку.

///////////////////////////////////////
Многобайтные строки   // http://php.net/manual/ru/book.mbstring.php#book.mbstring
Хотя и существует множество языков, в которых все необходимые символы можно закодировать одним восьмибитным значением, существуют также и языки, требующие столько символов, что они не умещаются в один байт (Байт состоит из восьми бит. Каждый бит может содержать одно из двух различных значений, единицу или ноль. Поэтому, один байт может задавать только 256 уникальных значений (два в восьмой степени)). Схемы кодирования, использующие многобайтные строки, были разработаны для того, чтобы можно было пользоваться более, чем 256 символами, при этом продолжая работать со строками, как будто они закодированы в обычной побайтовой системе.

Когда вы работаете с многобайтными строками (удаляете пробельные символы с помощью функции trim, разбиваете строку на массив по регулярному выражению с помощью функции split, и т.д.), необходимо использовать специальные функции, так как в таких кодировках два или более последовательных байта могут задавать один символ. Иначе, если применить функцию, не умеющую работать с многобайтными строками, она, вероятно, не сможет определить начало и конец многобайтных символов, и в итоге вы получите строку-мусор, которая скорее всего потеряет исходное значение.

mbstring предоставляет функции для работы с многобайтными строками, которые облегчают работу c многобайтными кодировками в PHP. Кроме того, mbstring занимается конвертированием строк из одной кодировки в другую. mbstring предназначен для работы с Unicode-кодировками, такими, как UTF-8 и UCS-2, а также с многими однобайтными кодировками (для удобства), перечисленными ниже.
....................................
/////////////////////////////////////////
/* Unsorted string needs to be sorted. */
 
$str = 'qwertyuioplkjhgfdsazxcvbnm';
 
/* Using str_split convert them into array. */
 
$sort = str_split($str);
 
/* Sort the array using sort() method. */
 
sort($sort);
 //..................
 $strr = (string)$sort;
 echo $strr; // Array
echo "\n";
echo $strr[0]; // A
echo "\n";
//..................
/* Implode the sorted array. */
 
$sort = implode($sort);
 
/* Output will be sorted string.
   abcdefghijklmnopqrstuvwxyz */
 echo $sort;

////////////////////////////////////////////////////
Вы можете определить константу с помощью функции define() или с помощью ключевого слова const вне объявления класса начиная с версии PHP 5.3.0. После того, как константа определена, ее значение не может быть изменено или аннулировано.

До PHP 5.6 константы могут содержать только скалярные данные (boolean, integer, float и string типов). С PHP 5.6 возможно также определять константы как скалярные выражения, и также можно определять константы с типом array. Можно определять константы с типом resource, но не рекомендуется, так как может привести к неожиданным результатам.

Получить значение константы можно, указав ее имя. В отличие от переменных, вам не нужно предварять имя константы символом $. Также вы можете использовать функцию constant() для получения значения константы, если вы формируете имя константы динамически. Используйте функцию get_defined_constants() для получения списка всех объявленных констант.

Замечание: Константы и (глобальные) переменные находятся в разных пространствах имен. Это означает, что, например, TRUE и $TRUE являются совершенно разными вещами.

define("CONSTANT", "Здравствуй, мир.");
echo CONSTANT; // выводит "Здравствуй, мир."

// Работает, начиная с версии PHP 5.3.0
const CONSTANT = 'Здравствуй, мир.';

echo CONSTANT;

// Работает, начиная с версии PHP 5.6.0
const ANOTHER_CONST = CONSTANT.'; Прощай, мир.';

echo ANOTHER_CONST;
.......
const W = [1,2,55,'eesdjf'];
print_r(W);

/*
sort(W); // Fatal error: Only variables can be passed by reference in /home/valentin/t.php on line 9

print_r(W);
*/
.......
Array constants can now be defined using the define() function. In PHP 5.6, they could only be defined using const keyword.

Example:

   //define a array using define function
   define('animals', [
      'dog',
      'cat',
      'bird'
   ]);
   print(animals[1]);   // cat

Example:

define('AREA', ['triangle','circle','rectangle']);

echo  AREA [0]; // outputs  "triangle"
..............................
Некоторые "волшебные" константы PHP
           Имя	                              Описание

	__LINE__	 Текущий номер строки в файле.
	__FILE__	 Полный путь и имя текущего файла с развернутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.
	__DIR__	         Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). 
		         Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.
	__FUNCTION__	 Имя функции.
	__CLASS__	 Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, Foo\Bar). Обратите внимание, что начиная с PHP5.4
                          __CLASS__  также работает в трейтах. При использовании в методах трейтов __CLASS__ является именем класса, в котором эти методы используется.
	__TRAIT__	 Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, Foo\Bar).
	__METHOD__	 Имя метода класса.
	__NAMESPACE__	 Имя текущего пространства имен.

Смотрите также get_class(), get_object_vars(), file_exists() и function_exists().
...........................................................................................................

Операторы сравнения 

	$a == $b	Равно	                            TRUE если $a равно $b после преобразования типов.
	$a === $b	Тождественно равно	            TRUE если $a равно $b и имеет тот же тип.
	$a != $b	Не равно	                    TRUE если $a не равно $b после преобразования типов.
	$a <> $b	Не равно	                    TRUE если $a не равно $b после преобразования типов.
	$a !== $b	Тождественно не равно	            TRUE если $a не равно $b или они разных типов.
	$a < $b	        Меньше	                            TRUE если $a строго меньше $b.
	$a > $b	        Больше	                            TRUE если $a строго больше $b.
	$a <= $b	Меньше или равно	            TRUE если $a меньше или равно $b.
	$a >= $b	Больше или равно	            TRUE если $a больше или равно $b.

В случае, если вы сравниваете число со строкой или две строки, содержащие числа, каждая строка будет преобразована в число, и сравниваться они будут как числа. Эти правила также распространяются на оператор switch. 
Преобразование типов не происходит при использовании === или !== так как в этом случае кроме самих значений сравниваются еще и типы. //TODO

//////////////////////////////////////////////////

In PHP 7, a new feature, spaceship operator has been introduced. It is used to compare two expressions. It returns -1, 0 or 1 when first expression is respectively less than, equal to, or greater than second expression.

//integer comparison                             // result
   print( 1 <=> 1);print("<br/>");               //  0                                   
   print( 1 <=> 2);print("<br/>");               // -1
   print( 2 <=> 1);print("<br/>");               //  1
   print("<br/>");
   //float comparison
   print( 1.5 <=> 1.5);print("<br/>");           //  0  
   print( 1.5 <=> 2.5);print("<br/>");           // -1
   print( 2.5 <=> 1.5);print("<br/>");           //  1
   print("<br/>");
   //string comparison
   print( "a" <=> "a");print("<br/>");           //  0  
   print( "a" <=> "b");print("<br/>");           // -1
   print( "b" <=> "a");print("<br/>");           //  1

////////////////////////////////////////////////////

...................Сравнение объектов 

При использовании оператора сравнения (==), свойства объектов просто сравниваются друг с другом, а именно: два объекта равны, если они содержат одинаковые свойства и одинаковые значения, и являются экземплярами одного и того же класса.

При использовании оператора идентичности (===), переменные объектов считаются идентичными тогда и только тогда, когда они ссылаются на один и тот же экземпляр одного и того же класса.


Сравнение различных типов

Тип операнда 1	                 Тип операнда 2	                                        Результат

null или string	                   string	                                       NULL преобразуется в "", числовое или лексическое сравнение

bool или null	                   что угодно	                                       Оба операнда преобразуются в bool, FALSE < TRUE

object	                             object	                                       Встроенные классы могут определять свои собственные правила сравнения, объекты
                                                                                       разных классов не сравниваются, объекты одного класса - сравниваются свойства тем же
                                                                                       способом, что и в массивах (PHP 4), в PHP 5 есть свое собственное объяснение(см.выше)

string, resource или number	string, resource или number	                        Строки и ресурсы переводятся в числа, обычная математика

array	                           array	                                       Массивы с меньшим числом элементов считаются меньше, если ключ из первого операнда
                                                                                       не найден во втором операнде - массивы не могут сравниваться, иначе идет сравнение
                                                                                       соответствующих значений (смотри пример ниже)

object	                          что угодно	                                          object всегда больше

array	                          что угодно	                                          array всегда больше


..................................................................

$a ** $b	Возведение в степень	Результат возведения $a в степень $b. Добавлен в PHP 5.6.

Операция деления ("/") возвращает число с плавающей точкой, кроме случая, когда оба значения являются целыми числами (или строками, которые преобразуются в целые числа), которые делятся нацело - в этом случае возвращается целое значение.
При делении по модулю операнды преобразуются в целые числа (удалением дробной части) до начала операции.
Результат операции остатка от деления % будет иметь тот же знак, что и делимое — то есть, результат $a % $b будет иметь тот же знак, что и $a.

echo (5 % 3)."\n";           // выводит 2
echo (5 % -3)."\n";          // выводит 2
echo (-5 % 3)."\n";          // выводит -2
echo (-5 % -3)."\n";         // выводит -2
......................................................................
Строковые операторы 
Первый - оператор конкатенации ('.')
Второй - оператор присваивания с конкатенацией ('.='), который присоединяет правый аргумент к левому.
$a = "Hello ";
$b = $a . "World!"; // $b теперь содержит строку "Hello World!"

$a = "Hello ";
$a .= "World!";     // $a теперь содержит строку "Hello World!"

...............................................
Как уже было сказано, ссылки не являются указателями.
.........................Присвоение по ссылке
$b = 10;
$a  = & $b;   // то $a указывает на то же значение что и $b.
$b = 0;
echo " b = $b, a = $a";  //  b=0  ,  a=0
Замечание://TODO
$a и $b здесь абсолютно эквивалентны, но это не означает, что $a указывает на $b или наоборот. Это означает, что $a и $b указывают на одно и тоже значение.
Начиная с PHP 5, new автоматически возвращает объекты по ссылке, поэтому использовать =& в этом случае нерекомендуется и вызывает сообщение E_DEPRECATED в PHP 5.3 и последующих версиях, а также сообщение E_STRICT в более ранних версиях.

Внимание
Если переменной, объявленной внутри функции как global, будет присвоена ссылка, она будет видна только в функции. Чтобы избежать этого, используйте массив $GLOBALS.
	$var1 = "Example variable";
	$var2 = "";

		function global_references($use_globals)
		{
		    global $var1, $var2;
		    if (!$use_globals) {
			$var2 =& $var1;     // только локально
		    } else {
			$GLOBALS["var2"] =& $var1;   // глобально
		    }
		}

	global_references(false);
	echo "значение var2: '$var2'\n"; // значение var2: ''
	global_references(true);
	echo "значение var2: '$var2'\n"; // значение var2: 'Example variable'

Думайте о global $var; как о сокращении от $var =& $GLOBALS['var'];. Таким образом, присвоение $var другой ссылки влияет лишь на локальную переменную.//TODO

Однако следует отметить, что ссылки в массивах являются потенциально опасными.
..................Второе, что делают ссылки - передача параметров по ссылке.При этом локальная переменная в функции и переменная в вызывающей области видимости ссылаются на одно и то же содержимое.
Если вы хотите, что бы аргумент всегда передавался по ссылке, вы можете указать амперсанд  &  перед именем аргумента в описании функции.

По ссылке можно передавать:

Переменные, например foo($a)
Оператор new, например foo(new foobar())
Ссылки, возвращаемые функцией, например:

	function foo(&$var)
	{
	    $var++;
	}
	function &bar()
	{
	    $a = 5;
	    return $a;
	}

	foo(bar());
...............
передача массива в функцию по ссылке


..................Третье, что могут делать ссылки - это возврат по ссылке.  //  TODO ####
Возвращение по ссылке используется в тех случаях, когда вы хотите использовать функцию для выбора переменной, с которой должна быть связана данная ссылка. Не используйте возврат по ссылке для увеличения производительности. Ядро PHP само занимается оптимизацией. Применяйте возврат по ссылке только имея технические причины на это. При возвращении по ссылке используйте такой синтаксис:
	class foo {
	    public $value = 42;

	    public function &getValue() {
		return $this->value;  // OK
                // return ($this->value);  //PHP Notice:  Only variable references should be returned by reference in /home/valentin/t.php on line 16
	    }
	}

	$obj = new foo;
	$myValue = &$obj->getValue(); // $myValue указывает на $obj->value, равное 42.
	$obj->value = 2;
	echo $myValue;                // отобразит новое значение $obj->value, т.е. 2.

В этом примере устанавливается свойство объекта, возвращённого функцией getValue, а не его копии, как было бы без использования ссылок.

Замечание: // TODO  ####
В отличие от передачи параметров по ссылке, & здесь нужно использовать в обоих местах - для указания на то, что вы возвращаете ссылку, а не копию, как обычно, и для указания того, что происходит связывание по ссылке, а не обычное присвоение для $myValue.

Замечание:  // TODO ####
 Если вы возвращаете ссылку из функции используя следующий синтаксис: return ($this->value);, это не будет работать, так как вы возвращаете по ссылке результат выражения, а не переменную. По ссылке можно возвращать только переменные и ничего больше. Начиная с PHP 4.4.0 и PHP 5.1.0, если код пытается вернуть по ссылке динамическое выражение или результат оператора new, будет выброшено предупреждение E_NOTICE.
Для использования возвращаемой ссылки вы должны применять присвоение по ссылке:

<?php
function &collector() {
  static $collection = array();
  return $collection;
}
$collection = &collector();
$collection[] = 'foo';
?>
Для передачи возвращаемой ссылки в другую функцию, принимающую ссылку, вы можете использовать следующий синтаксис:
<?php
function &collector() {
  static $collection = array();
  return $collection;
}
array_push(collector(), 'foo');

Замечание: Заметим, что array_push(&collector(), 'foo'); не сработает, а приведет к неисправимой ошибке.
................................................
.........................................Объекты и ссылки 

Одним из ключевых моментов объектно-ориентированной парадигмы PHP 5, которой часто обсуждается, является "передача объектов по ссылке по умолчанию". Это не совсем верно. Этот раздел уточняет это понятие используя некоторые примеры.

//TODO ####
Ссылка в PHP это псевдоним (алиас), который позволяет присвоить двум переменным одинаковое значение. 
Начиная с PHP 5 объектная переменная больше не содержит сам объект как значение. Такая переменная содержит только идентификатор объекта, который позволяет найти конкретный объект при обращении к нему. Когда объект передается как аргумент функции, возвращается или присваивается другой переменной, то эти разные переменные не являются псевдонимами (алиасами): они содержат копию идентификатора, который указывает на один и тот же объект.

Пример #1 Ссылки и объекты

<?php
class A {
    public $foo = 1;
}  

$a = new A;
$b = $a;     // $a и $b копии одного идентификатора ($a) = ($b) = <id>

$b->foo = 2;
echo $a->foo."\n";  // 2


$c = new A;
$d = &$c;    // $c и $d ссылки
             // ($c,$d) = <id>

$d->foo = 2;
echo $c->foo."\n";             // 2


$e = new A;

function foo($obj) {
    // ($obj) = ($e) = <id>
    $obj->foo = 2;
}

foo($e);
echo $e->foo."\n";     // 2


?>


..................

При сбросе ссылки, просто разрывается связь имени и содержимого переменной. Это не означает, что ,содержимое переменной будет разрушено. Например:

<?php
$a = 1;
$b =& $a;
unset($a); 

Этот код не сбросит $b, а только $a.
Опять же, можно провести аналогию с вызовом unlink (в Unix).

.......Ссылки global .............................

Если вы объявляете переменную как global $var, вы фактически создаёте ссылку на глобальную переменную. Это означает то же самое, что и:

<?php
$var =& $GLOBALS["var"];
?>
Это значит, например, что сброс (unset) $var не приведёт к сбросу глобальной переменной.
<?
..............$this ..................................

В методах объекта, $this всегда является ссылкой на вызывающий объект.
........................................................................


...............................................
Используйте скобки, даже если они не обязательны. Чаще всего это повышает читаемость кода, непосредственно определяя порядок группировки, не полагаясь на конкретные приоритет или ассоциативность оператора.
В следующей таблице приведен список операторов, отсортированный по убыванию их приоритетов. Операторы, размещенные в одной строке имеют одинаковый приоритет и их группировка при выполнении определяется исходя из их ассоциативности.


Порядок выполнения операторов

Ассоциативность                     	               Оператор	                                          Дополнительная информация

неассоциативна	                                       clone new	                                          clone и new
левая	                                                   [	                                                  array()
правая	                                                   **	                                                  арифметика
правая	                              ++ -- ~ (int) (float) (string) (array) (object) (bool) @	                  типы и инкремент/декремент
неассоциативна	                                      instanceof	                                          типы
правая	                                                    !	                                                  логические операторы
левая(слева направо)                                      * / %	                                                  арифметические операторы
левая	                                                  + - .	                                                  арифметические операторы и строковые операторы
левая	                                                 << >>	                                                  побитовые операторы
неассоциативна	                                        < <= > >=	                                          операторы сравнения
неассоциативна	                                     == != === !== <>	                                          операторы сравнения
левая	                                                    &	                                                  побитовые операторы и ссылки
левая	                                                    ^	                                                  побитовые операторы
левая	                                                    |	                                                  побитовые операторы
левая	                                                    &&	                                                  логические операторы
левая	                                                    ||	                                                  логические операторы
левая	                                                    ? :	                                                  тернарный оператор
правая(справа налево)	                    = += -= *= **= /= .= %= &= |= ^= <<= >>= =>	                          операторы присваивания
левая	                                                    and	                                                  логические операторы
левая	                                                    xor	                                                  логические операторы
левая	                                                     or	                                                  логические операторы
левая	                                                      ,	                                                  множество применений

<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// ассоциативность тройного оператора отличается от C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>

приоритет и ассоциативность оператора определяет только группировку выражений, и не определяет порядок выполнения. PHP (в целом) не описывает в каком порядке выражение выполняется, и следует избегать код, опирающийся на порядок выполнения, так как поведение может меняться между версиями PHP в зависимости от окружающего кода.
................................................................
<?
Логические операторы
	Пример	                            Название	                                   Результат

	$a and $b	                       И	                              TRUE если и $a, и $b TRUE.
	$a or $b	                      Или	                              TRUE если или $a, или $b TRUE.
	$a xor $b	                   Исключающее или	                      TRUE если $a, или $b TRUE, но не оба.
	! $a	                          Отрицание	                              TRUE если $a не TRUE.
	$a && $b	                       И	                              TRUE если и $a, и $b TRUE.
	$a || $b	                       Или	                              TRUE если или $a, или $b TRUE.
	............................................

Операторы, работающие с массивами
Пример	                                        Название	                                    Результат

$a + $b	                                        Объединение	                                 Объединение массива $a и массива $b.
$a == $b	                                    Равно	                                 TRUE в случае, если $a и $b содержат одни и те же пары ключ/значение.
$a === $b	                             Тождественно равно	                                 TRUE в случае, если $a и $b содержат одни и те же паты ключ/значение в том же
                                                                                                 самом порядке и того же типа.
$a != $b	                                 Не равно	                                 TRUE, если массив $a не равен массиву $b.
$a <> $b	                                 Не равно	                                 TRUE, если массив $a не равен массиву $b.
$a !== $b	                           Тождественно не равно	                         TRUE, если массив $a не равен тождественно массиву $b.

Оператор + возвращает левый массив, к которому был присоединен правый массив. Для ключей, которые существуют в обоих массивах, будут использованы значения из левого массива, а соответствующие им элементы из правого массива будут проигнорированы.
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)

.................................................


Побитовые операторы позволяют считывать и устанавливать конкретные биты целых чисел.
http://php.net/manual/ru/language.operators.bitwise.php
			               Побитовые операторы
Пример				Название			             Результат

$a & $b                               И		                          Устанавливаются только те биты, которые установлены и 
                                                                           в $a, и в $b.

$a | $b			           Или	                                  Устанавливаются те биты, которые установлены в $a или в $b.
$a ^ $b				Исключающее или	                          Устанавливаются только те биты, которые установлены либо только в $a, либо только в $b, но не в  
                                                                          обоих одновременно.
~ $a	                           Отрицание	                          Устанавливаются те биты, которые не установлены в $a, и наоборот. (инверсия, 1 меняется на 0, и
                                                                            наоборот)
$a << $b	                   Сдвиг влево	                          Все биты переменной $a сдвигаются на $b позиций влево (каждая позиция подразумевает "умножение на 2")
$a >> $b	                   Сдвиг вправо	                          Все биты переменной $a сдвигаются на $b позиций вправо (каждая позиция подразумевает "деление на 2")

Побитовый сдвиг в PHP - это арифметическая операция. Биты, сдвинутые за границы числа, отбрасываются. Сдвиг влево дополняет число нулями справа, сдвигая в то же время знаковый бит числа влево, что означает что знак операнда не сохраняется. Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает что знак операнда сохраняется.
Используйте скобки для обеспечения необходимого приоритета операторов. Например, $a & $b == true сначала проверяет на равенство, а потом выполняет побитовое и; тогда как ($a & $b) == true сначала выполняет побитовое и, а потом выполняет проверку на равенство.

Если оба операнда для &, | и ^ являются строками, то операция будет выполнена над ASCII значениями символов, составляющих эти строки, и результатом будет строка. В других случаях, оба операнда будут приведены к целому и результатом будет тоже целое число.

Если операнд для оператора ~ является строкой, то операция будет произведена над ASCII значением символов, составляющих эту строку, и результатом будет строка. Иначе, и операнд и результат будут оперироваться как целые числа.

Both operands and the result for the << and >> operators are always treated as integers.

       Опция настроек PHP error_reporting использует побитовые значения,
       обеспечивая реальную демонстрацию гашения значений битов.
       Чтобы показать все ошибки кроме замечаний,
       инструкции в файле php.ini предлагают использовать:
       E_ALL & ~E_NOTICE
      
       Начинаем со значения E_ALL:
       00000000000000000111011111111111
       Затем берем значение E_NOTICE...
       00000000000000000000000000001000
       ... и инвертируем его с помощью ~:
       11111111111111111111111111110111
       Наконец, используем побитовое И (&), чтобы установить только те биты,
       которые установлены в единицу в обоих значениях:
       00000000000000000111011111110111
      
       Другой способ достичь этого - использовать ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, ^),
       чтобы получить только те биты, которые установлены в единицу
       либо только в одном, либо только в другом значении:
       E_ALL ^ E_NOTICE
      
       Опция error_reporting также может быть использована для демонстрации
       установки битов. Показать только ошибки и обрабатываемые ошибки можно
       следующим образом:
       E_ERROR | E_RECOVERABLE_ERROR
      
       Здесь мы комбинируем E_ERROR
       00000000000000000000000000000001
       и
       00000000000000000001000000000000
       с помощью оператора ИЛИ (OR, |),
       чтобы получить биты, установленные хотя бы в одном операнде:
       00000000000000000001000000000001
      

?????????????????????????????????? // https://www.kobzarev.com/programming/bitwise-operators-in-php-by-example.html
define('U_READ', 1 << 0);   // 0001
define('U_CREATE', 1 << 1); // 0010
define('U_EDIT', 1 << 2);   // 0100
define('U_DELETE', 1 << 3); // 1000
define('U_ALL', U_READ | U_CREATE | U_EDIT | U_DELETE); // 1111

Установка значений битов

Присваиваем одно право.
$user_perm =  U_READ; // только право чтения

Чтобы комбинировать несколько прав используем побитовый оператор ИЛИ.
$user_perm =  U_READ | U_DELETE; // можно читать и удалять

Добавляем все права с помощью заготовленной константы.
$user_perm =  U_ALL; // все права

Если нужно дать все права кроме одного или нескольких, то можно воспользоваться следующими операторами.
$user_perm =  U_ALL ^ U_DELETE;  // все права кроме  удаления
$user_perm =  U_ALL & ~ U_DELETE; // все права кроме  удаления, в данном случае 2 оператора
Разница между этими вариантами в том, что в первом случае просто переключается бит, если был 1, то станет 0, и наоборот.
Второй же вариант делает бит равным 0, независимо от его текущего значения.

Проверка значения бита

Выставлять биты мы уже научились, теперь рассмотрим как же их использовать, т.е. проверять значение. Для проверки наличия прав доступа используем побитовый оператор И.
if($user_perm & U_READ) // есть ли право чтения?

Можно проверять значения сразу нескольких бит, к примеру
if($user_perm & ( U_READ | U_DELETE )) // есть ли право чтения и/или удаления

Сброс бита

Если мы хотим убрать какое-нибудь право доступа, то пишем так
$user_perm &= ~ U_DELETE; // запретить удаление











.................................................................
Оператор управления ошибками

PHP поддерживает один оператор управления ошибками: знак (@). В случае, если он предшествует какому-либо выражению в PHP-коде, любые сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено



Выражения - это самые важные строительные элементы PHP. Почти все, что вы пишете в PHP, является выражением. Самое простое и точное определение выражения - "все что угодно, имеющее значение".

Замечание: // TODO
Оператор @ работает только с выражениями. Есть простое правило: если что-то возвращает значение, значит вы можете использовать перед ним оператор @. Например, вы можете использовать @ перед именем переменной, произвольной функцией или вызовом include, константой и так далее. 
В то же время вы не можете использовать этот оператор перед определением функции или класса, условными конструкциями, такими как if, foreach и т.д.
Внимание
На сегодняшний день оператор "@" подавляет вывод сообщений даже о критических ошибках, прерывающих работу скрипта. Помимо всего прочего, это означает, что если вы использовали "@" для подавления ошибок, возникающих при работе какой-либо функции, в случае если она недоступна или написана неправильно, дальнейшая работа скрипта будет остановлена без каких-либо уведомлений.
.....................................

..........................Операторы исполнения 

PHP поддерживает один оператор исполнения: обратные кавычки (``). Обратите внимание, что это не одинарные кавычки! PHP попытается выполнить строку, заключенную в обратные кавычки, как консольную команду, и вернет полученный вывод (т.е. он не просто выводится на экран, а, например, может быть присвоен переменной). Использование обратных кавычек аналогично использованию функции shell_exec().

<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
Замечание:
Обратные кавычки недоступны, в случае, если включен безопасный режим или отключена функция shell_exec().
................................................................
Оператор проверки типа 

Оператор instanceof используется для определения того, является ли текущий объект экземпляром указанного класса.
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);           // bool(true)
var_dump($a instanceof ParentClass);         // bool(true)
var_dump(!($a instanceof stdClass));
............
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);

?>
.......................................................................
Значения аргументов по умолчанию 

Функция может определять значения по умолчанию в стиле C++ для скалярных аргументов, например:

<?php
function makecoffee($type = "капуччино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();        // Готовим чашку капуччино.
echo makecoffee(null);        // Готовим чашку .
echo makecoffee("эспрессо");  // Готовим чашку эспрессо.
?>
.........
PHP также позволяет использовать массивы (array) и специальный тип NULL в качестве значений по умолчанию, например:

Использование нескалярных типов в качестве значений по умолчанию
<?php
function makecoffee($types = array("капуччино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капуччино", "лавацца"), "в чайнике");

...................
Значение по умолчанию должно быть константным выражением, а не (к примеру) переменной или вызовом функции/метода класса.
Обратите внимание, что все аргументы, для которых установлены значения по умолчанию, должны находиться правее аргументов, для которых значения по умолчанию не заданы, в противном случае ваш код может работать не так, как вы этого ожидаете. Рассмотрим следующий пример:
Корректное использование значений по умолчанию

<?php

// function makeyogurt($type = "ацидофил", $flavour)  // error

function makeyogurt($flavour, $type = "ацидофил")
{
    return "Готовим чашку из бактерий $type со вкусом $flavour.\n";
}
 
echo makeyogurt("малины");   // отрабатывает правильно

http://php.net/manual/ru/functions.arguments.php
////////////////////////////////////////////////////////////

Управляющие конструкции: if, else, elseif/else if ...

.................Альтернативный синтаксис управляющих структур 
(PHP 4, PHP 5, PHP 7)     //   http://php.net/manual/ru/control-structures.alternative-syntax.php
PHP предлагает альтернативный синтаксис для некоторых его управляющих структур, а именно: if, while, for, foreach и switch. В каждом случае основной формой альтернативного синтаксиса является изменение открывающей фигурной скобки на двоеточие (:), а закрывающей скобки на endif;, endwhile;, endfor;, endforeach; или endswitch; соответственно.

<?php if ($a == 5): ?>
A равно 5
<?php endif; ?>

Замечание:
Смешивание синтаксиса в одном и том же блоке управления не поддерживается.
<?
.................
(PHP 4, PHP 5, PHP 7)                  foreach
Конструкция foreach предоставляет простой способ перебора массивов. Foreach работает только с массивами и объектами, и будет генерировать ошибку при попытке использования с переменными других типов или неинициализированными переменными. Существует два вида синтаксиса:

foreach (array_expression as $value)
    statement
foreach (array_expression as $key => $value)
    statement

Первый цикл перебирает массив, задаваемый с помощью array_expression. На каждой итерации значение текущего элемента присваивается переменной $value и внутренний указатель массива увеличивается на единицу (таким образом, на следующей итерации цикла работа будет происходить со следующим элементом).

Второй цикл будет дополнительно соотносить ключ текущего элемента с переменной $key на каждой итерации.

Замечание:
Когда оператор foreach начинает исполнение, внутренний указатель массива автоматически устанавливается на первый его элемент Это означает, что нет необходимости вызывать функцию reset() перед использованием цикла foreach.
Так как оператор foreach опирается на внутренний указатель массива, его изменение внутри цикла может привести к непредсказуемому поведению.

Для того, чтобы напрямую изменять элементы массива внутри цикла, переменной $value должен предшествовать знак &. В этом случае значение будет присвоено по ссылке.
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// массив $arr сейчас таков: array(2, 4, 6, 8)
unset($value); // разорвать ссылку на последний элемент
?>

Указатель на $value возможен, только если на перебираемый массив можно ссылаться (т.е. если он является переменной). Следующий код не будет работать:
<?php
foreach (array(1, 2, 3, 4) as &$value) {
    $value = $value * 2;
}
?>
Внимание
Ссылка $value на последний элемент массива остается даже после того, как оператор foreach завершил работу. Рекомендуется уничтожить ее с помощью функции unset().
Замечание:
Оператор foreach не поддерживает возможность подавления сообщений об ошибках с помощью префикса '@'.
...
<?
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
declare     ????

.............................

Возврат значений 

Значения возвращаются при помощи необязательного оператора возврата. Возвращаемые значения могут быть любого типа, в том числе это могут быть массивы и объекты. Возврат приводит к завершению выполнения функции и передаче управления обратно к той строке кода, в которой данная функция была вызвана. Для получения более детальной информации ознакомьтесь с описанием return.

Замечание:
Если конструкция return не указана, то функция вернет значение NULL.
Использование выражения return

Пример #1 Использование конструкции return

<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
Функция не может возвращать несколько значений, но аналогичного результата можно добиться, возвращая массив.

Пример #2 Возврат нескольких значений в виде массива

<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
Для того, чтобы функция возвращала результат по ссылке, вам необходимо использовать оператор & и при описании функции, и при присвоении переменной возвращаемого значения:

Пример #3 Возврат результата по ссылке

<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
Для получения более детальной информации о ссылках обратитесь к разделу документации Подробно о ссылках.

Объявление типов возвращаемых значений 

В PHP 7 добавлена возможность объявлять тип возвращаемого значения. Аналогично объявлению типов аргументов можно задать тип значения, которое будет возвращаться функцией. Типы, которые можно объявить для возвращаемых значений те же, что и для аргументов фукнций.

Режим строгой типизации также работает для объявлении типа возвращаемого значения. В обычном режиме слабой типизации возвращаемое из функции значение приводится к корректному типу. При строгой типизации возвращаемое значение должно быть заданного типа, иначе будет выброшено исключение TypeError.

Замечание:
Если переопределяется родительский метод, возвращаемое значение дочернего метода должно быть того же типа, что и родительского. Если в родительском методе не задан тип возвращаемого значения, то и дочерний метод этот тип может не объявлять.
Примеры 

Пример #4 Обычное объявление типа возвращаемого значения

<?php
function sum($a, $b): float {
    return $a + $b;
}

// Будет возвращаться значение типа float.
var_dump(sum(1, 2));
?>
Результат выполнения данного примера:

float(3)
Пример #5 То же в режиме строгой типизации

<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
Результат выполнения данного примера:

int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5

Пример #6 Возврат объектов

<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());

Результат выполнения данного примера:

object(C)#1 (0) {
}
......................................
return возвращает управление программой в вызывавший модуль. Выполнение возвращается в выражение, следующее после вызова текущего модуля.

Если вызвано из функции, выражение return немедленно прекращает выполнение текущей функции и возвращает свой аргумент как значение данной функции. return также завершает выполнение выражения eval() или всего файла скрипта.

Если вызывается из глобальной области видимости, выполнение текущего файла скрипта прекращается.
 Если текущий файл скрипта был подключен с помощью функций include или require, тогда управление возвращается к файлу, который вызывал текущий. Более того, если текущий файл скрипта был подключен с помощью include, тогда значение переданное return будет возвращено в качестве значения вызова include. 
Если return вызывается из главного файла скрипта, тогда выполнение скрипта прекращается. Если текущий файл скрипта был вызван конфигурационными опциями auto_prepend_file или auto_append_file из файла настроек php.ini, тогда выполнение этого скрипта прекращается.

Замечание: 
Заметьте, что так как return является языковой конструкцией, а не функцией, круглые скобки, окружающие аргументы, не являются необходимостью. Общепринято не использовать их в данном случае и, в принципе, так и надо делать, т.к. PHP будет меньше работы по синтаксическому разбору файла в данном случае.
Замечание: 
Если параметры не указаны, тогда круглые скобки должны быть опущены, и вернется значение NULL. Вызов return со скобками, но без аргументов вызовет синтаксическую ошибку.
Замечание:
Вы не должны использовать скобки при возврате переменной, если возвращаете по ссылке, так как это не сработает. Вы можете вернуть только переменную по ссылке, а не результат выражения. Если вы используете return ($a);, тогда вы вернете не переменную, а результат выражения ($a) (который, естественно, будет являться значением переменной $a).

........................................................

require 

(PHP 4, PHP 5, PHP 7)
require идентично include за исключением того, что при ошибке оно также выдаст фатальную ошибку уровня E_COMPILE_ERROR. Другими словами, она остановит выполнение скрипта, тогда как include только выдала бы предупреждение E_WARNING, которое позволило бы скрипту продолжить выполнение.

include 

(PHP 4, PHP 5, PHP 7)
Выражение include включает и выполняет указанный файл.
Файлы включаются исходя из пути указанного файла, или, если путь не указан, используется путь, указанный в директиве include_path. Если файл не найден в include_path, include попытается проверить директорию, в которой находится текущий включающий скрипт и текущую рабочую директорию перед тем, как выдать ошибку. Конструкция include выдаст warning, если не сможет найти файл; поведение отлично от require, который выдаст фатальную ошибку.
Для большей информации о том, как PHP обрабатывает включаемые файлы и включаемые пути, смотрите документацию для директивы include_path.

Когда файл включается, его код наследует ту же область видимости переменных, что и строка, на которой произошло включение. Все переменные, доступные на этой строке во включающем файле будут также доступны во включаемом файле. Однако все функции и классы, объявленные во включаемом файле, будут доступны в глобальной области видимости.

Если включение происходит внутри функции включающего файла, тогда весь код, содержащийся во включаемом файле, будет вести себя так, как будто он был определен внутри этой функции. То есть, он будет в той же области видимости переменных этой функции. Исключением к этому правилу являются магические константы, которые выполняются парсером перед тем, как происходит включение.

require_once 

(PHP 4, PHP 5, PHP 7)
Выражение require_once идентично require за исключением того, что PHP проверит, включался ли уже данный файл, и, если да, не будет включать его еще раз.

include_once 

(PHP 4, PHP 5, PHP 7)
Выражение include_once включает и выполняет указанный файл во время выполнения скрипта. Его поведение идентично выражению include, с той лишь разницей, что если код из файла уже один раз был включен, он не будет включен и выполнен повторно. Как видно из имени, он включит файл только один раз (include once).

include_once может использоваться в тех случаях, когда один и тот же файл может быть включен и выполнен более одного раза во время выполнения скрипта, в данном случае это поможет избежать проблем с переопределением функций, переменных и т.д.

.............................................
 goto 

(PHP 5 >= 5.3.0, PHP 7)
Оператор goto используется для перехода в другую часть программы. Место, куда необходимо перейти указывается с помощью метки, за которой ставится двоеточие, после оператора goto указывается желаемая метка для перехода.
 Оператор не является неограниченным "goto". Целевая метка должна находиться в том же файле, в том же контексте. Имеется ввиду, что вы не можете ни перейти за границы функции или метода, ни перейти внутрь одной из них. Вы также не можете перейти внутрь любой циклической структуры или оператора switch. Но вы можете выйти из них, и обычным применением оператора goto является использование его вместо многоуровневых break.
<?php
for($i=0,$j=50; $i<100; $i++) {
  while($j--) {
    if($j==17) goto end; 
  }  
}
echo "i = $i";
end:
echo 'j hit 17';


...............................................................................................
http://php.net/manual/ru/language.functions.php
...................Функции 
Функции не обязаны быть определены до их использования, исключая тот случай, когда функции определяются условно, как это показано в двух последующих примерах.
(перед выполненим программы PHP просматривает весь файл не запуская его, запоминает названия ф-ций)
В случае, когда функция определяется в зависимости от какого-либо условия, например, как это показано в двух приведенных ниже примерах, обработка описания функции должна предшествовать ее вызову.
Пример #2 Функции, зависящие от условий
<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она еще не определена, но мы можем 
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Я не существую до тех пор, пока выполнение программы меня не достигнет.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar() 
{
  echo "Я существую сразу с начала старта программы.\n";
}

?>
Вложенные функции
<?php
function foo() 
{
  function bar() 
  {
    echo "Я не существую пока не будет вызвана foo().\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она еще не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала ее доступной. */

bar();

?>


..............Объявление типов 

Замечание:Объявление типов также известно, как подсказки для типов в PHP 5.
Объявления типов позволяют функциям строго задавать тип передаваемых параметров. Передача в функцию значений несоответствующего типа будет приводить к ошибке: в PHP 5 это будет обрабатываемая фатальная ошибка, а в PHP 7 будет выбрасываться исключение TypeError.

Чтобы объявить тип агрумента, необходимо перед его именем добавить имя требуемого типа. Также можно объявить тип NULL, чтобы указать, что значением по умолчанию аргумента является NULL.
Объявление типа Null
	<?php
	class C {}

	function f(C $c = null) {
	    var_dump($c);
	}

	f(new C); // object(C)#1 (0)
	f(null);  // NULL
	
.............................................
Тип					Описание											Минимальная версия PHP

Имя класса/интерфейса			Агрумент должен быть instanceof, что и имя класса или интерфейса.				PHP 5.0.0
array					Аргумент должен быть типа array.								PHP 5.1.0
callable				Аргумент должен быть корректным callable типом.							PHP 5.4.0
bool					Аргумент должен быть типа boolean.								PHP 7.0.0
float					Аргумент должен быть float типа.								PHP 7.0.0
int					Аргумент должен быть типа integer.								PHP 7.0.0
string					Аргумент должен иметь тип string.								PHP 7.0.0
...........................................
callable ????

	<?php
	class C {}
	class D extends C {}

	// Это не является расширением класса C.
	class E {}

	function f(C $c) {
	    echo get_class($c)."\n";
	}

	f(new C);   // C
	f(new D);   // D
	f(new E);    // error
	

..........Строгая типизация 

По умолчанию, PHP будет пытаться привести значения несоответствующих типов к скалярному типу, если это возможно. Например, если в функцию передается integer, а тип аргумента объявлен string, в итоге функция получит преобразованное string значение.

Для отдельных файлов можно включать режим строгой типизации. В этом режиме в функцию можно передавать значения только тех типов, которые объявлены для аргументов. В противном случае будет выбрасываться исключение TypeError. Есть лишь одно исключение - integer можно передать в функцию, которая ожидает значение типа float.

Для влючения режима строгой типизации используется выражение declare в объявлении strict_types:

Предостережение:Включение режима строгой типизации также повлияет на объявления типов возвращаемых значений.
Замечание:
Режим строгой типизации распространяется на вызовы функций совершенные из файла, в котором этот режим включен, а не на функции, которые в этом файле объявлены. Если файл без строгой типизации вызывает функцию, которая объявлена в файле с включенным режимом, значения аргументов будут приведены к нужным типам и ошибок не последует.
Замечание:
Строгая типизация применима только к скалярным типам и работает только в PHP 7.0.0 и выше. Равно как и сами объявления скалярных типов добавлены в этой версии.

Строгая типизация
	<?php
	declare(strict_types=1);

	function sum(int $a, int $b) {
	    return $a + $b;
	}

	var_dump(sum(1, 2));    // int(3)
	var_dump(sum(1.5, 2.5));  // error
	?>
Слабая типизация
	<?php
	function sum(int $a, int $b) {
	    return $a + $b;
	}

	var_dump(sum(1, 2));

	// These will be coerced to integers: note the output below!
	var_dump(sum(1.5, 2.5));
	?>
Обработка исключения TypeError
	<?php
	declare(strict_types=1);

	function sum(int $a, int $b) {
	    return $a + $b;
	}

	try {
	    var_dump(sum(1, 2));
	    var_dump(sum(1.5, 2.5));
	} catch (TypeError $e) {
	    echo 'Error: '.$e->getMessage();
	}
	?>

Объявление типов возвращаемых значений (PHP 7 )
Режим строгой типизации также работает для объявлении типа возвращаемого значения. В обычном режиме слабой типизации возвращаемое из функции значение приводится к корректному типу. При строгой типизации возвращаемое значение должно быть заданного типа, иначе будет выброшено исключение TypeError.
Замечание:
Если переопределяется родительский метод, возвращаемое значение дочернего метода должно быть того же типа, что и родительского. Если в родительском методе не задан тип возвращаемого значения, то и дочерний метод этот тип может не объявлять.

Обычное объявление типа возвращаемого значения

<?php
	function sum($a, $b): float {
	    return $a + $b;
	}

	// Будет возвращаться значение типа float.
	var_dump(sum(1, 2));     // float(3)
?>

То же в режиме строгой типизации

<?php
	declare(strict_types=1);

	function sum($a, $b): int {
	    return $a + $b;
	}

	var_dump(sum(1, 2)); // int(3)
	var_dump(sum(1, 2.5));  // Fatal error

?>
Возврат объектов
<?
	class C {}

	function getC(): C {
	    return new C;
	}

Обращение к функциям через переменные 

PHP поддерживает концепцию переменных функций. Это означает, что если к имени переменной присоединены круглые скобки, PHP ищет функцию с тем же именем, что и результат вычисления переменной, и пытается ее выполнить. Эту возможность можно использовать для реализации обратных вызовов, таблиц функций и множества других вещей.
Переменные функции не будут работать с такими языковыми конструкциями как echo, print, unset(), isset(), empty(), include, require и другими подобными им операторами. Вам необходимо реализовывать свою функцию-обертку (wrapper) для того, чтобы приведенные выше конструкции могли работать с переменными функциями.
Пример #1 Работа с функциями посредством переменных
<?php
	function foo() {
	    echo "In foo()<br />\n";
	}

	function bar($arg = '')
	{
	    echo "In bar(); argument was '$arg'.<br />\n";
	}

	// Функция-обертка для echo
	function echoit($string)
	{
	    echo $string;
	}

	$func = 'foo';
	$func();        // Вызывает функцию foo()

	$func = 'bar';
	$func('test');  // Вызывает функцию bar()

	$func = 'echoit';
	$func('test');  // Вызывает функцию echoit()

Пример #2 Обращение к методам класса посредством переменных
<?php
	class Foo
	{
	    function Variable()
	    {
		$name = 'Bar';
		$this->$name(); // Вызываем метод Bar()
	    }
	    
	    function Bar()
	    {
		echo "This is Bar";
	    }
	}

	$foo = new Foo();
	$funcname = "Variable";
	$foo->$funcname();  // Обращаемся к $foo->Variable()


При вызове статических методов, вызов функции "сильнее" чем оператор доступа к статическому свойству:

Пример #3 Пример вызова переменного метода со статическим свойством
<?php
	class Foo
	{
	    static $variable = 'static property';
	    static function Variable()
	    {
		echo 'Method Variable called';
	    }
	}

	echo Foo::$variable; // Это выведет 'static property'. Переменная $variable будет разрешена в нужной области видимости.
	$variable = "Variable";
	Foo::$variable();  // Это вызовет $foo->Variable(), прочитав $variable из этой области видимости.


................Встроенные функции  ( http://php.net/manual/ru/functions.internal.php )
В самом PHP содержится достаточно большое количество встроенных функций и языковых конструкций. Также есть функции, которые требуют, чтобы PHP был собран со специфическими расширениями, в противном случае вы получите сообщение о фатальной ошибке, вызванной использованием неизвестной функции.

................Анонимные функции ( http://php.net/manual/ru/functions.anonymous.php )

Анонимные функции, также известные как замыкания (closures), позволяют создавать функции, не имеющие определенных имен. Они наиболее полезны в качестве значений 
callback-параметров, но также могут иметь и множество других применений.
Пример #1 Пример анонимной функции

<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// выведет helloWorld

Пример #2 Пример присвоения анонимной функции переменной

<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');

и другое ????

echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// outputs helloWorld

// inherit
$message = 'hello';

// Without "use" keyword
$example = function () {
    var_dump($message);
};
echo $example();

// Inherit $message
$example = function () use ($message) {
    var_dump($message);
};
echo $example();
....
Variadic functions

function sum(...$nums)
{
    return array_sum($nums);
}
............................................
a bit tricky:
echo ( "-0" ? "yes" : "no" ); // => yes
echo ( "0" ? "yes" : "no" ); // => no
while -0 is equal to 0, the tricky thing is that "-0" evaluates as string however the "0" evaluates as number
..............................................

// define variables and set to empty values
$name = $email = $gender = $comment = $website = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  $name = test_input($_POST["name"]);
  $email = test_input($_POST["email"]);
  $website = test_input($_POST["website"]);
  $comment = test_input($_POST["comment"]);
  $gender = test_input($_POST["gender"]);
}

function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}

//http://www.w3schools.com/php/php_form_validation.asp

....................................
$user = isset($_GET['user']) ? $_GET['user'] : 'Guest';
...........................................

................Альтернативный синтаксис управляющих структур .................
(PHP 4, PHP 5, PHP 7)
PHP предлагает альтернативный синтаксис для некоторых его управляющих структур, а именно: if, while, for, foreach и switch. В каждом случае основной формой альтернативного синтаксиса является изменение открывающей фигурной скобки на двоеточие (:), а закрывающей скобки на endif;, endwhile;, endfor;, endforeach; или endswitch; соответственно.

<?php if ($a == 5): ?>
A равно 5
<?php endif; ?>

Альтернативный синтаксис также применяется и к else и elseif. Ниже приведена структура if с elseif и else в альтернативном формате:

<?php
if ($a == 5):
    echo "a равно 5";
    echo "...";
elseif ($a == 6):
    echo "a равно 6";
    echo "!!!";
else:
    echo "a не равно ни 5 ни 6";
endif;
?>
Замечание:
Смешивание синтаксиса в одном и том же блоке управления не поддерживается.
Внимание
Любой вывод (включая пробельные символы) между выражением switch и первым case приведут к синтаксической ошибке. Например этот код не будет работать:
<?php switch ($foo): ?>
    <?php case 1: ?>
    ...
<?php endswitch ?>
В то же время следующий пример будет работать, так как завершающий перевод строки после выражения switch считается частью закрывающего ?> и следовательно ничего не выводится между switch и case:
<?php switch ($foo): ?>
<?php case 1: ?>
    ...
<?php endswitch ?>

.....................

		<p class="titl">Категории</p>
		
	<?php foreach ($categories as $categoryItem): ?>
	<p> <a href="/category/<?php echo $categoryItem['id']; ?>">
	<?php echo $categoryItem['title']; ?>
	</a> </p>    
	<?php endforeach; ?>

.......................foreach................
<?
(PHP 4, PHP 5, PHP 7)
Конструкция foreach предоставляет простой способ перебора массивов. Foreach работает только с массивами и объектами, и будет генерировать ошибку при попытке использования с переменными других типов или неинициализированными переменными. Существует два вида синтаксиса:

foreach (array_expression as $value)
    statement

foreach (array_expression as $key => $value)
    statement

Первый цикл перебирает массив, задаваемый с помощью array_expression. На каждой итерации значение текущего элемента присваивается переменной $value и внутренний указатель массива увеличивается на единицу (таким образом, на следующей итерации цикла работа будет происходить со следующим элементом).

Второй цикл будет дополнительно соотносить ключ текущего элемента с переменной $key на каждой итерации.

Замечание:
Когда оператор foreach начинает исполнение, внутренний указатель массива автоматически устанавливается на первый его элемент Это означает, что нет необходимости вызывать функцию reset() перед использованием цикла foreach.
Так как оператор foreach опирается на внутренний указатель массива, его изменение внутри цикла может привести к непредсказуемому поведению.
Для того, чтобы напрямую изменять элементы массива внутри цикла, переменной $value должен предшествовать знак &. В этом случае значение будет присвоено по ссылке.

$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// массив $arr сейчас таков: array(2, 4, 6, 8)
unset($value); // разорвать ссылку на последний элемент

Указатель на $value возможен, только если на перебираемый массив можно ссылаться (т.е. если он является переменной). Следующий код не будет работать:

foreach (array(1, 2, 3, 4) as &$value) {
    $value = $value * 2;
}

Внимание
Ссылка $value на последний элемент массива остается даже после того, как оператор foreach завершил работу. Рекомендуется уничтожить ее с помощью функции unset().
Замечание:
Оператор foreach не поддерживает возможность подавления сообщений об ошибках с помощью префикса '@'.

..................Оператор управления ошибками........................

PHP поддерживает один оператор управления ошибками: знак (@). В случае, если он предшествует какому-либо выражению в PHP-коде, любые сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.//TODO

Если вы установили собственную функцию обработки ошибок с помощью set_error_handler(), то она все равно будет вызвана, однако, если внутри этой функции будет вызвана функция error_reporting(), то она вернет 0, если функция, вызвавшая данную ошибку, была подавлена с помощью @.

В случае, если установлена опция track_errors , все генерируемые сообщения об ошибках будут сохраняться в переменной $php_errormsg. Эта переменная будет перезаписываться при каждой новой ошибке, поэтому в случае необходимости проверяйте ее сразу же.
.......................................................................//TODO
http://php.net/manual/ru/errorfunc.configuration.php#ini.track-errors
http://php.net/manual/ru/reserved.variables.phperrormsg.php
The track_errors parameter is PHP_INI_ALL, so you can use code like this: 

<?php 
ini_set('track_errors', 1); 

$result = @do_risky_thing(); 
if (! $result) { 
    echo '<p>Error' . htmlspecialchars($php_errormsg) . '</p>'; 
} 

ini_set('track_errors', 0); 
?>
.......................................................
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено
Замечание: //TODO
Оператор @ работает только с выражениями. Есть простое правило: если что-то возвращает значение, значит вы можете использовать перед ним оператор @. Например, вы можете использовать @ перед именем переменной, произвольной функцией или вызовом include, константой и так далее.
 В то же время вы не можете использовать этот оператор 
перед определением функции или класса, 
условными конструкциями, такими как if, foreach и т.д.
Внимание
На сегодняшний день оператор "@" подавляет вывод сообщений даже о критических ошибках, прерывающих работу скрипта. Помимо всего прочего, это означает, что если вы использовали "@" для подавления ошибок, возникающих при работе какой-либо функции, в случае если она недоступна или написана неправильно, дальнейшая работа скрипта будет остановлена без каких-либо уведомлений.

>>>>>>>>>>>>>>>>>>>>>  Выражения  >>>>>>// TODO
Выражения - это самые важные строительные элементы PHP. Почти все, что вы пишете в PHP, является выражением. Самое простое и точное определение выражения - "все что угодно, имеющее значение".

Основными формами выражений являются константы и переменные. Если вы записываете "$a = 5", вы присваиваете '5' переменной $a. '5', очевидно, имеет значение 5 или, другими словами, '5' это выражение со значением 5 (в данном случае '5' - это целочисленная константа).

После этого присвоения вы ожидаете, что значением $a также является 5, поэтому, если вы написали $b = $a, вы полагаете, что работать это будет так же, как если бы вы написали $b = 5. Другими словами, $a это также выражение со значением 5. Если все работает верно, то именно так и произойдет.

Немного более сложными примерами выражений являются функции. Например, рассмотрим следующую функцию:

<?php
function foo ()
{
    return 5;
}

Исходя из того, что вы хорошо знакомы с концепцией функций (если нет, то прочитайте главу о функциях), вы полагаете, что запись $c = foo() абсолютно эквивалентна записи $c = 5, и вы правы.
 	Функции - это выражения, значением которых является то, что возвращает функция. Поскольку foo() возвращает 5, значением выражения 'foo()' является 5. Как правило, функции возвращают не просто статическое значение, а что-то вычисляют.

	Разумеется, значения в PHP не обязаны быть целочисленными, и очень часто ими не являются. 
PHP поддерживает четыре типа скалярных значений: целочисленные (integer), с плавающей точкой (float), строковые значения (string) и булевы (boolean) значения (скалярными являются значения, которые вы не можете 'разбить' на меньшие части, в отличие, например, от массивов).
PHP поддерживает также два комбинированных (не скалярных) типа: массивы и объекты. Любое значение такого типа может присваиваться переменной или возвращаться функцией.

	Однако PHP, как и многие другие языки, понимает гораздо больше выражений. PHP - это язык, ориентированный на выражения и рассматривающий почти все как выражение. Вернемся к примеру, с которым мы уже имели дело: '$a = 5'. Легко заметить, что здесь присутствуют два значения - значение целочисленной константы '5' и значение переменной $a, также принимающей значение 5. Но на самом деле здесь присутствует и еще одно значение - значение самого присвоения. Само присвоение вычисляется в присвоенное значение, в данном случае - в 5. На практике это означает, что '$a = 5', независимо от того, что оно делает, является выражением со значением 5. Таким образом, запись '$b = ($a = 5)' равносильна записи '$a = 5; $b = 5;' (точка с запятой обозначает конец выражения). Поскольку операции присвоения анализируются справа налево, вы также можете написать '$b = $a = 5'.

	Другой хороший пример ориентированности на выражения - префиксный и постфиксный инкремент и декремент. Пользователи PHP и многих других языков возможно уже знакомы с формой записи variable++ и variable--. Это операторы инкремента и декремента. Также как и C, PHP поддерживает два типа инкремента - префиксный и постфиксный. Они оба инкрементируют значение переменной и эффект их действия на нее одинаков. Разница состоит в значении выражения инкремента. 
Префиксный инкремент, записываемый как '++$variable', вычисляется в инкрементированное значение (PHP инкрементирует переменную до того как прочесть ее значение, отсюда название 'пре-инкремент'). 
Постфиксный инкремент, записываемый как '$variable++', вычисляется в первоначальное значение переменной $variable до ее приращения (PHP инкрементирует переменную после прочтения ее значения, отсюда название 'пост-инкремент').//TODO

	Очень распространенным типом выражений являются выражения сравнения. Результатом вычислений являются FALSE (ложь) или TRUE (истина). PHP поддерживает операции сравнения > (больше), >= (больше либо равно), == (равно), != (не равно), < (меньше) и <= (меньше либо равно). Он также поддерживает операторы строгого равенства: === (равно и одного типа) и !== (не равно или не одного типа). Чаще всего эти выражения используются в операторах условного выполнения, таких как if.

	Последний пример выражений, который мы здесь рассмотрим, это смешанные выражения операции и присвоения. 
Вы уже знаете, что если вы хотите увеличить $a на 1, вы можете просто написать '$a++' или '++$a'. Но что, если вы хотите прибавить больше, чем единицу,например, 3? Вы могли бы написать '$a++' много раз, однако, очевидно это не очень рациональный и удобный способ. Гораздо более распространенной практикой является запись вида '$a = $a + 3'. 
'$a + 3' вычисляется в значение $a плюс 3 и снова присваивается $a, увеличивая в результате $a на 3. В PHP, как и в некоторых других языках, таких как C, вы можете записать это более коротким образом, что увеличит очевидность смысла и быстроту понимания кода по прошествии времени. Прибавить 3 к текущему значению $a можно с помощью записи '$a += 3'. Это означает дословно "взять значение $a, прибавить к нему 3 и снова присвоить его переменной $a". Кроме большей понятности и краткости, это быстрее работает. Значением '$a += 3', как и обычного присвоения, является присвоенное значение. Обратите внимание, что это НЕ 3, а суммированное значение $a плюс 3 (то, что было присвоено $a). Таким образом может использоваться любой бинарный оператор, например, '$a -= 5' (вычесть 5 из значения $a), '$b *= 7' (умножить значение $b на 7) и т.д.

Существует еще одно выражение, которое может выглядеть необычно, если вы не встречали его в других языках - тернарный условный оператор:


$first ? $second : $third

Если значением первого подвыражения является TRUE (не ноль), то выполняется второе подвыражение, которое и будет результатом условного выражения. В противном случае будет выполнено третье подвыражение и его значение будет результатом.

Следующий пример должен помочь вам немного улучшить понимание префиксного и постфиксного инкремента и выражений:

<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;        /* присвоить значение пять переменным $a и $b */
$c = $a++;          /* постфиксный инкремент, присвоить значение $a 
                       (5) переменной $c */
$e = $d = ++$b;     /* префиксный инкремент, присвоить увеличенное
                       значение $b (6) переменным $d и $e */

/* в этой точке и $d, и $e равны 6 */

$f = double($d++);  /* присвоить удвоенное значение $d перед
                       инкрементом (2*6 = 12) переменной $f */
$g = double(++$e);  /* присвоить удвоенное значение $e после
                       инкремента (2*7 = 14) переменной $g */
$h = $g += 10;      /* сначала переменная $g увеличивается на 10,
                       приобретая, в итоге, значение 24. Затем значение
                       присвоения (24) присваивается переменной $h,
                       которая в итоге также становится равной 24. */

$a=1;
$a=$a-- +1; // 2

	Некоторые выражения могут рассматриваться как инструкции. В данном случае инструкция имеет вид 'expr' ; - выражение с последующей точкой с запятой. 
В записи '$b = $a = 5;', $a = 5 - это верное выражение, но само по себе не инструкция. Тогда как '$b = $a = 5;' является верной инструкцией.//??

Последнее, что стоит упомянуть, это истинность значения выражений. Во многих случаях, как правило, в условных операторах и циклах, вас может интересовать не конкретное значение выражения, а только его истинность (значение TRUE или FALSE). Константы TRUE и FALSE (регистро-независимые) - это два возможных булевых значения. При необходимости выражение автоматически преобразуется в булев тип. Подробнее о том, как это происходит, смотрите в разделе о приведении типов.

PHP предоставляет полную и мощную реализацию выражений, и их полное документирование выходит за рамки этого руководства. Вышеприведенные примеры должны дать вам представление о том, что они из себя представляют и как вы сами можете создавать полезные выражения. Далее, для обозначения любого верного выражения PHP в этой документации мы будем использовать сокращение expr.



<<<<<<<<<<<<<<<<<<<<<
В PHP две области видимости переменных:
Локальная обл.видим.(внутри ф-ции)
Глобальная обл.видим.(вне ф-ции)

Доступ к глобальным пер. внутри ф-ции:
global
$GLOBALS

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 

http://php.net/manual/ru/language.namespaces.php
...................Обзор пространств имен .......................
(PHP 5 >= 5.3.0, PHP 7)
Что такое пространства имен? В широком смысле - это один из способов инкапсуляции элементов. Такое абстрактное понятие можно увидеть во многих местах. Например, в любой операционной системе директории служат для группировки связанных файлов и выступают в качестве пространства имен для находящихся в них файлов. В качестве конкретного примера файл foo.txt может находиться сразу в обоих директориях: /home/greg и /home/other, но две копии foo.txt не могут существовать в одной директории. Кроме того, для доступа к foo.txt извне директории /home/greg, мы должны добавить имя директории перед именем файла используя разделитель, чтобы получить /home/greg/foo.txt. Этот же принцип распространяется и на пространства имен в программировании.

В PHP пространства имен используются для решения двух проблем, с которыми сталкиваются авторы библиотек и приложений при создании повторно используемых элементов кода, таких как классы и функции:

Конфликт имен между вашим кодом и внутренними классами/функциями/константами PHP или сторонними.
Возможность создавать псевдонимы (или сокращения) для Ну_Очень_Длинных_Имен, чтобы облегчить первую проблему и улучшить читаемость исходного кода.
Пространства имен PHP предоставляют возможность группировать логически связанные классы, интерфейсы, функции и константы.

namespace my\name; // см. раздел "Определение пространств имен"

class MyClass {}
function myfunction() {}
const MYCONST = 1;

$a = new MyClass;
$c = new \my\name\MyClass; // см. раздел "Глобальная область видимости"

$a = strlen('hi'); // см. раздел "Использование пространств имен: возврат
                   // к глобальной функции/константе"

$d = namespace\MYCONST; // см. раздел "оператор пространства имен и
                        // константа __NAMESPACE__"
$d = __NAMESPACE__ . '\MYCONST';
echo constant($d); // см. раздел "Пространства имен и динамические особенности языка"

Замечание:
Названия пространств имен PHP и php, и составные названия, начинающиеся с этих (такие как PHP\Classes), являются зарезервированными для нужд языка и их не следует использовать в пользовательском коде.

.................Определение пространств имен 

(PHP 5 >= 5.3.0, PHP 7)
Хотя любой исправный PHP-код может находиться внутри пространства имен, только классы (включая абстрактные и трейты), интерфейсы, функции и константы зависят от него.

Пространства имен объявляются с помощью зарезервированного слова namespace. Файл, содержащий пространство имен, должен содержать его объявление в начале перед любым другим кодом, кроме зарезервированного слова declare.

Пример #1 Объявление единого пространства имен

<?php
namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

Только выражение declare может находиться перед объявлением пространства имен для указания кодировки файла. Кроме того, объявлению пространства имен не должен предшествовать не PHP-код, в том числе лишние пробелы:
Пример #2 Объявление простого пространства имен

<html>
<?php
namespace MyProject; // fatal error - объявление пространства имен должно быть первым выражением в скрипте

Кроме того, в отличии от любой другой конструкции PHP, одно и тоже пространство имен можно определять в нескольких файлах, что позволяет распределять находящееся в них по файловой системе.

............Использование пространства имен: основы
PHP 5 >= 5.3.0, PHP 7)
До обсуждения использования пространств имен важно понять как PHP узнает какие элементы из пространства имен запрашиваются в вашем коде. Можно провести аналогию между пространствами имен PHP и файловой системой. Есть три способа обратиться к файлу в файловой системе:

Относительное имя файла, такое как foo.txt, преобразуемое в currentdirectory/foo.txt, где currentdirectory текущая директория, в которой мы находимся. Тогда, если текущая директория /home/foo, то имя преобразуется в /home/foo/foo.txt.

Относительное имя пути, такое как subdirectory/foo.txt, преобразуется в currentdirectory/subdirectory/foo.txt.
Абсолютное имя пути, такое как /main/foo.txt, которое остается таким же: /main/foo.txt.

Тот же принцип применим и к элементам из пространств имен PHP. Для примера, имя класса может быть указано тремя способами:
Неполные имена (имена классов без префикса), такие как $a = new foo(); или foo::staticmethod();. Если текущее пространство имен currentnamespace, то эти имена преобразуются в currentnamespace\foo. Если код находится в глобальном пространстве имен, то имена остаются такими же: foo. Предупреждение: неполные имена для функций и констант будут определяться в глобальном пространстве имен, если они не определены в текущем пространстве имен. Подробнее в Использование пространств имен: доступ к глобальным функциям и классам.
Полные имена (имена классов с префиксами), такие как $a = new subnamespace\foo(); или subnamespace\foo::staticmethod();. Если текущее пространство имен currentnamespace, то эти имена преобразуются в currentnamespace\subnamespace\foo. Если код находится в глобальном пространстве имен, то имена преобразуются в subnamespace\foo.
Абсолютные имена или имена с предшествующим префиксом, обозначающим глобальное пространство. $a = new \currentnamespace\foo(); или \currentnamespace\foo::staticmethod();. Имена всегда определяются также как и записаны: currentnamespace\foo.

Ниже приведен пример трех вариантов синтаксиса в реальном коде:

file1.php

<?php
namespace Foo\Bar\subnamespace;

const FOO = 1;
function foo() {}
class foo
{
    static function staticmethod() {}
}

file2.php

<?php
namespace Foo\Bar;
include 'file1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function staticmethod() {}
}

/* Неполные имена */
foo(); // определяется как функция Foo\Bar\foo
foo::staticmethod(); // определяется как класс Foo\Bar\foo с методом staticmethod
echo FOO; // определяется как константа Foo\Bar\FOO

/* Полные имена */
subnamespace\foo(); // определяется как функция Foo\Bar\subnamespace\foo
subnamespace\foo::staticmethod(); // определяется как класс Foo\Bar\subnamespace\foo
                                  // c методом staticmethod
echo subnamespace\FOO; // определяется как константа Foo\Bar\subnamespace\FOO
                                  
/* Абсолютные имена */
\Foo\Bar\foo(); // определяется как функция Foo\Bar\foo
\Foo\Bar\foo::staticmethod(); // определяется как класс Foo\Bar\foo с методом staticmethod
echo \Foo\Bar\FOO; // определяется как константа Foo\Bar\FOO

Обратите внимание, что для доступа к любым глобальным классам, функциям или константам, может использоваться абсолютное имя, такое как \strlen(), или \Exception, или \INI_ALL.

Пример #1 Доступ к глобальным классам, функциям и константам из пространства имен

<?php
namespace Foo;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('hi'); // вызывает глобальную функцию strlen
$b = \INI_ALL; // получает доступ к глобальной константе INI_ALL
$c = new \Exception('error'); // Создает экземпляр глобального класса Exception

....
Все версии PHP, поддерживающие пространства имен, поддерживают три вида создания псевдонима имени или импорта: создание псевдонима для имени класса, создание псевдонима для имени интерфейса и для имени пространства имен. PHP 5.6+ также поддерживает импорт функций и имен констант.
В PHP создание псевдонима имени выполняется с помощью оператора use. 
<?php
namespace foo;
use My\Full\Classname as Another;

// это тоже самое, что и использование My\Full\NSname как NSname
use My\Full\NSname;

// импортирование глобального класса
use ArrayObject;

// импортирование функции (PHP 5.6+)
use function My\Full\functionName;

// псевдоним функции (PHP 5.6+)
use function My\Full\functionName as func;

// импортирование константы (PHP 5.6+)
use const My\Full\CONSTANT;

$obj = new namespace\Another; // создает экземпляр класса foo\Another
$obj = new Another; // создает объект класса My\Full\Classname
NSname\subns\func(); // вызывает функцию My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // создает объект класса ArrayObject
// без выражения "use ArrayObject" мы создадим объект класса foo\ArrayObject
func(); // вызывает функцию My\Full\functionName
echo CONSTANT; // выводит содержимое константы My\Full\CONSTANT

Обратите внимание, что для имен в пространстве имен (абсолютные имена, содержащие разделитель пространств имен, такие как Foo\Bar, в отличие от глобальных имен, которые его не содержат, такие как FooBar) нет необходимости в начальном обратном слеше (\) и его присутствие там не рекомендуется, так как импортируемые имена должны быть абсолютными и не обрабатываются относительно текущего пространства имен.
PHP дополнительно поддерживает удобное сокращение для задания нескольких операторов use в одной и той же строке

Пример #2 импорт/создание псевдонима имени с помощью оператора use, комбинирование нескольких операторов use

<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // создает объект класса My\Full\Classname
NSname\subns\func(); // вызывает функцию My\Full\NSname\subns\func
?>
Импорт выполняется во время компиляции, и не влияет на имена динамических классов, функций или констант.

Пример #3 Импорт и динамические имена

<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // создает объект класса My\Full\Classname
$a = 'Another';
$obj = new $a;      // создает объект класса Another
?>
В дополнение, импорт распространяется только на неполные и полные имена. Абсолютные имена не затрагиваются операцией импорта.

Пример #4 Импортирование и абсолютные имена

<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // создает объект класса My\Full\Classname
$obj = new \Another; // создает объект класса Another
$obj = new Another\thing; // создает объект класса My\Full\Classname\thing
$obj = new \Another\thing; // создает объект класса Another\thing
?>
Scoping rules for importing 

Ключевое слово use должно быть указано в самом начале файла (в глобальной области) или внутри объявления пространства имен. Это необходимо потому, что импорт выполняется во время компиляции, а не во время исполнения, поэтому оно не может быть заключено в блок. Следующий пример показывает недопустимое применение ключевого слова use:

Пример #5 Недопустимое правило импорта

<?php
namespace Languages;

class Greenlandic
{
    use Languages\Danish;

    ...
}

Замечание:
Правила импорта задаются на каждый файл отдельно. Это означает, что присоединяемые файлы НЕ будут наследовать правила импорта из родительского файла.

............................................
From PHP7 onwards, a single use statement can be used to import Classes, functions and constants from same namespace instead of multiple use statements.

Example
<?php
   // Before PHP 7
   use com\tutorialspoint\ClassA;
   use com\tutorialspoint\ClassB;
   use com\tutorialspoint\ClassC as C;

   use function com\tutorialspoint\fn_a;
   use function com\tutorialspoint\fn_b;
   use function com\tutorialspoint\fn_c;

   use const com\tutorialspoint\ConstA;
   use const com\tutorialspoint\ConstB;
   use const com\tutorialspoint\ConstC;

   // PHP 7+ code
   use com\tutorialspoint\{ClassA, ClassB, ClassC as C};
   use function com\tutorialspoint\{fn_a, fn_b, fn_c};
   use const com\tutorialspoint\{ConstA, ConstB, ConstC};


.......................................................................

 Так для чего же тогда нужны пространства? Прежде всего, для уверенности в том, что когда вы подключаете файл, с каким-нибудь фреймворком или библиотекой, ваши классы не переопределят классы фреймворка или наоборот.

Для того, чтобы использовать классы определенные в своем пространстве имен, необходимо в нужном месте(я как правило предпочитаю делать это в начале файла) импортировать определенное вами пространство в глобальное для этого используется ключевое слово
use

Внимание: по каким-то своим основаниям php не допускает использование ключевого слова use в блоках условий и циклах


возьмем пример с картинок и воплотим его в коде:
Внимание: ключевое слово namespase должно быть расположено в самом начале файла сразу после <? php
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Парсинг – это линейное сопоставление последовательности слов с правилами языка

Сериализация (в программировании) — процесс перевода какой-либо структуры данных в последовательность битов. Обратной к операции сериализации является операция десериализации (структуризации) — восстановление начального состояния структуры данных из битовой последовательности.
Сериализация используется для передачи объектов по сети и для сохранения их в файлы. 

Хеширование или хэширование (англ. hashing) — преобразование массива входных данных произвольной длины в (выходную) битовую строку фиксированной длины, выполняемое определённым алгоритмом. Функция, реализующая алгоритм и выполняющая преобразование, называется «хеш-функцией» или «функцией свёртки». Исходные данные называются входным массивом, «ключом» или «сообщением». Результат преобразования (выходные данные) называется «хешем», «хеш-кодом», «хеш-суммой», «сводкой сообщения».

Лока́ль (англ. locale, /lɔ.kal/ или /ləuˈkɑ:l/) — набор параметров, определяющий региональные настройки пользовательского интерфейса, такие как язык, страна, часовой пояс, набор символов и т. п.

Управляющие символы ANSI (англ. ANSI escape code) — символы, встраиваемые в текст, для управления форматом, цветом и другими опциями вывода в текстовом терминале.

Кэш или кеш (англ. cache, от фр. cacher — «прятать»; произносится [kæʃ] — «кэш») — промежуточный буфер с быстрым доступом, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. Доступ к данным в кэше осуществляется быстрее, чем выборка исходных данных из более медленной памяти или удаленного источника, однако её объём существенно ограничен по сравнению с хранилищем исходных данных.
Кэш — это память с большей скоростью доступа, предназначенная для ускорения обращения к данным, содержащимся постоянно в памяти с меньшей скоростью доступа (далее «основная память»). Кэширование применяется ЦПУ, жёсткими дисками, браузерами, веб-серверами, службами DNS и WINS.
Кэш состоит из набора записей. Каждая запись ассоциирована с элементом данных или блоком данных (небольшой части данных), которая является копией элемента данных в основной памяти. Каждая запись имеет идентификатор, часто называемый тегом, определяющий соответствие между элементами данных в кэше и их копиями в основной памяти.
Когда клиент кэша (ЦПУ, веб-браузер, операционная система) обращается к данным, прежде всего исследуется кэш. Если в кэше найдена запись с идентификатором, совпадающим с идентификатором затребованного элемента данных, то используются элементы данных в кэше. Такой случай называется попаданием кэша. Если в кэше не найдена запись, содержащая затребованный элемент данных, то он читается из основной памяти в кэш, и становится доступным для последующих обращений. 
______________________________________________________________________________________
Основная память                                               Память кэша
_______________________________________________________________________________________
Индекс | Данные                                               Индекс | Тег  | Данные
_______________________________________________________________________________________
  0       xyz                                                   0     2      abc
  1       pdq                                                   1     0      xyz
  2       abc
  3       rgf

_______________________________________________________________________________________
Отображение кэша памяти ЦПУ в основной памяти.


Коллекция в программировании — программный объект, содержащий в себе, тем или иным образом, набор значений одного или различных типов, и позволяющий обращаться к этим значениям. Коллекция позволяет записывать в себя значения и извлекать их. Назначение коллекции — служить хранилищем объектов и обеспечивать доступ к ним.


Число пи — это соотношение длины окружности к диаметру, одинаковое для всех окружностей.
Это фундаментальная пропорция, свойственная всем окружностям, а следовательно, она участвует в вычислении длины окружности, площади, объема и площади поверхности для кругов, сфер, цилиндров и т.д. Пи показывает, что все окружности связаны, не говоря уже о тригонометрических функциях, выводимых из окружностей (синус, косинус, тангенс).    3,1415 ...

Число е (экспонента) является базовым соотношением роста для всех непрерывно растущих процессов.
Так что число е – это не случайное, взятое наугад число. Число е воплощает в себе идею, что все непрерывно растущие системы являются масштабированными версиями одного и того же показателя.
Число е (2.718) — это максимально возможный результат при распределении 100% роста в течение одного периода времени.
Число е — это нечто вроде предела скорости (как "число с" — скорость света). Эта константа показывает, как быстро можно вырасти, используя непрерывный процесс. Вы можете не всегда достигать предела скорости, но это удобная точка сравнения: вы можете описать любой коэффициент роста с помощью этой универсальной константы.
число е объединяет прирост и время 

          прирост  время      прирост × время
рост = ( e        )       = e
..............
Примеры:

3.45E4 (3.45 умножается на 10000. Кострукция E4 означает 10 в степени 4, т.е. 10000) = 3450

8.33E-4 означает 8.33/10000 или 0.000833

d.dddE+n - означ. перемещение десятичной точки на n позиций вправо.
d.dddE-n - означ. перемещение десятичной точки на n позиций влево.

9.11e-31
...................
Лексемами наз. неделимые элементы в строке кода.  
................................
Основной единицей в памяти компьютера является бит. Его можно представить как электрон­
ный переключатель, который может быть установлен в два положения: "включен" и "выключен ".
Положение "выключен" равносильно значению О, а положение "включен" - значению 1.
Порция памяти , состоящая из 8 битов, может представпять одну из 256 различных комбинаций. Число
256 получено исходя из того, что каждый бит может представпять ноль или единицу, что в конеч­
ном итоге дает общую сумму комбинаций для 8 бит: 2 х 2 х 2 х 2 х 2 х 2 х 2 х 2, или 256. 
Таким образом, 8-битная структура может представить число от О до 255, или число от -128 до 1 27.
Каждый дополнительный бит удваивает количество комбинаций. Это означает, что вы можете ис­
пользовать 16-битную порцию памяти для представления числа от О до 65 535 и 32-битную пор­
цию памяти для представления числа от О до 4 294 672 295.  
 1 байт обычно означает 8-битную порцию памяти
.......................
 В языке С++, как и в С, целые числа можно записывать
в трех различных системах счисления: с основанием 10 (наиболее распространенная
форма), с основанием 8 (старая запись в системах семейства Unix) и с основанием 16
(излюбленная форма компьютерных хакеров). Описание этих систем можно найти
в приложении А, а сейчас мы остановимся на рассмотрении представлений в С++.
В языке С++ для обозначения основания постоянного числа используется первая
или две первые цифры. Если первая цифра находится в диапазоне 1-9, то это число
десятичное (с основанием 10); поэтому основанием числа 93 является 10. Если пер­
вой цифрой является ноль, а вторая цифра находится в диапазоне 1-7, то это число
восьмеричное (основание 8); таким образом, 042 - это восьмеричное значение, соот­
ветствующее десятичному числу 32. Если первыми двумя символами являются Ох или
ОХ, то это шестнадцатеричное значение (основание 16); поэтому Ох42 - это шест­
надцатеричное значение, соответствующее десятичному числу 66. В представлении
десятичных значений символы a-f и A-F представляют шестнадцатеричные цифры,
соответствующие значениям 10-15. OxF - это 15, а ОхА5 - это 165 (10 раз по шестнад­
цать плюс 5).   [Прата с.97]

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

Возникновение выражения симлинк происходит из двух слов — Symbolic link, что в переводе с английского означает символическая ссылка. 
Симлинк это специальный файл в файловой системе, для которого не формируются никакие данные, за исключением одной текстовой строки с указателем. Это строка содержит информацию о пути к файлу, который должен быть открыт при попытке обращения к симлинку.
Симлинк может ссылаться на любой объект, это может быть файл, папка, не существующий файл, и т.д. Кстати в случае несуществующего файла, ссылки такого рода принято называть «висячими», или «битыми».
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Callback (англ. call — вызов, англ. back — обратный) или фу́нкция обра́тного вы́зова в программировании — передача исполняемого кода в качестве одного из параметров другого кода.

Callbacks / Callables           // http://php.net/manual/ru/language.types.callable.php

Callbacks can be denoted by callable type hint as of PHP 5.4. This documentation used callback type information for the same purpose.

Some functions like call_user_func() or usort() accept user-defined callback functions as a parameter. Callback functions can not only be simple functions, but also object methods, including static class methods.
A PHP function is passed by its name as a string. //TODO
Any built-in or user-defined function can be used, except language constructs such as: array(), echo, empty(), eval(), exit(), isset(), list(), print or unset().
A method of an instantiated object is passed as an array containing an object at index 0 and the method name at index 1. Accessing protected and private methods from within a class is allowed.

Static class methods can also be passed without instantiating an object of that class by passing the class name instead of an object at index 0. As of PHP 5.2.3, it is also possible to pass 'ClassName::methodName'.

Apart from common user-defined function, anonymous functions can also be passed to a callback parameter.
Пример #1 Callback function examples

<?php

// An example callback function
function my_callback_function() {
    echo 'hello world!';
}

// An example callback method
class MyClass {
    static function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// Type 1: Simple callback
call_user_func('my_callback_function');

// Type 2: Static class method call
call_user_func(array('MyClass', 'myCallbackMethod'));

// Type 3: Object method call
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));

// Type 4: Static class method call (As of PHP 5.2.3)
call_user_func('MyClass::myCallbackMethod');

// Type 5: Relative static class method call (As of PHP 5.3.0)
class A {
    public static function who() {
        echo "A\n";
    }
}

class B extends A {
    public static function who() {
        echo "B\n";
    }
}

call_user_func(array('B', 'parent::who')); // A

// Type 6: Objects implementing __invoke can be used as callables (since PHP 5.3)
class C {
    public function __invoke($name) {    //
        echo 'Hello ', $name, "\n";
    }
}
//Функторы в C++ являются сокращением от "функциональные объекты".  Объект, который действует как функция.
$c = new C();
call_user_func($c, 'PHP!');

Пример #2 Callback example using a Closure

<?php
// Our closure
$double = function($a) {
    return $a * 2;
};

// This is our range of numbers
$numbers = range(1, 5);

// Use the closure as a callback here to
// double the size of each element in our
// range
$new_numbers = array_map($double, $numbers);

print implode(' ', $new_numbers);


Результат выполнения данного примера:

2 4 6 8 10

Замечание: In PHP 4, it was necessary to use a reference to create a callback that points to the actual object, and not a copy of it. For more details, see References Explained.
Замечание:
Callback-функции, зарегистрированные такими функциями как call_user_func() и call_user_func_array(), не будут вызваны при наличии не пойманного исключения, брошенного в предыдущей callback-функции.
//////////////////////////////////////////////////////////////

Псевдо-типы и переменные, используемые в этой документации  // http://php.net/manual/ru/language.pseudo-types.php#language.types.callback

	mixed 

mixed говорит о том, что параметр может принимать много (но необязательно все) типов.

Например, функция gettype() принимает все типы PHP, тогда как str_replace() принимает только типы string и array.

	number 

number говорит о том, что параметр может быть либо integer, либо float.

	callback 

Псевдо-тип callback использовался в этой документации до того, как был введен тип callable в PHP 5.4. Он означает в точности то же самое.

	array|object 

array|object указывает, что параметр может быть как массивом array так и объектом object.

	void 

void в качестве типа результата означает, что возвращенное значение бесполезно. void в списке параметров означает, что функция не принимает параметров.

	... 

$... в прототипах функции означает and so on (и так далее). Это имя переменной используется когда функция может принимать бесконечное количество параметров.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PHP errors
<?php
	// Turn off all error reporting
	error_reporting(0);

	// Report simple running errors
	error_reporting(E_ERROR | E_WARNING | E_PARSE);

	// Reporting E_NOTICE can be good too (to report uninitialized
	// variables or catch variable name misspellings ...)
	error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);

	// Report all errors except E_NOTICE
	error_reporting(E_ALL & ~E_NOTICE);  // TODO

	// Report all PHP errors (see changelog)
	error_reporting(E_ALL);

	// Report all PHP errors
	error_reporting(-1);

	// Same as error_reporting(E_ALL);
	ini_set('error_reporting', E_ALL);
..........Настройка во время выполнения                //  http://php.net/manual/ru/errorfunc.configuration.php
http://php.net/manual/ru/errorfunc.configuration.php#ini.track-errors
error_reporting integer

Задает уровень протоколирования ошибки. Параметр может быть либо числом, представляющим битовое поле, либо именованной константой. Соответствующие уровни и константы приведены в разделе Предопределенные константы, а также в php.ini. Для установки настройки во время выполнения используйте функцию error_reporting(). См. также описание директивы display_errors.

В PHP 5.3 и новее later, значение по умолчанию равно E_ALL & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED. При этой настройке не отображаются уровни ошибок E_NOTICE, E_STRICT и E_DEPRECATED. Можно отображать их при разработке. До версии PHP 5.3.0, значением по умолчанию было E_ALL & ~E_NOTICE & ~E_STRICT. В PHP 4 значением по умолчанию было E_ALL & ~E_NOTICE.
  ...
  ...
  ...
  ...
display_errors string
Эта настройка определяет, требуется ли выводить ошибки на экран вместе с остальным выводом, либо ошибки должны быть скрыты от пользователя.

Значение "stderr" посылает ошибки в поток stderr вместо stdout. Значение доступно в версии PHP 5.2.4. В ранних версиях эта директива имела тип boolean.

Замечание:
Этот функционал предназначен только для разработки и не должен использоваться в готовых производственных системах (например, системах, имеющих доступ в интернет).
Замечание:
Несмотря на то, что display_errors может быть установлена во время выполнения (функцией ini_set()), это ни на что не повлияет, если в скрипте есть фатальные ошибки. Это обусловлено тем, что ожидаемые действия программы во время выполнения не получат управления (не будут выполняться).


(PHP 4, PHP 5, PHP 7)              // http://php.net/manual/ru/function.ini-set.php
ini_set — Установка значения настройки конфигурации      //TODO


..............
Если вы переведете error_reporting в режим отображения ошибок уровня E_NOTICE (например, такой как E_ALL), вы сразу увидите эти ошибки. По умолчанию error_reporting установлена их не отображать.
Как указано в разделе синтаксис, внутри квадратных скобок ('[' и ']') должно быть выражение. Это означает, что можно писать вот так:

<?php
echo $arr[somefunc($bar)];
?>
Это пример использования возвращаемого функцией значения в качестве индекса массива. PHP известны также и константы:

<?php
$error_descriptions[E_ERROR]   = "Произошла фатальная ошибка";
$error_descriptions[E_WARNING] = "PHP сообщает о предупреждении";
$error_descriptions[E_NOTICE]  = "Это лишь неофициальное замечание";
?>
Обратите внимание, что E_ERROR - это такой же верный идентификатор, как и bar в первом примере. Но последний пример по сути эквивалентен такой записи:

<?php
$error_descriptions[1] = "Произошла фатальная ошибка";
$error_descriptions[2] = "PHP сообщает о предупреждении";
$error_descriptions[8] = "Это лишь неофициальное замечание";

поскольку E_ERROR соответствует 1, и т.д.

//////////////////////////////////////
/////////////////////////////////////

Обработка и протоколирование ошибок           // http://php.net/manual/ru/book.errorfunc.php

Перечисленные ниже константы всегда доступны как часть ядра PHP.

Замечание: Данные имена констант можно использовать в файле php.ini но не вне PHP, как например в файле httpd.conf, где вместо них необходимо использовать значения их битовых масок.

Значение	 Константа	                                                            Описание	                                                     Примечание

1	   E_ERROR (integer)	              Фатальные ошибки времени выполнения. Это неустранимые средствами самого скрипта ошибки, 
                                              такие как ошибка распределения памяти и т.п. Выполнение скрипта в таком случае прекращается.
	 
2	   E_WARNING (integer)	              Предупреждения времени выполнения (не фатальные ошибки). 
                                              Выполнение скрипта в таком случае не прекращается.
	 
4	   E_PARSE (integer)	              Ошибки на этапе компиляции. Должны генерироваться только парсером.
	 
8	   E_NOTICE (integer)	              Уведомления времени выполнения. Указывают на то, что во время выполнения скрипта произошло 
                                              что-то, что может указывать на ошибку, хотя это может происходить и при обычном выполнении программы.
	 
16	   E_CORE_ERROR (integer)	      Фатальные ошибки, которые происходят во время запуска РНР. Такие ошибки схожи с E_ERROR, 
                                              за исключением того, что они генерируются ядром PHP.
	 
32	   E_CORE_WARNING (integer)	      Предупреждения (не фатальные ошибки), которые происходят во время начального запуска РНР. 
                                              Такие предупреждения схожи с E_WARNING, за исключением того, что они генерируются ядром PHP.
	 
64	   E_COMPILE_ERROR (integer)	      Фатальные ошибки на этапе компиляции. Такие ошибки схожи с E_ERROR, за исключением того, 
                                              что они генерируются скриптовым движком Zend.	
 
128	   E_COMPILE_WARNING (integer)	      Предупреждения на этапе компиляции (не фатальные ошибки). Такие предупреждения схожи с E_WARNING, 
                                              за исключением того, что они генерируются скриптовым движком Zend.
	 
256	   E_USER_ERROR (integer)	      Сообщения об ошибках сгенерированные пользователем. Такие ошибки схожи с E_ERROR, за исключением того, 
                                              что они генерируются в коде скрипта средствами функции PHP trigger_error().
	 
512	   E_USER_WARNING (integer)	      Предупреждения сгенерированные пользователем. Такие предупреждения схожи с E_WARNING, за исключением того, 
                                              что они генерируются в коде скрипта средствами функции PHP trigger_error().
	 
1024	   E_USER_NOTICE (integer)	      Уведомления сгенерированные пользователем. Такие уведомления схожи с E_NOTICE, за исключением того, 
                                              что они генерируются в коде скрипта, средствами функции PHP trigger_error().	
 
2048	   E_STRICT (integer)	              Включаются для того, чтобы PHP предлагал изменения в коде, которые обеспечат лучшее взаимодействие 
                                              и совместимость кода.	                                                                                     Начиная с PHP 5, но
                                                                                                                                                             не включены в E_ALL
                                                                                                                                                             вплоть до PHP 5.4.0

4096	   E_RECOVERABLE_ERROR (integer)      Фатальные ошибки с возможностью обработки. Такие ошибки указывают, что, вероятно, возникла опасная 
                                              ситуация, но при этом, скриптовый движок остается в стабильном состоянии. Если такая ошибка не 
                                              обрабатывается функцией, определенной пользователем для обработки ошибок (см. set_error_handler()), 
                                              выполнение приложения прерывается, как происходит при ошибках E_ERROR.	                                     Начиная с PHP 5.2.0

8192	   E_DEPRECATED (integer)	      Уведомления времени выполнения об использовании устаревших конструкций. Включаются для того, 
                                              чтобы получать предупреждения о коде, который не будет работать в следующих версиях PHP.	                     Начиная с PHP 5.3.0

16384	   E_USER_DEPRECATED (integer)	      Уведомления времени выполнения об использовании устаревших конструкций, сгенерированные пользователем.
                                              Такие уведомления схожи с E_DEPRECATED за исключением того, что они генерируются в коде скрипта, 
                                              с помощью функции PHP trigger_error().	                                                                     Начиная с PHP 5.3.0

32767	   E_ALL (integer)	              Все поддерживаемые ошибки и предупреждения, за исключением ошибок E_STRICT до PHP 5.4.0.	                     32767 в PHP 5.4.x,
                                                                                                                                                             30719 в PHP 5.3.x,
                                                                                                                                                             6143 в PHP 5.2.x,
                                                                                                                                                             2047 ранее

Представленные выше значения (как числовые, так и символьные) используются для задания битовой маски, определяющей об ошибках какого типа будет даваться отчет. Вы можете использовать побитовые операторы, чтобы совмещать эти значения для указания определенных типов ошибок. Стоит отметить, что в php.ini допустимы только следующие операторы: '|', '~', '!', '^' и '&'.
...............................................http://php.net/manual/ru/errorfunc.examples.php

$errortype = array (
                E_ERROR              => 'Ошибка',
                E_WARNING            => 'Предупреждение',
                E_PARSE              => 'Ошибка разбора исходного кода',
                E_NOTICE             => 'Уведомление',
                E_CORE_ERROR         => 'Ошибка ядра',
                E_CORE_WARNING       => 'Предупреждение ядра',
                E_COMPILE_ERROR      => 'Ошибка на этапе компиляции',
                E_COMPILE_WARNING    => 'Предупреждение на этапе компиляции',
                E_USER_ERROR         => 'Пользовательская ошибка',
                E_USER_WARNING       => 'Пользовательское предупреждение',
                E_USER_NOTICE        => 'Пользовательское уведомление',
                E_STRICT             => 'Уведомление времени выполнения',
                E_RECOVERABLE_ERROR  => 'Отлавливаемая фатальная ошибка'
                );

////////////////////////
//////////////////////////
Функции обработки ошибок   // http://php.net/manual/ru/ref.errorfunc.php

См. также функцию syslog().

debug_backtrace           — Выводит стек вызовов функций в массив
debug_print_backtrace     — Выводит стек вызовов функций
error_clear_last          — Clear the most recent error
error_get_last            — Получение информации о последней произошедшей ошибке
error_log                 — Отправляет сообщение об ошибке заданному обработчику ошибок
error_reporting           — Задает, какие ошибки PHP попадут в отчет
restore_error_handler     — Восстанавливает предыдущий обработчик ошибок
restore_exception_handler — Восстанавливает предыдущий обработчик исключений
set_error_handler         — Задает определенный пользователем обработчик ошибок
set_exception_handler     — Задает пользовательский обработчик исключений
trigger_error             — Вызывает пользовательскую ошибку/предупреждение/уведомление
user_error                — Синоним для trigger_error
//////////////////////////////
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Exceptions
	function inverse($x) {
	    if (!$x) {
		throw new Exception('Division by zero.');
	    }
	    return 1/$x;
	}

	try {
	    echo inverse(5) . "\n";
	} catch (Exception $e) {
	    echo 'Caught exception: ',  $e->getMessage(), "\n";
	} finally {
	    echo "This is always executed.\n";
	}

.................................................................

///////////////////////////////////////////////
Сетевые Функции // http://php.net/manual/ru/ref.network.php

header — Отправка HTTP заголовка
///////////////////////////////////////////////
http://www.w3schools.com/php/php_file.asp

	 readfile() — Выводит файл     // Read File
                  function reads a file and writes it to the output buffer.
	
                       ‎echo readfile("webdictionary.txt");
...............................................................
	 fopen()  // Open File 
	          A better method to open files is with the fopen() function. This function gives you more options than the readfile() function.

	$myfile = fopen("webdictionary.txt", "r") or die("Unable to open file!");
	echo fread($myfile,filesize("webdictionary.txt"));
	fclose($myfile);
....................................................................
	 fread()
	          The fread() function reads from an open file.
The first parameter of fread() contains the name of the file to read from and the second parameter specifies the maximum number of bytes to read.

  	fread($myfile,filesize("webdictionary.txt"));
...................................................................
	 fclose()  // Close File
	          The fclose() function is used to close an open file
Note	It's a good programming practice to close all files after you have finished with them. You don't want an open file running around on your server taking up resources!
The fclose() requires the name of the file (or a variable that holds the filename) we want to close:

	$myfile = fopen("webdictionary.txt", "r");
	// some code to be executed....
	fclose($myfile);
...............................................................................
	 fgets()  // Read Single Line
	          The fgets() function is used to read a single line from a file.

	$myfile = fopen("webdictionary.txt", "r") or die("Unable to open file!");
	echo fgets($myfile);    // AJAX = Asynchronous JavaScript and XML
	fclose($myfile);

....
string fgets ( resource $handle [, int $length ] )
handle // Указатель на файл должен быть корректным и указывать на файл, успешно открытый функциями fopen() или fsockopen() (и все еще не закрытым функцией fclose()).

length // Чтение заканчивается по достижении length - 1 байт, если встретилась новая строка (которая включается в возвращаемый результат) или конец файла (что встретилось первым). Если длина не указана, чтение из потока будет продолжаться до тех пор, пока не достигнет конца строки.

Замечание:
До версии PHP 4.3.0, опущение этого параметра означало, что длина строки будет равна 1024 символам. Если большинство строк в файле больше 8 килобайт, в целях производительности вашего скрипта стоит указать максимальную длину строки.

Возвращает строку размером в length - 1 байт, прочитанную из дескриптора файла, на который указывает параметр handle. Если данных для чтения больше нет, то возвращает FALSE.
В случае возникновения ошибки возвращает FALSE.
....
Построчное чтение файла // http://php.net/manual/ru/function.fgets.php
$handle = @fopen("/tmp/inputfile.txt", "r");
if ($handle) {
    while (($buffer = fgets($handle, 4096)) !== false) {
        echo $buffer;
    }
    if (!feof($handle)) {
        echo "Error: unexpected fgets() fail\n";
    }
    fclose($handle);
}
..............................................................................
	 feof()  // Check End-Of-File 
	         The feof() function checks if the "end-of-file" (EOF) has been reached.The feof() function is useful for looping through data of unknown length

	$myfile = fopen("webdictionary.txt", "r") or die("Unable to open file!");
	// Output one line until end-of-file
	while(!feof($myfile)) {
	  echo fgets($myfile) . "<br>";
	}
	fclose($myfile);

.....................................................................
	 fgetc() //  Read Single Character 
	         The fgetc() function is used to read a single character from a file.
The example below reads the "webdictionary.txt" file character by character, until end-of-file is reached:

	$myfile = fopen("webdictionary.txt", "r") or die("Unable to open file!");
	// Output one character until end-of-file
	while(!feof($myfile)) {
	  echo fgetc($myfile);
	}
	fclose($myfile);
....................................................................
	fwrite() //  Write to File
The fwrite() function is used to write to a file.
The first parameter of fwrite() contains the name of the file to write to and the second parameter is the string to be written.

	$myfile = fopen("newfile.txt", "w") or die("Unable to open file!");
	$txt = "John Doe\n";
	fwrite($myfile, $txt);
	$txt = "Jane Doe\n";
	fwrite($myfile, $txt);
	fclose($myfile);

Notice that we wrote to the file "newfile.txt" twice. Each time we wrote to the file we sent the string $txt that first contained "John Doe" and second contained "Jane Doe". After we finished writing, we closed the file using the fclose() function.

............................................................................
 Overwriting

Now that "newfile.txt" contains some data we can show what happens when we open an existing file for writing. All the existing data will be ERASED and we start with an empty file.
	$myfile = fopen("newfile.txt", "w") or die("Unable to open file!");
	$txt = "Mickey Mouse\n";
	fwrite($myfile, $txt);
	$txt = "Minnie Mouse\n";
	fwrite($myfile, $txt);
	fclose($myfile);

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.
Modes	Description
r	Open a file for read only. File pointer starts at the beginning of the file
w	Open a file for write only. Erases the contents of the file or creates a new file if it doesn''t exist. File pointer starts at the beginning of the file
a	Open a file for write only. The existing data in file is preserved. File pointer starts at the end of the file. Creates a new file if the file doesn''t exist
x	Creates a new file for write only. Returns FALSE and an error if file already exists
r+	Open a file for read/write. File pointer starts at the beginning of the file
w+	Open a file for read/write. Erases the contents of the file or creates a new file if it doesn''t exist. File pointer starts at the beginning of the file
a+	Open a file for read/write. The existing data in file is preserved. File pointer starts at the end of the file. Creates a new file if the file doesn''t exist
x+	Creates a new file for read/write. Returns FALSE and an error if file already exists

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
File Upload   //  http://www.w3schools.com/php/php_file_upload.asp   // TODO
/////////////////////////////////////////////////
http://php.net/manual/ru/ref.filesystem.php

Файловая система

basename — Возвращает последний компонент имени из указанного пути
chgrp — Изменяет группу владельцев файла
chmod — Изменяет режим доступа к файлу
chown — Изменяет владельца файла
clearstatcache — Очищает кэш состояния файлов
copy — Копирует файл
delete — См.описание функции unlink или unset
dirname — Возвращает имя родительского каталога из указанного пути
disk_free_space — Возвращает размер доступного пространства в каталоге или в файловой системе
disk_total_space — Возвращает общий размер каталога или раздела файловой системы
diskfreespace — Псевдоним disk_free_space
fclose — Закрывает открытый дескриптор файла
feof — Проверяет, достигнут ли конец файла
fflush — Сбрасывает буфер вывода в файл
fgetc — Считывает символ из файла
fgetcsv — Читает строку из файла и производит разбор данных CSV
fgets — Читает строку из файла
fgetss — Прочитать строку из файла и отбросить HTML-теги
file_exists — Проверяет наличие указанного файла или каталога
file_get_contents — Читает содержимое файла в строку
file_put_contents — Пишет строку в файл
file — Читает содержимое файла и помещает его в массив
fileatime — Возвращает время последнего доступа к файлу
filectime — Возвращает время изменения индексного дескриптора файла
filegroup — Получает идентификатор группы файла
fileinode — Возвращает индексный дескриптор файла
filemtime — Возвращает время последнего изменения файла
fileowner — Возвращает идентификатор владельца файла
fileperms — Возвращает информацию о правах на файл
filesize — Возвращает размер файла
filetype — Возвращает тип файла
flock — Портируемая консультативная блокировка файлов
fnmatch — Проверяет совпадение имени файла с шаблоном
fopen — Открывает файл или URL
fpassthru — Выводит все оставшиеся данные из файлового указателя
fputcsv — Форматирует строку в виде CSV и записывает её в файловый указатель
fputs — Псевдоним fwrite
fread — Бинарно-безопасное чтение файла
fscanf — Обрабатывает данные из файла в соответствии с форматом
fseek — Устанавливает смещение в файловом указателе
fstat — Получает информацию о файле используя открытый файловый указатель
ftell — Сообщает текущую позицию чтения/записи файла
ftruncate — Урезает файл до указанной длинны
fwrite — Бинарно-безопасная запись в файл
glob — Находит файловые пути, совпадающие с шаблоном
is_dir — Определяет, является ли имя файла директорией
is_executable — Определяет, является ли файл исполняемым
is_file — Определяет, является ли файл обычным файлом
is_link — Определяет, является ли файл символической ссылкой
is_readable — Определяет существование файла и доступен ли он для чтения
is_uploaded_file — Определяет, был ли файл загружен при помощи HTTP POST
is_writable — Определяет, доступен ли файл для записи
is_writeable — Псевдоним is_writable
lchgrp — Изменяет группу, которой принадлежит символическая ссылка
lchown — Изменяет владельца символической ссылки
link — Создаёт жёсткую ссылку
linkinfo — Возвращает информацию о ссылке
lstat — Возвращает информацию о файле или символической ссылке
mkdir — Создаёт директорию
move_uploaded_file — Перемещает загруженный файл в новое место
parse_ini_file — Обрабатывает конфигурационный файл
parse_ini_string — Разбирает строку конфигурации
pathinfo — Возвращает информацию о пути к файлу
pclose — Закрывает файловый указатель процесса
popen — Открывает файловый указатель процесса
readfile — Выводит файл
readlink — Возвращает файл, на который указывает символическая ссылка
realpath_cache_get — Получает записи из кэша реального пути
realpath_cache_size — Получает размер кэша реального пути
realpath — Возвращает канонизированный абсолютный путь к файлу
rename — Переименовывает файл или директорию
rewind — Сбрасывает курсор у файлового указателя
rmdir — Удаляет директорию
set_file_buffer — Псевдоним stream_set_write_buffer
stat — Возвращает информацию о файле
symlink — Создаёт символическую ссылку
tempnam — Создаёт файл с уникальным именем
tmpfile — Создаёт временный файл
touch — Устанавливает время доступа и модификации файла
umask — Изменяет текущую umask
unlink — Удаляет файл
.........
echo filetype('/etc/passwd');  // file
echo filetype('/etc/');        // dir
............
$structure = '/home/valentin/Документы/КНИГИ/ИЗУЧЕНИЕ/for testing/dir/';

// Для создания вложенной структуры необходимо указать параметр
// $recursive в mkdir() .

if (!mkdir($structure, 0777, true)) {
    die('Не удалось создать директории...');
}

,,,,,,,,,,,,,,,,,,,,,,,,


Текстовый формат CSV (от англ. Comma-Separated Values — значения, разделённые запятыми) — формат, предназначенный для представления табличных данных. Каждая строка файла — это одна строка таблицы. Значения отдельных колонок разделяются следующими символами: запятой ( , ), точкой с запятой (;), двоеточием(:).
/////////////////////////////////
Функции для работы с каталогами     // http://php.net/manual/ru/ref.dir.php

За описанием сопутствующих функций, таких как dirname(), is_dir(), mkdir() и rmdir(), обратитесь к главе Файловая система.
dirname — Возвращает имя родительского каталога из указанного пути

	chdir     — Изменяет каталог
	chroot    — Изменяет корневой каталог
	closedir  — Освобождает дескриптор каталога
	dir       — Возвращает экземпляр класса Directory
	getcwd    — Получает имя текущего рабочего каталога
	opendir   — Открывает дескриптор каталога
	readdir   — Получает элемент каталога по его дескриптору
	rewinddir — Сбросить дескриптор каталога
	scandir   — Получает список файлов и каталогов, расположенных по указанному пути
..........
array scandir ( string $directory [, int $sorting_order = SCANDIR_SORT_ASCENDING [, resource $context ]] )

$dir    = '/home/valentin/Документы/КНИГИ/ИЗУЧЕНИЕ/for testing/';
$files1 = scandir($dir);
$files2 = scandir($dir, 1);

print_r($files1);
print_r($files2);
/*
Array
(
    [0] => $.html
    [1] => .
    [2] => ..
    [3] => BOM.html
    [4] => DOM_vs_jQ
    [5] => Form.html
    [6] => dir
    [7] => dommove.gif
    [8] => domstr.gif
    [9] => file_test.html
    [10] => flex.html
    [11] => index.html
    [12] => jQ.html
    [13] => jquery-3.0.0.min.js
    [14] => position.html
    [15] => q.html
    [16] => style.css
    [17] => test.html
    [18] => testDOM.html
    [19] => windowObjects.png
    [20] => Дерево DOM.html
    [21] => документ_test.txt
)
Array
(
    [0] => документ_test.txt
    [1] => Дерево DOM.html
    [2] => windowObjects.png
    [3] => testDOM.html
    [4] => test.html
    [5] => style.css
    [6] => q.html
    [7] => position.html
    [8] => jquery-3.0.0.min.js
    [9] => jQ.html
    [10] => index.html
    [11] => flex.html
    [12] => file_test.html
    [13] => domstr.gif
    [14] => dommove.gif
    [15] => dir
    [16] => Form.html
    [17] => DOM_vs_jQ
    [18] => BOM.html
    [19] => ..
    [20] => .
    [21] => $.html
)

*/

.................
$d = dir("/home/valentin/Документы/КНИГИ/ИЗУЧЕНИЕ/for testing/dir");
echo "Дескриптор: " . $d->handle . "\n";
echo "Путь: " . $d->path . "\n";
while (false !== ($entry = $d->read())) {
   echo $entry."\n";
}
$d->close();
/*
Дескриптор: Resource id #5
Путь: /home/valentin/Документы/КНИГИ/ИЗУЧЕНИЕ/for testing/dir
..
.
doc
*/
...........
echo getcwd() . "\n";  //  /home/valentin
....
$dir = "/home/valentin/Документы/КНИГИ/ИЗУЧЕНИЕ/Джейсон Ленгсторф - PHP и jQuery для профессионалов - 2010/";

// Открыть известный каталог и начать считывать его содержимое
if (is_dir($dir)) {
    if ($dh = opendir($dir)) {
        while (($file = readdir($dh)) !== false) {
            echo "файл: $file : тип: " . filetype($dir . $file) . "\n";
        }
        closedir($dh);
    }
}

/*
файл: .. : тип: dir
файл: src : тип: dir
файл: Джейсон Ленгсторф - PHP и jQuery для профессионалов - 2011.djvu : тип: file
файл: Jason Lengstorf - Pro PHP and jQuery - 2010.pdf : тип: file
файл: . : тип: dir
файл: Джейсон Ленгсторф - PHP и jQuery для профессионалов - 2011.bookmarks : тип: file

*/
....если по другому.......................................
$dir = "/home/valentin/Документы/КНИГИ/ИЗУЧЕНИЕ/for testing/";

// Открыть известный каталог и начать считывать его содержимое
if (is_dir($dir)) {
    if ($dh = opendir($dir)) {
        $file = readdir($dh);
            echo "файл: $file : тип: " . filetype($dir . $file) . "\n";
        
        closedir($dh);
    }
}

// файл: $.html : тип: file

..................
if ($handle = opendir('.')) {
    while (false !== ($entry = readdir($handle))) {
        if ($entry != "." && $entry != "..") {
            echo "$entry\n";
        }
    }
    closedir($handle);
}
_______________
При выполнении выше приведенного кода, переменная $entry будет содержать такие включения, как  “.” и “..”. Это две виртуальные директории, которые имеются в каждом каталоге файловой системы. Они представляют текущий каталог и родительский каталог соответственно.
______
opendir
Эта функция открывает указанную директорию и возвращает служебный идентификатор соединения с директорией. Пути к директории следует указывать следующим образом:

 .           Точка означает открытие текущей директории

./files/     Открытие папки files, находящейся в текущей директории

..           Открытие папки на уровень выше текущей


_________________
Дескриптор это то, через что можно обращаться к объекту. Это может быть указатель, ссылка, или само имя объекта.
Дескри́птор (от лат. descriptor — описывающий) — лексическая единица (слово, словосочетание) информационно-поискового языка, служащая для описания основного смыслового содержания документа или формулировки запроса при поиске документа (информации) в информационно-поисковой системе.

/////////////////////////////////////////////////////////
Opera  инспектировать элемент  Network       -   данные о странице GET и POST,session,cookie

Opera    Настройки   Безопасность   Файлы cookie
/////////////////
Переменные извне PHP                        https://secure.php.net/manual/ru/language.variables.external.php

HTML-формы (GET и POST) 

Когда происходит отправка данных формы PHP-скрипту, информация из этой формы автоматически становится доступной ему. Существует несколько способов получения этой информации, например:

Пример #1 Простая HTML-форма

<form action="foo.php" method="post">
    Имя:  <input type="text" name="username" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Отправь меня!" />
</form>
С версии PHP 5.4.0, есть только два способы получить доступ к данным из HTML форм. Доступные сейчас способы приведены ниже:

Пример #2 Доступ к данным из простой HTML POST-формы

<?php
echo $_POST['username'];
echo $_REQUEST['username'];
?>
В старых версиях PHP также существовало несколько других способов. Они приведены ниже. Смотрите также список изменений внизу страницы.

Пример #3 Старые способы получения пользовательских данных

<?php
// ВНИМАНИЕ: эти методы больше НЕ поддерживаются.

// Использование import_request_variables() - эта функция удалена в PHP 5.4.0
   import_request_variables('p', 'p_');
   echo $p_username;

// Эти длинные предопределенные массивы удалены в PHP 5.4.0
   echo $HTTP_POST_VARS['username'];

// Использование register_globals. Эта функциональность удалена в PHP 5.4.0
   echo $username;

GET-форма используется аналогично, за исключением того, что вместо POST, вам нужно будет использовать соответствующую предопределенную переменную GET. 
GET относится также к QUERY_STRING (информация в URL после '?'). 
Так, например,
//  http://www.example.com/test.php?id=3 содержит GET-данные, доступные как $_GET['id']. 
Смотрите также $_REQUEST.

Замечание:
Точки и пробелы в именах переменных преобразуется в знаки подчеркивания. Например, <input name="a.b" /> станет $_REQUEST["a_b"].
PHP также понимает массивы в контексте переменных формы (смотрите соответствующие ЧАВО). К примеру, вы можете сгруппировать связанные переменные вместе или использовать эту возможность для получения значений списка множественного выбора select. Например, давайте отправим форму самой себе, а после отправки отобразим данные:

Пример #4 Более сложные переменные формы

<?php
if ($_POST) {
    echo '<pre>';
    echo htmlspecialchars(print_r($_POST, true));
    echo '</pre>';
}
?>
<form action="" method="post">
    Имя:  <input type="text" name="personal[name]" /><br />
    Email: <input type="text" name="personal[email]" /><br />
    Пиво: <br />
    <select multiple name="beer[]">
        <option value="warthog">Warthog</option>
        <option value="guinness">Guinness</option>
        <option value="stuttgarter">Stuttgarter Schwabenbräu</option>
    </select><br />
    <input type="submit" value="Отправь меня!" />
</form>

Имена переменных кнопки-изображения 

При отправке формы вместо стандартной кнопки можно использовать изображение с помощью тега такого вида:

<input type="image" src="image.gif" name="sub" />
Когда пользователь щелкнет где-нибудь на изображении, соответствующая форма будет передана на сервер с двумя дополнительными переменными - sub_x и sub_y. Они содержат координаты нажатия пользователя на изображение. Опытные программисты могут заметить, что на самом деле имена переменных, отправленных браузером, содержат точку, а не подчеркивание, но PHP автоматически конвертирует точку в подчеркивание.
////<?php
.....................................
http://site.com/index.php?param1=value1&param2=value2

 Протокол              Адрес ресурса
  http://  site.com     /index.php       ?param1=value1&param2=value2
             Хост                             Параметры
......................................................
//////////////////////////////////////////////////////////////////////////////
Структура HTTP запроса


                                      Метод          Ресурс(URI)                  Версия
Строка запроса(Request Line)          GET          /index.php?param1=value1       HTTP/1.1
___________________________________________________________________________
Заголовки(Message Headers)        Host: site.com
                                  User-Agent: Mozulla/5.0          (браузер пользователя)
                                  ...
___________________________________________________________________________
                                  Пустая строка

___________________________________________________________________________
Тело сообщения(Entity Body)       Данные...

...........................................................

Как пример:

echo '<pre>';
print_r($_SERVER);
echo '<pre>';

Array
(
    [HTTP_HOST] => localhost
    [HTTP_CONNECTION] => keep-alive
    [HTTP_CACHE_CONTROL] => max-age=0
    [HTTP_ACCEPT] => text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*//*;q=0.8
    [HTTP_UPGRADE_INSECURE_REQUESTS] => 1
    [HTTP_USER_AGENT] => Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36 OPR/33.0.1990.115
    [HTTP_ACCEPT_ENCODING] => gzip, deflate, lzma, sdch
    [HTTP_ACCEPT_LANGUAGE] => ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4
    [PATH] => /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    [SERVER_SIGNATURE] => 
Apache/2.4.7 (Ubuntu) Server at localhost Port 80


    [SERVER_SOFTWARE] => Apache/2.4.7 (Ubuntu)
    [SERVER_NAME] => localhost
    [SERVER_ADDR] => ::1
    [SERVER_PORT] => 80
    [REMOTE_ADDR] => ::1
    [DOCUMENT_ROOT] => /var/www/html
    [REQUEST_SCHEME] => http
    [CONTEXT_PREFIX] => 
    [CONTEXT_DOCUMENT_ROOT] => /var/www/html
    [SERVER_ADMIN] => webmaster@localhost
    [SCRIPT_FILENAME] => /var/www/html/get_post/http_post.php
    [REMOTE_PORT] => 59919
    [GATEWAY_INTERFACE] => CGI/1.1
    [SERVER_PROTOCOL] => HTTP/1.1
    [REQUEST_METHOD] => GET
    [QUERY_STRING] => a=12&b=3&c=3&Submit=%D0%9F%D0%BE%D0%B4%D1%82%D0%B2%D0%B5%D1%80%D0%B4%D0%B8%D1%82%D1%8C
    [REQUEST_URI] => /get_post/http_post.php?a=12&b=3&c=3&Submit=%D0%9F%D0%BE%D0%B4%D1%82%D0%B2%D0%B5%D1%80%D0%B4%D0%B8%D1%82%D1%8C
    [SCRIPT_NAME] => /get_post/http_post.php
    [PHP_SELF] => /get_post/http_post.php
    [REQUEST_TIME_FLOAT] => 1467830135.126
    [REQUEST_TIME] => 1467830135
)

echo '<pre>';
print_r($_SERVER['HTTP_USER_AGENT']); // доступ по ключу     // Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/...
echo '<pre>';

phpinfo(); показ. основн.настройки и характер. сервера ...
////////////////////////////////////////////////////////////////////////////////
Ответ сервера

Строка ответа

Протокол      Статус          Поясняющая фраза
HTTP/1.1       200               OK
_________________________________________________________
Заголовки

Server:Apache/...
Date: ...
...
__________________________________________________________
Пустая строка
__________________________________________________________
Тело сообщения   (может быть видео, предложено сохр. на диск, в заголовках будет отобр.формат видео)

<html>
...Текст страницы полностью...
<html>

////////////////////////////////////////////////////////////////////////////////
Статусы ответа сервера

 1хх      Информационные

 2хх      Успех

 3хх      Перенаправление

 4хх      Ошибки клиента
 
 5хх      Ошибки сервера

/////////////////////////////////////////////////////////////////////////////////
................................
Методы GET и POST

   GET /index.php?a=1&b=2&c=4 HTTP/1.1        // строка запроса 
	...Заголовки...                       // заголовок
	...Тело...                            // тело сообщения

Параметры (a=1&b=2&c=4) передаются в строке запроса        // GET                        // http://localhost/get_post/http_get.php?a=12&b=3&c=4&Submit=Искать
Ограничения в длине
....
   POST /index.php HTTP/1.1       // строка запроса 
	...Заголовки...           // заголовок
	a=1&b=2&c=4               // тело сообщения

Параметры (a=1&b=2&c=4) передаются в теле сообщения        // POST                       //                http://localhost/get_post/http_post.php
Нет ограничений
....................................
/////////////////////////////////////////////////////////////
Cookie(Куки) - небольшой фрагмент данных, отправленный веб-сервером(сайтом) и хранимый на компьютере пользователя.Данные cookie хран. в браузере.
Веб-браузер каждый раз при обращении к сайту пересылает этот фрагмент данных в составе HTTP-запроса.
Куки одного сайта не могут быть перемешаны с куки другого сайта.Хранятся в разных папках для разных сайтов.

Применяется для:
аутентификации пользователя
хранения предпочтений и настроек пользователя
ведения статистики о пользователях
отслеживания состояния сеанса доступа пользователя

1й

                              Запрос:Вход на сайт + данные ----------------->

Пользователь                                                                                   Сайт
                              <---------------------------Ответ:ОК + cookie

2й ...и т.д....
                                      
                                  Запрос:Страница + cookie ------->
   Пользователь(cookie)                         
                                   <-----------Ответ:ОК, Страница



/////////////////////////////
HTTP Cookies 

PHP прозрачно поддерживает HTTP cookies как определено в » RFC 6265. 
Cookies - это механизм для хранения данных в удаленном браузере и отслеживания и идентификации таким образом вернувшихся пользователей. Вы можете установить cookies, используя функцию setcookie().
 Cookies являются частью HTTP-заголовка, поэтому функция SetCookie должна вызываться до того, как браузеру будет отправлен какой бы то ни было вывод. Это ограничение аналогично ограничению функции header(). Данные, хранящиеся в cookie, доступны в соответствующих массивах данных cookie, таких как $_COOKIE и $_REQUEST. Подробности и примеры смотрите на странице setcookie() руководства.

Если вы хотите присвоить множество значений одной переменной cookie, вы можете присвоить их как массив. Например:

<?php
  setcookie("MyCookie[foo]", 'Testing 1', time()+3600);
  setcookie("MyCookie[bar]", 'Testing 2', time()+3600);
?>
Это создаст две разные cookie, хотя в вашем скрипте MyCookie будет теперь одним массивом. Если вы хотите установить именно одну cookie со множеством значений, примите во внимание сначала применение к значениям таких функций, как serialize() или explode().

Обратите внимание, что cookie заменит предыдущую cookie с тем же именем в вашем браузере, если только путь или домен не отличаются. Так, для приложения корзины покупок вы, возможно, захотите сохранить счетчик. То есть:

Пример #5 Пример использования setcookie()

<?php
if (isset($_COOKIE['count'])) {
    $count = $_COOKIE['count'] + 1;
} else {
    $count = 1;
}     
setcookie('count', $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
?>
Точки в именах приходящих переменных ¶

Как правило, PHP не меняет передаваемых скрипту имен переменных. Однако следует отметить, что точка не является корректным символом в имени переменной PHP. Поэтому рассмотрим такую запись:

<?php
$varname.ext;  /* неверное имя переменной */

В данном случае интерпретатор видит переменную $varname, после которой идет оператор конкатенации, а затем голая строка (то есть, не заключенная в кавычки строка, не соответствующая ни одному из ключевых или зарезервированных слов) 'ext'. Очевидно, что это не даст ожидаемого результата.
По этой причине важно заметить, что PHP будет автоматически заменять любые точки в именах приходящих переменных на символы подчеркивания.

Определение типов переменных 

Поскольку PHP определяет и конвертирует типы переменных (в большинстве случаев) как надо, не всегда очевидно, какой тип имеет данная переменная в конкретный момент времени. PHP содержит несколько функций, позволяющих определить тип переменной, таких как: gettype(), is_array(), is_float(), is_int(), is_object() и is_string(). Смотрите также раздел Типы.

Список изменений 

Версия	Описание
5.4.0	Register Globals, Magic Quotes и register_long_arrays удалены
5.3.0	Register Globals, Magic Quotes и register_long_arrays стали устаревшими
4.2.0	register_globals по умолчанию стала равна off.
4.1.0	Добавлены Суперглобальные массивы, такие как $_POST и $_GET

/////////////////////////////////
                                   имя переменной   ее значение        текущее время + кол-во секунд (время через которое будут удалены данные )
Создание cookie:         setcookie("name",          "Виктор",          time()+N sec.);
                                  принимает много параметров

 setcookie('name','');  удалить cookie
 setcookie("name", "Виктор",time()-N sec.); удалить cookie
/////////////////////////////////////////////////
Хранение массивов в cookie

$arr = ['name'=>'Иван','surname'=>'Пронин','city'=>'NY'];

$str = serialize($arr); массив в строку                  // var_dump($str);      // string(86) "a:3:{s:4:"name";s:8:"Иван";s:7:"surname";s:12:"Пронин";s:4:"city";s:2:"NY";}"
Можем сохранить в cookie:    setcookie('arr',$str);  
$arr = $_COOKIE['arr'];
..................

$str = $_COOKIE['arr'];
$array = unserialize($str); строку в массив

Использование cookie:
cookie - не большой фрагмент данных
До 4kB (не большой объем данных),браузеры ограничивают размер данных и кол-во хранимых значений,т.е. кол-во переменных которые можно туда записать.
It’s a simple text file which stores maximum 4KB of data.
http://webrewrite.com/create-read-delete-cookie-php/
////////////////////////////////////////////////////
Пример(блог):
  // file aside.php
...
 <p class="titl">Поиск</p>
	 <form action="view_search.php" method="POST" name="form_s">

	 	<p id="srch">Поисковый запрос должен быть не менее 4-х символов</p>

	 	<input name="search"   type="text"   size="25" maxlength="40"> <br>
	 	<input name="submit_s" type="submit" value="Искать">


	 </form>




  // file   view_search.php
<?php
include'blocks/bd.php'; // Соединяемся с базой

// if(isset($_POST['submit_s'])) {
// 	$submit_s = $_POST['submit_s'];
// }
$submit_s = isset($_POST['submit_s']) ? $_POST['submit_s'] : '';
// if(isset($_POST['search'])) {
// 	$search = $_POST['search'];
// }
$search = isset($_POST['search']) ? $_POST['search'] : '';

if(isset($submit_s)) {
	if(empty($search) || (mb_strlen($search,'UTF8')<4)){
		exit("<p>Поисковый запрос не введен , либо он менее 4-х символов.</p>");	
	}
$search = trim($search); // обрезать пробелы
$search = stripslashes($search); // убрать слеш
$search = htmlspecialchars($search);// от взлома
}
else{
	exit("<p>Вы обратились к файлу без необходимых параметров</p>");
}




/////////////////////////////////////////////////////////////////////////////
Пример(Зинченко теория урок_8 HTTP формы):
// file
<?php
print_r($_FILES); 
/*      
 Array 
( 
   [file] => Array 
                 ( [name] => 224H.jpg 
	           [type] => image/jpeg
	           [tmp_name] =>  /tmp/phpHOcLIF                         // путь где сохранен
		   [error] => 0                                          // no err
	           [size] => 1894005 
                 ) 
)

*/
?>
        <form action="index.php" method="get" enctype="multipart/form-data">

                A:<input   type="text"   name="a"> 
		B:<input   type="text"   name="b"> 
		C:<input   type="text"   name="c"> 
                File:<input type="file" name="file">                  // при отправки файла, сервер получает его название(чтобы отпр.сам файл добавл.enctype="multipart/form
                                                                      //   -data", имя исчезнет, а файл попадет в супергл. мас. $_FILES)
	 	<input name="Submit" type="submit" value="Искать">            // name(key)  value(value)

        </form>

Если параметр name не задан, соответствующая строка имя=значение передана не будет.
Все теги , за исключением <select> выглядят одинаково - как один, они генерируют строки вида   имя=значение  , где имя - строка, заданная в атрибуте name, 
а значение - либо текст, введенный пользователем, либо содержимое атрибута value (например, так происходит у независимых и зависимых переключателей)



enctype - если хотим отправить файл на сервер          этот тип  multipart/form-data  работает при методе POST
////посылаем запрос на сервер  GET /index.php?a=1&b=2&c=4 HTTP/1.1        (адрес /index.php - лежит в корне)
// http://localhost/form_php.php?a=1&b=2&c=4&Submit=Искать

// file   index.php
<?php
//   print_r($_GET); //    Array ( [a] => 1 [b] => 2 [c] => 4 [Submit] => Искать )
include_once 'functions.php';   // file  с функцией

	if(isset($_GET['Submit']){
		$a = $_GET['a'];
		$b = $_GET['b'];
		$c = $_GET['c'];
                if(!empty($a) && !empty($b) && !empty($c)){
		        $res = func($a,$b,$c);
		        if($res != false){
		         // code.
		         // code
		        }
                }
                echo"Форма отправлена a = $a, b = $b, c = $c;<br>";
        }

//////////////////////////////////////////////////////////////////////////////////////////////////////
/var/www/html/get_post       

//http_get.php
<?php
print_r($_GET);      // Array ( [a] => dss [b] => 54 [c] => 56 [Submit] => Подтвердить )
?>

<!DOCTYPE html>
<html>
<head>
	<title>form_GET</title>
	<meta charset="UTF-8">
</head>
<body>
<form action="http_get.php" method="GET" >

        A:<input   type="text"   name="a"> <br>
		B:<input   type="text"   name="b"> <br>
		C:<input   type="text"   name="c"> <br>
	 	<input name="Submit" type="submit" value="Подтвердить">

        </form>
</body>
</html>           
// http://localhost/get_post/http_get.php?a=dss&b=54&c=56&Submit=Подтвердить

//http_post.php
<?php
print_r($_POST);  // Array ( [a] => 1223 [b] => 33333 [c] => 777 [Submit] => Подтвердить )
//print_r($_FILES);
/*
echo '<pre>';
print_r($_SERVER);
echo '<pre>';
*/
?>

<!DOCTYPE html>
<html>
<head>
	<title>form_POST</title>
	<meta charset="UTF-8">
</head>
<body>
<form action="http_post.php" method="POST" enctype="multipart/form-data">

        A:<input   type="text"   name="a"> <br>
		B:<input   type="text"   name="b"> <br>
		C:<input   type="text"   name="c"> <br>
	 File:<input type="file" name="file">  <br>
	 	<input name="Submit" type="submit" value="Подтвердить">

        </form>
</body>
</html>


//http://localhost/get_post/http_post.php

<?
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Сессии - позволяют хранить данные о пользователе на сервере(идентификационная инфо.).Специальный файл который хранится во временной папке на сервере.В этом файле могут быть записаны данные связанные с
пользователем.Когда мы используем сессию мы отправляем куки с идентификатором с сессии.

session_start(); // когда начинаем работать с сессиями выз. эту ф-цию
$answer1 = $_POST['answer1'];
$_SESSION['answer1'] = $answer1;
echo session_id();// sess_4sscgdf1vrpfpv9h7umhpjsjv2 (как пример) имя файла(идентификатором с сессии)
echo session_name();// PHPSESSID

Request Cookies					36				
PHPSESSID	4sscgdf1vrpfpv9h7umhpjsjv2

// remove all session variables
session_unset(); 

// destroy the session 
session_destroy(); 

....
apache sessions directory
sys_get_temp_dir()  - return the directory path used for temporary files     //             /tmp
session_save_path() — Get and/or set the current session save path           //             /var/lib/php5
...........................

Сессии являются простым способом хранения информации для отдельных пользователей с уникальным идентификатором сессии. Это может использоваться для сохранения состояния между запросами страниц. Идентификаторы сессий обычно отправляются браузеру через сессионный cookie и используются для получения имеющихся данных сессии. Отсутствие идентификатора сессии или сессионного cookie сообщает PHP о том, что необходимо создать новую сессию и сгенерировать новый идентификатор сессии.

Сессии используют простую технологию. Когда сессия создана, PHP будет либо получать существующую сессию, используя переданный идентификатор (обычно из сессионного cookie) или, если ничего не передавалось, будет создана новая сессия. PHP заполнит суперглобальную переменную $_SESSION сессионной информацией после того, как будет запущена сессия. Когда PHP завершает работу, он автоматически сериализует содержимое суперглобальной переменной $_SESSION и отправит для сохранения, используя сессионный обработчик для записи сессии.

По умолчанию PHP использует внутренний обработчик files для сохранения сессий, который установлен в INI-переменной session.save_handler. Этот обработчик сохраняет данные на сервере в директории, указанной в конфигурационной директиве session.save_path.

Сессии могут запускаться вручную с помощью функции session_start(). Если директива session.auto_start установлена в 1, сессия автоматически запустится, в начале запроса.

Сессия обычно завершает свою работу, когда PHP заканчивает исполнять скрипт, но может быть завершена и вручную с помощью функции session_write_close().

Предостережение
НЕ ОЧИЩАЙТЕ $_SESSION целиком, используя unset($_SESSION), так как это отключит возможность регистрации сессионных переменных через суперглобальную переменную $_SESSION.
Внимание
Вы не можете использовать ссылки в сессионных переменных, так как не существует реального способа восстановления ссылки к другой переменной.
Внимание
register_globals переопределяет переменные в глобальной области видимости, имена которых совпадают с переменными сессии. Подробнее смотрите Использование глобальных переменных (Register Globals).
Замечание:
Сессии, использующие файлы (по умолчанию в PHP), блокируют файл сессии сразу при открытии сессии функцией session_start() или косвенно при указании session.auto_start. После блокировки, ни один другой скрипт не может получить доступ к этому же файлу сессии, пока он не будет закрыт или при завершении скрипта 
или при вызове функции session_write_close().
Скорее всего это станет проблемой для сайтов, которые активно используют AJAX и делают несколько одновременных запросов. Простейшим путем решить эту проблему будет вызов функции session_write_close() сразу же как только все требуемые изменения в сессии будут сделаны, предпочтительно ближе к началу работы скрипта. Также можно использовать другой механизм сессии, который поддерживает конкурентный доступ.
.................................................................................................................
.............................task1.php....................................................................................
<p>Вопрос 1:</p>
<p>2 + 2 = ?</p>

<form action="task2.php" method="post">
	<input type="text" name="answer1" />
	<input type="submit"/>

</form>
............................task2.php..............................
<?php
//print_r($_POST);
session_start(); // когда начинаем работать с сессиями выз. эту ф-цию

$answer1 = $_POST['answer1'];
//echo $answer1;
$_SESSION['answer1'] = $answer1;
?>


<p>Вопрос 2:</p>
<p>3 + 3 = ?</p>

<form action="task3.php" method="post">
	<input type="text" name="answer2" />
	<input type="submit"/>

</form>
........................task3.php.............................
<?php
session_start(); // когда начинаем работать с сессиями выз. эту ф-цию

//print_r($_POST);
$answer2 = $_POST['answer2'];
//echo $answer2;

$_SESSION['answer2'] = $answer2;

?>

<p>Вопрос 3:</p>
<p>4 + 4 = ?</p>

<form action="result.php" method="post">
	<input type="text" name="answer3" />
	<input type="submit"/>

</form>

..........................result.php............................

<?php
//print_r($_POST);
session_start();
$answer1 = $_SESSION['answer1'];
$answer2 = $_SESSION['answer2'];
$answer3 = $_POST['answer3'];

if(($answer1 == 4) && ($answer2 == 6) && ($answer3 == 8)){
    echo 'Ваш результат: +';
} else  {
	echo 'Ваш результат: -';
}
///////////////////////////

From PHP7+, session_start() function accepts an array of options to override the session configuration directives set in php.ini. These options supports session.lazy_write, which is by default on and causes PHP to overwrite any session file if the session data has changed.

Another option added is read_and_close, which indicates that the session data should be read and then the session should immediately be closed unchanged. For example, Set session.cache_limiter to private and set the flag to close the session immediately after reading it, using the following code snippet.

<?php
   session_start([
      'cache_limiter' => 'private',
      'read_and_close' => true,
   ]);


////////////////////////
Описание встроенных директив php.ini       //  http://php.net/manual/ru/ini.core.php#ini.core

(PHP 4 >= 4.3.0, PHP 5, PHP 7)
set_include_path — Устанавливает значение настройки конфигурации include_path

Пример #1 include_path в Unix                   //  http://php.net/manual/ru/ini.core.php#ini.include-path

include_path=".:/php/includes"
///////////////////
http://php.net/manual/ru/reserved.constants.php

Предопределенные константы ¶

Объявленные в ядре константы ¶

Нижеописанные константы объявляются ядром PHP и охватывают PHP, Zend engine и SAPI-модули.

PHP_VERSION (string)
Текущая версия PHP в виде строки в формате "major.minor.release[extra]".
PHP_MAJOR_VERSION (integer)
Текущая "основная" (major) версия PHP в виде целого числа (например, int(5) для версии "5.2.7-extra"). Доступна начиная с версии PHP 5.2.7.
PHP_MINOR_VERSION (integer)
Текущая "промежуточная" версия PHP в виде целого числа (например, int(2) для версии "5.2.7-extra"). Доступна начиная с версии PHP 5.2.7.
PHP_RELEASE_VERSION (integer)
Текущая "релиз"-версия (release) PHP в виде целого числа (например, int(7) для версии "5.2.7-extra"). Доступна начиная с версии PHP 5.2.7.
PHP_VERSION_ID (integer)
Текущая версия PHP в виде целого числа, её удобно использовать при сравнениях версий (например, int(50207) для версии "5.2.7-extra"). Доступна начиная с версии PHP 5.2.7.
PHP_EXTRA_VERSION (string)
Текущая "экстра"-версия PHP в виде строки (например, '-extra' для версии "5.2.7-extra"). Обычно используется в различных дистрибутивах для индикации версий пакетов. Доступна начиная с версии PHP 5.2.7.
PHP_ZTS (integer)
Доступна начиная с версии PHP 5.2.7.
PHP_DEBUG (integer)
Доступна начиная с версии PHP 5.2.7.
PHP_MAXPATHLEN (integer)
Максимальная длина файловых имен (включая путь), поддерживаемая данной сборкой PHP. Доступна начиная с версии PHP 5.3.0.
PHP_OS (string)
PHP_SAPI (string)
Серверное API данной сборки PHP. Смотрите также php_sapi_name().
PHP_EOL (string)
Корректный символ конца строки, используемый на данной платформе. Доступна начиная с версии PHP 5.0.2
PHP_INT_MAX (integer)
Максимальное целое число, поддерживаемое данной сборкой PHP. Обычно это int(2147483647). Доступна начиная с версии PHP 5.0.5
PHP_INT_SIZE (integer)
Доступна начиная с версии PHP 5.0.5
DEFAULT_INCLUDE_PATH (string)
PEAR_INSTALL_DIR (string)
PEAR_EXTENSION_DIR (string)
PHP_EXTENSION_DIR (string)
PHP_PREFIX (string)
Значение опции "--prefix", указанной при запуске configure.
PHP_BINDIR (string)
Указывает путь установки бинарных файлов.
PHP_BINARY (string)
Указывает путь к исполняемым файлам PHP во время выполнения скрипта. Доступна с версии PHP 5.4.
PHP_MANDIR (string)
Указывает путь установки страниц документации man. Доступна, начиная с версии PHP 5.3.7.
PHP_LIBDIR (string)
PHP_DATADIR (string)
PHP_SYSCONFDIR (string)
PHP_LOCALSTATEDIR (string)
PHP_CONFIG_FILE_PATH (string)
PHP_CONFIG_FILE_SCAN_DIR (string)
PHP_SHLIB_SUFFIX (string)
Суффикс, используемый для динамически линкуемых библиотек, таких как "so" (характерный для большинства Unix-систем) или "dll" (Windows).
E_ERROR (integer)
Константа, указывающая уровень сообщений об ошибках
E_WARNING (integer)
E_PARSE (integer)
E_NOTICE (integer)
E_CORE_ERROR (integer)
E_CORE_WARNING (integer)
E_COMPILE_ERROR (integer)
E_COMPILE_WARNING (integer)
E_USER_ERROR (integer)
E_USER_WARNING (integer)
E_USER_NOTICE (integer)
E_DEPRECATED (integer)
Доступна начиная с версии PHP 5.3.0
E_USER_DEPRECATED (integer)
Доступна начиная с версии PHP 5.3.0
E_ALL (integer)
E_STRICT (integer)
__COMPILER_HALT_OFFSET__ (integer)
Доступна начиная с версии PHP 5.1.0
TRUE (boolean)
Смотрите раздел Булев тип.
FALSE (boolean)
Смотрите раздел Булев тип.
NULL (null)
Смотрите Null.
////////////////////////
СПОРТ
http://php.net/manual/ru/extensions.membership.php#extensions.membership.core
https://www.facebook.com/menshealthuk/videos/10157080857005234/

https://www.facebook.com/MensHealth/videos/10157143191695207/

https://www.facebook.com/MensHealth/videos/10157164422205207/  // to try
https://www.facebook.com/menshealthuk/videos/10157120295150234/
https://www.facebook.com/MensHealth/videos/10157203651965207/
..........................

ФиЛОСОФИЯ 
https://www.facebook.com/www.adme.ru/videos/10153824962320172/
...........................................................
PSR    // http://www.php-fig.org/psr/           // http://www.php-fig.org/psr/psr-1/
       // http://svyatoslav.biz/misc/psr_translation/
....................................

https://www.facebook.com/MensHealth/videos/10156472136150207/


	|| запинается на «правде»,
	&& запинается на «лжи».

	 true || true  // true
	 false || true  // true
	 true || false  // true
	 false || false  // false
	 true && true  // true
	 false && true  // false
	 true && false  // false
	 false && false  // false

//////////////////////////////////////////////////////
In PHP 7, following two new functions are introduced to generate cryptographically secure integers and strings in a cross platform way.

random_bytes() − Generates cryptographically secure pseudo-random bytes.

random_int() − Generates cryptographically secure pseudo-random integers.

..............   random_bytes()

random_bytes() generates an arbitrary-length string of cryptographic random bytes that are suitable for cryptographic use, such as when generating salts, keys or initialization vectors.

Syntax
string random_bytes ( int $length )
Parameters
length − The length of the random string that should be returned in bytes.

Return Values
Returns a string containing the requested number of cryptographically secure random bytes.

Errors/Exceptions
If an appropriate source of randomness cannot be found, an Exception will be thrown.

If invalid parameters are given, a TypeError will be thrown.

If an invalid length of bytes is given, an Error will be thrown.

Example
<?php
   $bytes = random_bytes(5);
   print(bin2hex($bytes));

It produces the following browser output −          54cc305593

............................  random_int()
random_int() generates cryptographic random integers that are suitable for use where unbiased results are critical.

Syntax
int random_int ( int $min , int $max )
Parameters
min − The lowest value to be returned, which must be PHP_INT_MIN or higher.

max - The highest value to be returned, which must be less than or equal to PHP_INT_MAX.

Return Values
Returns a cryptographically secure random integer in the range min to max, inclusive.

Errors/Exceptions
If an appropriate source of randomness cannot be found, an Exception will be thrown.

If invalid parameters are given, a TypeError will be thrown.

If max is less than min, an Error will be thrown.

Example
<?php
   print(random_int(100, 999));  // 614
   print("");
   print(random_int(-1000, 0));  // -882
?>
It produces the following browser output −                         614                             -882


//////////////////////////////////////////////  ФОРМЫ  ////////////////////////////////////////////////////
Элемент <fieldset> предназначен для группирования элементов формы. Такая группировка облегчает работу с формами, содержащими большое число данных, например, один блок может быть предназначен для ввода текстовой информации, а другой — для флажков.

Браузеры для повышения наглядности отображают результат использования элемента <fieldset> в виде рамки. Её вид зависит от операционной системы, а также используемого браузера.

Синтаксис:

<form>
  <fieldset>...</fieldset>
</form>
___________

    <form action="index.php" method="get" enctype="multipart/form-data">

                A:<input   type="text"   name="a"> 
		B:<input   type="text"   name="b"> 
		C:<input   type="text"   name="c"> 
                File:<input type="file" name="file">                  // при отправки файла, сервер получает его название(чтобы отпр.сам файл добавл.enctype="multipart/form
                                                                      //   -data", имя исчезнет, а файл попадет в супергл. мас. $_FILES)
	 	<input name="Submit" type="submit" value="Искать">            // name(key)  value(value)

        </form>
enctype - если хотим отправить файл на сервер          этот тип  multipart/form-data  работает при методе POST
.....................
Три категории :
 <input ... >;
 <texyarea ...> ... </texyarea ...>;
 <select...><option...>...</option>...</select>

Пары имя=значение перед тем, как отправятся сценарию, буду разделены в строке параметров символом &. 
Если параметр name не задан, соответствующая строка    имя=значение    передана не будет.
Все теги , за исключением <select> выглядят одинаково - как один, они генерируют строки вида   имя=значение  , где имя - строка, заданная в атрибуте name, 
а значение - либо текст, введенный пользователем, либо содержимое атрибута value (например, так происходит у независимых и зависимых переключателей)

 Имя:      <input type="text" name="firstname" value="значение" size="размер" maxlenth="число"> 
 Если задано value, то в текстовом поле будет изначально отображена указанная строка.
...........................
Поле ввода пароля(password)    <input type="password" name="name" value="значение" size="размер" maxlenth="число"> 
Символы не будут отображаться на экране.
..........................
Скрытое текстовое поле(hidden)   <input type="hidden" name="name" value="значение">
Создает неотображаемое(скрытое)поле.Такой объект нужен,чтобы передать сценарию некую служебную информацию.

        <form action="/cgi/index.php" method="post">

               <input   type="hidden"   name="email" value="admin@smth.com" > 
		<h2> Пошлите сообщение администратору</h2>
		<input   type="text"   name="text"> 
		<input type="submit" name="doSend" value="Отослать">            

        </form>


...........................
Переключатель
<input type="radio" name="YesorNo" value="yes" checked>  yes </input>
<input type="radio" name="YesorNo" value="no" > no </input> 
............................
Независимый переключатель
<input type="checkbox" name="spice0" value="wwww"> wwww </input> <br/>  
<input type="checkbox" name="spice1" value="qqqq"> qqqq </input> <br/>
<input type="checkbox" name="spice2" value="xxxx" checked> xxxx </input> <br/> <br/> <br/>
Если задан атрибут checked, то флажок будет изначально установлен.
.............................
Многострочное поле ввода текста
<textarea name = "comments" rows = "10" cols = "20" wrap="тип">  Hello  </textarea>
Параметр wrap определяет, как будет выглядеть текст в поле ввода.(Virtual,Physical, None)
.............................
Выпадающий список
<select name= "имя" size="размер" multiple> 
	<option value="Баккару" >Баккару Банзай</option>
	<option value="Томми">Чудесный Томми</option>
	<option value="Пенни" selected>Пенни Придди</option>
	<option value="Джерси">Нью-Джерси</option>
	<option>Джон Паркер</option>
</select> 
Параметр size задает,сколько строк будет занимать список.Если size равен 1, то список будет выпадающим, в противном случае - занимает size строк и имеет полосы прокрутки.
Если указан атрибут multiple, то будет разрешено выбирать сразу несколько элементов из списка, а иначе - только один.
Каждая строка списка опред. своим тегом  <option> . Если задан задан атрибут value , то строка списка будет идентифицирована его значением, а если не задан, 
то самим текстом этой строки(считается , что значение value равно самой строке).
Если указ. параметр selected, то данная строка будет изначально выбранной.

 Атрибуты:

autofocus - Устанавливает, что список получает фокус после загрузки страницы. 
disabled  - Блокирует доступ и изменение элемента.
form      - Связывает список с формой. 
multiple  - Позволяет одновременно выбирать сразу несколько элементов списка.
name      - Имя элемента для отправки на сервер или обращения через скрипты.
required  - Список обязателен для выбора перед отправкой формы. 
size      - Количество отображаемых строк списка.
..............................................
<input type="number" min="5" max="22"> 
<input type="range" min="0" max="10" step="2"> <br/> <br/> 
<input type="color"> color </input>  <br/> <br/> 
<input type="date"> date </input> <br/> <br/> 
<input type="email"> email </input> <br/> <br/> 
<input type="tel"> tel </input> <br/> <br/> 
<input type="url"> url </input> <br/> <br/>  


.............................
Кнопка отправки формы(submit)
<input type="submit" name="doSend" value="текст_кнопки">  
После нажатия кнопки передается пара doSend=текст_кнопки (name=value)
.................................
Рисунок отправки формы(image)
<input type="image" src="/путь/sub1.jpg" name="имя" />
Когда пользователь щелкнет где-нибудь на изображении, соответствующая форма будет передана на сервер с двумя дополнительными переменными - имя.x (имя_x) и имя.y(имя_y). 
Они содержат координаты нажатия пользователя на изображение.
..............................
Кнопка сброса формы(reset)
<input type="reset"  value="текст_кнопки">  
При нажатии все элементы формы в браузере будут сброшены(установлены в значения по умолчанию) 




...........................................
<input type="button" id="addButton" value="AddSong">
<button id="move_up">Move Up</button>
<button type="button" onclick="alert('Hello World!')">Click Me!</button>
...............
The purpose of the <keygen> element is to provide a secure way to authenticate users.

The <keygen> element specifies a key-pair generator field in a form.

When the form is submitted, two keys are generated, one private and one public.

The private key is stored locally, and the public key is sent to the server.

The public key could be used to generate a client certificate to authenticate the user in the future.

<form action="action_page.php">
  Username: <input type="text" name="user">
  Encryption: <keygen name="security">
  <input type="submit">
</form>


<form method="post" action="../admin/add_story.php"> 
<input name="Имя переключателя" type="Тип" value="Значение">
<input type="Тип" name="Имя кнопки" value="Надпись на кнопке">
</form>

..............
HTML5 added several new input types:

	color
	date
	datetime
	datetime-local
	email
	month
	number
	range
	search
	tel
	time
	url
	week


HTML5 Attributes
HTML5 added the following attributes for <input>:

	autocomplete
	autofocus
	form
	formaction
	formenctype
	formmethod
	formnovalidate
	formtarget
	height and width
	list
	min and max
	multiple
	pattern (regexp)
	placeholder
	required
	step
and the following attributes for <form>:

	autocomplete
	novalidate

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HTML-сущности    (HTML-entities)
<input type="text" name="text" value=" не "один",а "много" ">  - не можем написать напрямую.
Для решения таких проблем существ. спец. метод кодирования даннных, когда некоторые спец.символы заменяются на эквивалентные им HTML-сущности(HTML-entities)

/////////////////////////////////////////////////////
PHP Form Validation 
Think SECURITY when processing PHP forms!

The Form Element
The HTML code of the form looks like this:

<form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>">

When the form is submitted, the form data is sent with method="post".
What is the $_SERVER["PHP_SELF"] variable?
The $_SERVER["PHP_SELF"] is a super global variable that returns the filename of the currently executing script.

So, the $_SERVER["PHP_SELF"] sends the submitted form data to the page itself, instead of jumping to a different page. This way, the user will get error messages on the same page as the form.

What is the htmlspecialchars() function?

The htmlspecialchars() function converts special characters to HTML entities. This means that it will replace HTML characters like < and > with &lt; and &gt;. This prevents attackers from exploiting the code by injecting HTML or Javascript code (Cross-site Scripting attacks) in forms.



Big Note on PHP Form Security
The $_SERVER["PHP_SELF"] variable can be used by hackers!

If PHP_SELF is used in your page then a user can enter a slash (/) and then some Cross Site Scripting (XSS) commands to execute.

Cross-site scripting (XSS) is a type of computer security vulnerability typically found in Web applications. XSS enables attackers to inject client-side script into Web pages viewed by other users.



Validate Form Data With PHP
The first thing we will do is to pass all variables through PHP's htmlspecialchars() function.

When we use the htmlspecialchars() function; then if a user tries to submit the following in a text field:

<script>location.href('http://www.hacked.com')</script>

- this would not be executed, because it would be saved as HTML escaped code, like this:

&lt;script&gt;location.href('http://www.hacked.com')&lt;/script&gt;

The code is now safe to be displayed on a page or inside an e-mail.

We will also do two more things when the user submits the form:

Strip unnecessary characters (extra space, tab, newline) from the user input data (with the PHP trim() function)
Remove backslashes (\) from the user input data (with the PHP stripslashes() function)
The next step is to create a function that will do all the checking for us (which is much more convenient than writing the same code over and over again).

We will name the function test_input().

Now, we can check each $_POST variable with the test_input() function, and the script looks like this:

Example
<?php
// define variables and set to empty values
$name = $email = $gender = $comment = $website = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  $name = test_input($_POST["name"]);
  $email = test_input($_POST["email"]);
  $website = test_input($_POST["website"]);
  $comment = test_input($_POST["comment"]);
  $gender = test_input($_POST["gender"]);
}

function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}
?>
// $search = htmlspecialchars($search, ENT_QUOTES, 'UTF-8');

Notice that at the start of the script, we check whether the form has been submitted using $_SERVER["REQUEST_METHOD"]. If the REQUEST_METHOD is POST, then the form has been submitted - and it should be validated. If it has not been submitted, skip the validation and display a blank form.

However, in the example above, all input fields are optional. The script works fine even if the user does not enter any data.

The next step is to make input fields required and create error messages if needed.



//////////////////////////////////////////////////////////////

Загрузка файлов (Котеров с.96(69))
 <form action="index.php" method="get" enctype="multipart/form-data"> 
   <input type="file" name="file"> 
 </form>
enctype="multipart/form-data

....................
Configure The "php.ini" File:

First, ensure that PHP is configured to allow file uploads.In your "php.ini" file, search for the file_uploads directive, and set it to On:
       file_uploads = On
.....................
Create The HTML Form
 <!DOCTYPE html>
<html>
<body>

<form action="upload.php" method="post" enctype="multipart/form-data">
    Select image to upload:
    <input type="file" name="fileToUpload" id="fileToUpload">
    <input type="submit" value="Upload Image" name="submit">
</form>

</body>
</html>
.........................
Some rules to follow for the HTML form above:

Make sure that the form uses  method="post"
The form also needs the following attribute:  enctype="multipart/form-data". 
 It specifies which content-type to use when submitting the form
Without the requirements above, the file upload will not work.

Other things to notice:

The type="file" attribute of the <input> tag shows the input field as a file-select control, with a "Browse" button next to the input control

........................
Complete Upload File PHP Script
The complete "upload.php" file now looks like this:

<?php
$target_dir = "uploads/";
$target_file = $target_dir . basename($_FILES["fileToUpload"]["name"]);
$uploadOk = 1;
$imageFileType = pathinfo($target_file,PATHINFO_EXTENSION);
// Check if image file is a actual image or fake image
if(isset($_POST["submit"])) {
    $check = getimagesize($_FILES["fileToUpload"]["tmp_name"]);
    if($check !== false) {
        echo "File is an image - " . $check["mime"] . ".";
        $uploadOk = 1;
    } else {
        echo "File is not an image.";
        $uploadOk = 0;
    }
}
// Check if file already exists
if (file_exists($target_file)) {
    echo "Sorry, file already exists.";
    $uploadOk = 0;
}
// Check file size
if ($_FILES["fileToUpload"]["size"] > 500000) {          // 500kb
    echo "Sorry, your file is too large.";
    $uploadOk = 0;
}
//The code below only allows users to upload JPG, JPEG, PNG, and GIF files. All other file types gives an error message before setting $uploadOk to 0:
// Allow certain file formats        
if($imageFileType != "jpg" && $imageFileType != "png" && $imageFileType != "jpeg"
&& $imageFileType != "gif" ) {
    echo "Sorry, only JPG, JPEG, PNG & GIF files are allowed.";
    $uploadOk = 0;
}
// Check if $uploadOk is set to 0 by an error
if ($uploadOk == 0) {
    echo "Sorry, your file was not uploaded.";
// if everything is ok, try to upload file
} else {
    if (move_uploaded_file($_FILES["fileToUpload"]["tmp_name"], $target_file)) {
        echo "The file ". basename( $_FILES["fileToUpload"]["name"]). " has been uploaded.";
    } else {
        echo "Sorry, there was an error uploading your file.";
    }
}


PHP script explained:

$target_dir = "uploads/" - specifies the directory where the file is going to be placed
$target_file specifies the path of the file to be uploaded
$uploadOk=1 is not used yet (will be used later)
$imageFileType holds the file extension of the file
Next, check if the image file is an actual image or a fake image

Note: You will need to create a new directory called "uploads" in the directory where "upload.php" file resides. The uploaded files will be saved there.


//////////////////////////////////////////////////////////////////////

Суперглобальные переменные - это встроенные переменные, которые всегда доступны во всех областях видимости

Описание 

Некоторые предопределённые переменные в PHP являются "суперглобальными", что означает, что они доступны в любом месте скрипта. Нет необходимости использовать синтаксис global $variable; для доступа к ним в функциях и методах.

Суперглобальными переменными являются:

$GLOBALS
$_SERVER
$_GET
$_POST
$_FILES
$_COOKIE
$_SESSION
$_REQUEST
$_ENV

$_REQUEST — Переменные HTTP-запроса
Ассоциативный массив (array), который по умолчанию содержит данные переменных $_GET, $_POST и $_COOKIE.
















</body>
</html>

<?php


Avoid w3schools for HTML/CSS/Javascript and everything else:
http://phptherightway.com
http://php.net/manual/en
The group''s site has comprehensive resources: http://wwphp-fb.github.io/faq/

A really good cheatsheet can be found here: http://phpcheatsheets.com

Security Resources:
https://www.facebook.com/groups/2204685680/permalink/10154580375390681/
http://bobby-tables.com
http://wwphp-fb.github.io/faq/databases/mysqli-or-pdo/
http://wwphp-fb.github.io/faq/security/sql-injection/
http://wwphp-fb.github.io/faq/security/passwords
http://digg.com/video/computerphile-cracks-your-password
https://phpdelusions.net/pdo
https://phpdelusions.net/sql_injection
Prepared Statements are still vulnerable: http://stackoverflow.com/a/12202218/1508101

Other vulnerability attacks you need to consider:
1. XSS Injection: resources:
- https://www.sitepoint.com/php-security-cross-site.../
- http://security.stackexchange.com/a/109438

2. CSRF Attacks: resources:
- http://www.wikihow.com/Prevent-Cross-Site-Request-Forgery...
- http://csrf.htmlpurifier.org/
- https://www.sitepoint.com/preventing-cross-site-request.../
- http://stackoverflow.com/a/2526579/4548751.

3. Timing Attack: resources:
- http://blog.ircmaxell.com/2014/11/its-all-about-time.html.
- Or use php hash_equals(): http://php.net/manual/en/function.hash-equals.php

For HTML/CSS/Javascript: https://developer.mozilla.org/en-US/docs/Web



http://www.phptherightway.com                  PHP
                                           The Right Way

........................................................
Security should NEVER, EVER, EVER, EVER be an afterthought when you are writing a webapp...what scares me most is many of you are writing e-commerce systems and don''t think of security? You're asking to be hacked, and your customers' data to be sold to the highest bidder. It's criminally negligent. Don't use deprecated APIs (mysql_* functions are deprecated), use either mysqli(http://php.net/manual/en/book.mysqli.php) or PDO, which is preferred(http://php.net/manual/en/book.pdo.php, https://phpdelusions.net/pdo)
Not sure which: http://wwphp-fb.github.io/faq/databases/mysqli-or-pdo/
Think of security, and your design before you even start to code and do so from the mindset of a hacker deadset on stealing your customers'' data and wrecking your precious site:
Check out: https://www.owasp.org/index.php/PHP_Security_Cheat_Sheet
You need to think of(this is all covered in the link above) 
- CSRF attacks (http://www.wikihow.com/Prevent-Cross-Site-Request-Forgery-(…, http://csrf.htmlpurifier.org/,, https://www.sitepoint.com/preventing-cross-site-request-fo…/, http://stackoverflow.com/a/2526579/4548751.
- Timing attacks(http://blog.ircmaxell.com/2014/11/its-all-about-time.html, or use php hash_equals(): http://php.net/manual/en/function.hash-equals.php)
- Cross-Site-Scripting (XSS) attacks(https://www.sitepoint.com/php-security-cross-site-scriptin…/, http://security.stackexchange.com/a/109438
These can be used to steal users'' cookies and then impersonate them)
- SQL injection attacks(http://wwphp-fb.github.io/faq/security/sql-injection/, https://phpdelusions.net/sql_injection, http://bobby-tables.com)
These are only a few, check out: https://www.owasp.org/index.php/PHP_Security_Cheat_Sheet.
- Securing your server, making sure everything is up to date and patched
- PROPERLY hashing your passwords (http://wwphp-fb.github.io/faq/security/passwords/)

............................
For PHP related resources browse these:
- PHP manual which should be your No.1 resource: https://php.net
- http://phptherightway.com
- and than the documentation of the frameworks. 

More useful resources in the FAQ:
- https://wwphp-fb.github.io/faq/intro/what-is-php/

Also take an old school approach and read some books like all normal developers:
https://wwphp-fb.github.io/faq/which-books-for-php/

When you'll understand basics go also here:
https://nomadphp.com/

w3schools is maybe useful just to get a taste of web. For more you'll need to study more serious stuff.
JS, CSS:
https://developer.mozilla.org/en-US/docs/Web
w3schools are on the other hand ok to get an understanding of some html tags here and there.

.................................................................
Технология отложенного копирования (Котеров с.284(257))   // TODO

<?php
//
function takeVal($a) { $x = $a[1234]; }
//
function takeRef(&$a) { $x = $a[1234]; }
//
function takeValAndModif($a) { $a[1234]++; }
//
function takeRefAndModif(&$a) { $a[1234]++; }

//
test("takeVal");
test("takeRef");
test("takeValAndModif");
test("takeRefAndModif");

function test($func) {
   //
   $a = array(); // array (www.php.net/array)()
   for ($i=1; $i<=100000; $i++) $a[$i] = $i;
   //
   for ($t=time(); $t == time(); ); // time (www.php.net/time)()
   //
   for ($N=0, $t=time(); time() == $t; $N++) $func($a);
   printf("$func took %d itr/sec\n", $N);
}

/*
takeVal took 8889126 itr/sec
takeRef took 8443502 itr/sec
takeValAndModif took 891 itr/sec
takeRefAndModif took 7473268 itr/sec
*/

/*
Суть теста заключается в том, что мы создаем в памяти массив очень большого раз-мера (100000 элементов) и передаем его в функции с разными видами параметров, замеряя при этом время работы. В конце выводится сводка, сколько вызовов функ-ций разного типов "уложилось" ровно в 1 секунду. 


Давайте посмотрим вначале на первые две строчки. Он говорят, что вызов функции с передачей параметра по значению работает даже быстрее, чем передача по ссылке! В действительности, запустив тест несколько раз подряд, можно убедиться, что раз-ница в скорости не выходит за рамки погрешности подсчета времени: иногда takeRef() выходит на первое место по сравнению с takeVal(), а иногда (вот как сейчас) — на второе. 
Для того чтобы понять, каким же образом передача параметров по значению может работать не медленнее, чем по ссылке, взглянем на третью и четвертую строки ре-зультата. Вы видите, что функция takeValAndModif(), принимающая аргумент по значению и изменяющая его "локальную копию", резко (примерно в двадцать тысяч раз!) медленнее, чем ее аналог, имеющий агрумент-ссылку! Но ведь только что мы говорили, что параметры-ссылки и параметры-значения не различаются сколько-нибудь существенно по скорости. Что же происходит? 
Ответ кроется в одной особенности языка PHP версий 4 и 5, которые авторы этой книги не встречали ни в одном другом языке программирования. 

Речь идет о технологии отложенного копирования данных. Она работает так: когда в программе выполняется оператор присваивания (или, что то же самое, передача параметра в функ-цию по значению), PHP никуда не копирует данные, содержащиеся в переменной (в нашем случае — огромный массив). Вместо этого он просто помечает переменную-приемник как копию источника, что практически не отнимает времени. Реальное копирование данных будет отложено до того момента, когда одна из переменных потребует изменения (в примере выше — инкремент одной ячейки массива).

Таким образом, если вы в программе делаете сто "копий" одной и той же переменной при помощи оператора присваивания, а потом меняете только одну из них, PHP в реальности произведет всего лишь одну операцию копирования (а не сто, как это сделали бы другие языки программирования: PHP3, Perl, C++ и т.д.). Разработчики PHP мудро учли тот факт, что в крупных программах большинство операций копирования носят характер абстрактного "переименования" и производятся "вхолостую", а значит, в идеале не требуют передачи больших блоков данных и выделения новой памяти. 
Теперь вы понимаете, почему функция takeValAndModif() оказалась в 20000 раз медленнее, чем takeRefAndModif(), а takeVal() и takeRef() работают с одинако-вой скоростью? Ведь медленная функция изменяет свой параметр-значение, что за-ставляет PHP немедленно породить локальную копию переменной, уничтожаемую после выхода из функции. В то же время, изменение параметра-ссылки в takeRe-fAndModif() не влечет копирование, ибо модификация производится в уже сущест-вующем массиве. Что касается takeVal(), то она свой параметр не изменяет, и по-тому копирования и связанной с ним потери производительности нет.

*/
...................................................................

Сборка мусора   // http://php.net/manual/ru/features.gc.php#features.gc  

Котеров с.200(с.173)

Что происходит, когда мы присваиваем переменной $а некоторое значениe?

1. Выделяется оперативная память для хранения значения.
2.PHP регистрирует в своих таблицах новую переменную $а, с которой связывает выделенный только что участок памяти.

Теперь при обращении к $а PHP найдет ее в своих таблицах и обратиться к выделенной ранее области памяти, чтобы получить значение переменной.

$a = 10;
$b  = & $a;   // то $b указывает на то же значение что и $a.
$a = 0;
echo " b = $b, a = $a";  //  b=0  ,  a=0

$a и $b здесь абсолютно эквивалентны, но это не означает, что $a указывает на $b или наоборот. Это означает, что $a и $b указывают на одно и тоже значение.

Ссылка в PHP это псевдоним (алиас), который позволяет присвоить двум переменным одинаковое значение. 
Начиная с PHP 5 объектная переменная больше не содержит сам объект как значение. Такая переменная содержит только идентификатор объекта, который позволяет найти конкретный объект при обращении к нему. Когда объект передается как аргумент функции, возвращается или присваивается другой переменной, то эти разные переменные не являются псевдонимами (алиасами): они содержат копию идентификатора, который указывает на один и тот же объект.

При сбросе ссылки, просто разрывается связь имени и содержимого переменной. Это не означает, что ,содержимое переменной будет разрушено. Например:

<?php
$a = 1;
$b =& $a;
unset($a); 

Этот код не сбросит $b, а только $a.


Объект удаляется только тогда, когда на него никто не ссылается.

............................
pthreads in php

https://gist.github.com/krakjoe/6437782/

https://github.com/reactphp/react/wiki/FAQ...
https://github.com/reactphp/react/wiki/FAQ#what-about-threads



.................................................

http://php.net/manual/ru/function.header.php                                     header

________________________________________________________________________________________________________________________________

http://php.net/manual/ru/book.math.php
Математические функции

abs — Модуль числа
acos — Арккосинус
acosh — Гиперболический арккосинус
asin — Арксинус
asinh — Гиперболический арксинус
atan2 — Арктангенс двух переменных
atan — Арктангенс
atanh — Гиперболический арктангенс
cos — Косинус
cosh — Гиперболический косинус
tan — Тангенс
tanh — Гиперболический тангенс
sin — Синус
sinh — Гиперболический синус

hypot — Рассчитывает длину гипотенузы прямоугольного треугольника

base_convert — Преобразование числа между произвольными системами счисления

bindec — Двоичное в десятичное
decbin — Переводит число из десятичной системы счисления в двоичную
dechex — Переводит число из десятичной системы счисления в шестнадцатеричную
decoct — Переводит число из десятичной системы счисления в восьмеричную
hexdec — Переводит число из шестнадцатеричной системы счисления в десятичную
octdec — Переводит число из восьмеричной системы счисления в десятичную

deg2rad — Преобразует значение из градусов в радианы
rad2deg — Преобразует значение из радианов в градусы

ceil — Округляет дробь в большую сторону
floor — Округляет дробь в меньшую сторону
round — Округляет число типа float



exp — Вычисляет число e в степени
expm1 — Возвращает exp(number) - 1, рассчитанное таким образом, что результат точен, даже если number близок к нулю.

fmod — Возвращает дробный остаток от деления по модулю
getrandmax — Возвращает максимально возможное случайное число


intdiv — Integer division

is_finite — Проверяет, является ли значение допустимым конечным числом
is_infinite — Проверяет, является ли значение бесконечным
is_nan — Проверяет, является ли значение "не числом"

lcg_value — Комбинированный линейно конгруэнтный генератор

log10 — Десятичный логарифм
log1p — Возвращает log(1 + number), рассчитанный таким, что результат точен, даже если значение number близко к нулю
log — Натуральный логарифм

max — Возвращает наибольшее значение
min — Находит наименьшее значение

rand — Генерирует случайное число
srand — Изменяет начальное число генератора псевдослучайных чисел

mt_getrandmax — Показывает максимально возможное значение случайного числа
mt_rand — Генерирует случайное значение методом mt
mt_srand — Переинициализирует генератор случайных чисел mt

pi — Возвращает число Пи
pow — Возведение в степень

sqrt — Квадратный корень



____________________________________________________________


<img class="scaledImageFitWidth img" src="https://external-cdg2-1.xx.fbcdn.net/safe_image.php?d=AQDVlJNlTBF8RxmB&amp;w=476&amp;h=249&amp;url=fbstaging%3A%2F%2Fgraph.facebook.com%2Fstaging_resources%2FMDE2NDMyMzQ2ODI1MTk4ODc6MjAwMjA5OTExNA%3D%3D&amp;cfs=1&amp;upscale=1" alt="" width="476" height="249">


////////////////////
Дата и Время            		//http://php.net/manual/ru/book.datetime.php
Функции даты и времени  //http://php.net/manual/ru/ref.datetime.php

///////////////////ф-ции для обработки строк //////////////////

Обработка строк
addcslashes — Экранирует cтроку слешами в стиле языка C
addslashes — Экранирует строку с помощью слешей
bin2hex — Преобразует бинарные данные в шестнадцатеричное представление
chop — Псевдоним rtrim
chr — Возвращает символ по его коду
chunk_split — Разбивает строку на фрагменты
convert_cyr_string — Преобразует строку из одной кириллической кодировки в другую
convert_uudecode — Декодирует строку из формата uuencode в обычный вид
convert_uuencode — Кодирует строку в формат uuencode
count_chars — Возвращает информацию о символах, входящих в строку
crc32 — Вычисляет полином CRC32 для строки
crypt — Необратимое хэширование строки
echo — Выводит одну или более строк
explode — Разбивает строку с помощью разделителя
fprintf — Записывает отформатированную строку в поток
get_html_translation_table — Возвращает таблицу преобразований, используемую функциями htmlspecialchars и htmlentities
hebrev — Преобразует текст на иврите из логической кодировки в визуальную
hebrevc — Преобразует текст на иврите из логической кодировки в визуальную с преобразованием перевода строки
hex2bin — Преобразует шестнадцатеричные данные в двоичные
html_entity_decode — Преобразует все HTML-сущности в соответствующие символы
htmlentities — Преобразует все возможные символы в соответствующие HTML-сущности
htmlspecialchars_decode — Преобразует специальные HTML-сущности обратно в соответствующие символы
htmlspecialchars — Преобразует специальные символы в HTML-сущности
implode — Объединяет элементы массива в строку
join — Псевдоним implode
lcfirst — Преобразует первый символ строки в нижний регистр
levenshtein — Вычисляет расстояние Левенштейна между двумя строками
localeconv — Возвращает информацию о числовых форматах
ltrim — Удаляет пробелы (или другие символы) из начала строки
md5_file — Возвращает MD5-хэш файла
md5 — Возвращает MD5-хэш строки
metaphone — Возвращает ключ metaphone для строки
money_format — Форматирует число как денежную величину
nl_langinfo — Возвращает информацию о языке и локали
nl2br — Вставляет HTML-код разрыва строки перед каждым переводом строки
number_format — Форматирует число с разделением групп
ord — Возвращает ASCII-код символа
parse_str — Разбирает строку в переменные
print — Выводит строку
printf — Выводит отформатированную строку
quoted_printable_decode — Преобразует строку, закодированную методом quoted-printable в 8-битовую строку
quoted_printable_encode — Кодирует 8-битную строку в с помощью метода quoted-printable
quotemeta — Экранирует специальные символы
rtrim — Удаляет пробелы (или другие символы) из конца строки
setlocale — Устанавливает настройки локали
sha1_file — Возвращает SHA1-хэш файла
sha1 — Возвращает SHA1-хэш строки
similar_text — Вычисляет степень похожести двух строк
soundex — Возвращает ключ soundex для строки
sprintf — Возвращает отформатированную строку
sscanf — Разбирает строку в соответствии с заданным форматом
str_getcsv — Выполняет разбор CSV-строки в массив
str_ireplace — Регистронезависимый вариант функции str_replace
str_pad — Дополняет строку другой строкой до заданной длины
str_repeat — Возвращает повторяющуюся строку
str_replace — Заменяет все вхождения строки поиска на строку замены
str_rot13 — Выполняет преобразование ROT13 над строкой
str_shuffle — Переставляет символы в строке случайным образом
str_split — Преобразует строку в массив
str_word_count — Возвращает информацию о словах, входящих в строку
strcasecmp — Бинарно-безопасное сравнение строк без учета регистра
strchr — Псевдоним strstr
strcmp — Бинарно-безопасное сравнение строк
strcoll — Сравнение строк с учетом текущей локали
strcspn — Возвращает длину участка в начале строки, не соответствующего маске
strip_tags — Удаляет HTML и PHP-теги из строки
stripcslashes — Удаляет экранирование символов, произведенное функцией addcslashes
stripos — Возвращает позицию первого вхождения подстроки без учета регистра
stripslashes — Удаляет экранирование символов
stristr — Регистронезависимый вариант функции strstr
strlen — Возвращает длину строки
strnatcasecmp — Сравнение строк без учета регистра с использованием алгоритма "natural order"
strnatcmp — Сравнение строк с использованием алгоритма "natural order"
strncasecmp — Бинарно-безопасное сравнение первых n символов строк без учета регистра
strncmp — Бинарно-безопасное сравнение первых n символов строк
strpbrk — Ищет в строке любой символ из заданного набора
strpos — Возвращает позицию первого вхождения подстроки
strrchr — Находит последнее вхождение символа в строке
strrev — Переворачивает строку задом наперед
strripos — Возвращает позицию последнего вхождения подстроки без учета регистра
strrpos — Возвращает позицию последнего вхождения подстроки в строке
strspn — Возвращает длину участка в начале строки, полностью соответствующего маске
strstr — Находит первое вхождение подстроки
strtok — Разбивает строку на токены
strtolower — Преобразует строку в нижний регистр
strtoupper — Преобразует строку в верхний регистр
strtr — Преобразует заданные символы или заменяет подстроки
substr_compare — Бинарно-безопасное сравнение 2 строк со смещением, с учетом или без учета регистра
substr_count — Возвращает число вхождений подстроки
substr_replace — Заменяет часть строки
substr — Возвращает подстроку
trim — Удаляет пробелы (или другие символы) из начала и конца строки
ucfirst — Преобразует первый символ строки в верхний регистр
ucwords — Преобразует в верхний регистр первый символ каждого слова в строке
vfprintf — Записывает отформатированную строку в поток
vprintf — Выводит отформатированную строку
vsprintf — Возвращает отформатированную строку
wordwrap — Переносит строку по указанному количеству символов

/////////////////////////////////////


/usr/lib/x86_64-linux-gnu/opera

https://www.facebook.com/MensHealth/videos/10157301452300207/                          // ab && leg

https://www.facebook.com/MensHealth/videos/10157325182510207/

https://www.facebook.com/menshealthuk/videos/10157322891630234/

https://www.facebook.com/MensHealth/videos/10157425244170207/
////////////////////


$a = 1;
$b = 3;
echo $a++ + $b;  //4
echo $a + ++$b; //6
echo ++$a + $b++; // 7

//////////////////////////
Если атака выполняется одновременно с большого числа компьютеров, говорят о DDoS-атаке (от англ. Distributed Denial of Service, распределённая атака типа «отказ в обслуживании»).
DoS (от англ. Denial of Service — отказ в обслуживании) — хакерская атака на вычислительную систему с целью довести её до отказа, то есть создание таких условий, при которых добросовестные пользователи системы не могут получить доступ к предоставляемым системным ресурсам (серверам), либо этот доступ затруднён. Отказ «вражеской» системы может быть и шагом к овладению системой (если в нештатной ситуации ПО выдаёт какую-либо критическую информацию — например, версию, часть программного кода и т. д.).
_________________________________
Валидация — подтверждение путем экспертизы и представления объективного доказательства того, что особые требования, предназначенные для конкретного применения, соблюдены. Примечания: При проектировании и разработке утверждение означает проведение экспертизы продукции с целью определения соответствия нуждам потребителя.

Верификация проверяет соответствие одних создаваемых в ходе разработки и сопровождения ПО артефактов другим, ранее созданным или используемым в качестве исходных данных, а также соответствие этих артефактов и процессов их разработки правилам и стандартам. Другими словами, при верификации проверяем все, что написано в ТЗ. Система работает так, как написано в ТЗ? — Успех. Система работает не так? — Провал.

Валидация проверяет соответствие любых создаваемых или используемых в ходе разработки и сопровождения ПО артефактов нуждам и потребностям пользователей и заказчиков этого ПО, с учетом законов предметной области и ограничений контекста использования ПО. Другими словами, при валидации проверяем, выполняет ли она те функции, которые от нее ждут конечные пользователи? Если да — Пройдено, если нет — Провал.
________________

СПАМ
Ненужные адресату электронные послания, рекламные письма и т. п., рассылаемые отдельными фирмами по Интернету или электронной почте.

Спам (англ. spam) — массовая рассылка коммерческой и иной рекламы или подобных коммерческих видов сообщений лицам, не выражавшим желания их получать[1][2]. Распространителей спама называют спамерами.
___________________________
RSS -формат данных, позволяющий пользователям узнавать о содержании сайта без его посещения.
RSS - это язык разметки, использ. для описания содержания предназнвченного для распространения
________________
REST-3anpoc
_________________________
Если вы попытаетесь вывести значение
переменной $result непосредственно с помощью команды
echo, вы увидите что-нибудь подобное:

Resource id #3

Переменная $result содержит номер идентификатора ресурса MySQL,
а не непосредетвенные данные, полученные в результате выполнения запроса.
Происходит это следующим образом: MySQL-сервер временно сохраняет результат
выполнения вашего запроса и присваивает ему номер ресурса, по которому его
можно идентифицировать . Затем вы передаете этот идентификатор функции РНР
mysqli_fetch_array ( ), которая извлекает данные по одной записи за раз.

Поэтому, когда функция mysqli_fetch_array () возвращает массив данных, переменная $row
(в контексте проверки условия) интерпретируется как true, так как она
не является ни нулем (О), ни false.
Если в результатах запроса нет данных(пустой массив), это будет интерпретироваться как то, что функция
mysqli_fetch_array () возвратила значение false.
В результате цикл while не совершит ни одного прохода, что означает,
что код внутри фигурных скобок не будет выполнен ни одного раза.
___________________
Функция
isset () проверяет, существует ли переменная, то есть присвоено ли ей какое-либо
значение. 
Функция empty () идет на шаг дальше и определяет, присвоено ли переменной
пустое значение, что определяется в РНР как О (ноль), пустая строка("" или '')
или значения false или NULL.

______________________________
как обстоят дела с бинарными данными? Cкажем, такими как изображения
в формате JPEG или документы в формате PDF

Kудa деваются загружаемые на сервер файлы? с.275 "Мориссон  PHP MySQL"
Проблема, связанная с файлами, загруженными на сервер, заключается в том , что мы предполагаем, что
файлы должны сохраняться в тот же каталог на веб-сервере, в котором размещены наши РНР-сценарии .
Оказывается, это совершенно неверное предположение. Форма [добавь свой рейтинг] дает возмoжность
пользователю выбрать файл на своем собственном компьютере, но загруженный файл сохраняется
во временном каталоге. Он создается на сервере автоматически и обычно имеет бессмысленное имя,
состоящее из случайного набора букв и цифр.

Тем не менее вы не можете контролировать расположение каталога для
первоначального сохранения загружаемых файлов. Но вы можете пере местить
файл в другое место, после того как процесс загрузки завершился . РНР-функция
move_uploaded_file (),
используя исходное место расположения файла
и место его назначения , выполняет задачу по его перемещению:

move_uploaded_file ($_FILE['screenshot']['tmp_name'],$target);

$_FILE['screenshot']['tmp_name'] - исходное расп. файла 
$target - место назначения(имя каталога или имя самого файла)

Инициализационный файл РНР (php. ini) может быть
использован для изменения первоначального места расположения
загружаемых файлов через его опцию
upload_tmp_dir. Но если
вы арендуете виртуальный сервер у хостинговой компании, у вас
может не быть доступа с правом записи к этому файлу, что означает,
что вы все же должны будете переместить файл в свой собственный
каталог с помощью сценария РНР.

Каталог называется 'временным' в том смысле,
что он не рассматривается как окончательное место расположения
загружаемых файлов. Вы можете рассматривать его как область
промежуточного хранения , где загружаемые файлы хранятся до тех
пор, пока не будут перемещены на их постоянное место .

Почему я не могу просто оставить файл во временном
каталоге?

ВЫ можете это сделать. В этом случае необходимо добавить
значение переменной
$_FILES [ ' screenshot ' ][ 'tmp_name']
к имени файла изображения , чтобы к нему был
доступ во временном каталоге. Но имейте в виду, что в общем случае
у вас не будет полного контроля над именем и расположением
каталога. И, что более важно, в некоторых системах временные
каталоги могут периодически очищаться . Другая потенциальная
проблема заключается в том, что временные каталоги могут
не быть доступными для всех, поэтому вы не сможете ссылаться
на них из НТМL- кода, на чем базируется ве6-приложение «Гитарные
войны » И большинство других РНР-приложениЙ. Перемещая файлы
из временного каталога, вы получаете полный контроль над тем,
где конкретно они будут размещаться и с каким уровнем доступа .
__________________

Если файл php.ini может быть
использован для контроля над местом
размещения загружаемых файлов, эачем
тогда перемещать эти файлы?

Потому что не всегда имеется
возможность вносить изменения в файл
php.ini . И даже если у вас есть такая
возможность. вы рискуете получить
проблемы. если возникнет необходимость
переместить приложение на другой сервер.
Иначе говоря. приложение будет зависимо
от пути. контролируемого внешним
файлом php.ini.
в отличие от пути,
контролируемого внутренним кодом РНР
вашего приложения .
...........
если два пользователя загружают файлы с одинаковым именем, файл первого
пользователя будет заменен файлом
второго. Это плохо. Одно из решений
заключается в том, чтобы повысить уровень
уникальности имен файлов. загружаемых
на сервер. Простой способ достижения
этой цели - добавление текущего
на момент загрузки времени в секундах
в начало имени файла. как показано ниже:

define('GW_UPLOADPATH','images/')
$targer = GW_UPLOADPATH.time().$screenshot;

________________________________
Слово оnсе (однажды) в зтом
выражении означает, что код будет добавлен в 'сценарий' только
однажды, даже если это выражение встретится в нем (по ошибке)
более одного раза.
____________________________
Встроенная РНР-функция unlink ( ) удаляет файл
на сервере: в нашем cлучае -
подтверждающего рейтинг
пользователя временный файл изображения, который
был загружен. Так как не исключено, что загрузка
файла не удалась и на сервере нет временного файла
изображения (удалять нечего) , мы подавляем любое
сообщение об ошибке, выводимое функцией
unlink ( ) ,
путем введения перед ее именем символа @. Вы можете
ставить этот символ перед любой РНР-функцией, чтобы
подавить ее возможное сообщение об ошибке.
____________________________
НТТР-заголовки тщательно следят за тем , какая информация и как проходит
в прямом И обратном направлении между браузером и веб-сервером. Индивидуальный
НТТР-заголовок чаще всего состоит из пары 'имя/значение', которая определяет
конкретные сведения - такие, например, как формат содержания веб-страницы (НТМL).
Определенная группа НТТР-заголовков посылается на сервер как часть запроса
веб-страницы, а затем другая группа возвращается сервером как часть ответа на этот запрос.
давайте познакомимся поближе с этими группами НТТР-заголовков, чтобы понять, какая
передается информация, когда клиент и сервер ведут диалог друг с другом.

Первый HTTP-заголовок не представляет пару 'имя/значение'.Это запрос страницы GET(POST)

НTTР-загoловок: Когда кто-нибудь вводит
URL в адресную строку браузера или щелкает
по гиперссылке на веб-странице, браузер составляет
запрос GET и отправляет его серверу . Этот запрос
состоит из нескольких заголовков, содержащих
информацию о нем . Заголовки содержат такие данные,
как наименование и адрес запрашиваемой страницы , тип
браузера, с которого был отправлен запрос , и т . п .
с.335

вы можете очень легко работать с заголовками, присланными
сервером, что дает возможность выполнять задачи, управляемые заголовками,
к которым относится и НТТР-аутентификация. Встроенная функция
 header () может быть использована в РНР-сценарии для передачи заголовка с сервера
браузеру.
Функция header () немедленно отправляет НТТР-заголовок с сервера
 и должна вызываться до того, как само содержание страницы будет отправлено
браузеру.Это требование является очень строгим. Если хотя бы один символ
или даже пробел будет отослан до отправки НТТР-заголовка, браузер отбросит
его и выведет сообщение об ошибке. Поэтому вызов функции должен
предшествовать любому НТМL-коду в РНР-сценарии:

Аутентификация с использованием НТТР-заголовков
НТТР/1.1 401 Unauthorized
WWW_Authenticate: Basic rеаlm="Гитариые воины"
После обработки НTTР-заголовков аутентификации браузер ожидает
результатов диалога с пользователем, который проходит с использованием 
окна аутентификации.

НТГР-зaroловки, они достаточно гибки и могут быть
использованы для решения многих других интересных задач.
Достаточно просто вызвать ф-цию header() с соответствующей парой 'имя/значение',как пример:
header("HTTP/1.0 404 Not Found");
header("Location: http://www.example.com/about.php"); /* Перенаправление броузера */
Этoт НТГР-зaroловок называетсЯ lосаtioп header (НТTР-зaroловок
места расположения) и переадресовывает текущую страницу на страницу
с именем about.php на том же сайте ""
header('WWW-Authenticate: NTLM', false);

Этот НТТР-заголовок называется refresh header (НТТР-заголовок
обновления), так как он обновляет страницу через указанное время.
header('Refresh: 5; url=http://www.smth.net/about.php'); // через 5 сек. вы перейдете на стр. about.php

Один из последних НТТР-заголовков называется content type
header (НТТР-заголовок формата содержания), потому что
он контролирует тип формата содержания, передаваемого сервером.
header('Content-Type: text/plain'); 
echo 'Этот <strong>text</strong> не будет выделен жирным шрифтом';
//http://php.net/manual/ru/function.header.php



Слабым местом, которое используется в атаке ,Внедрение SQL-кодаi.>, является отсутствие
проверки введенных в форму данных на наличие опасных символов. Опасными символами
являются любые символы, которые потенциально могут изменить содержание SQL-запроса.
К ним, в частности, относятся запятые, кавычки, двойные дефисы. даже символы пробелов
в конце данных могут представлять опасность.
mysqli_real_escape_string () ,экранирующей потенциально опасные символы, которые могут
неблагоприятно повлиять на выполнение SQL-запроса.


...................
When we are coding large applications sometimes we do the outputs before redirection due to which the output does not get stored in the buffer and the header function does not catch the URL due to which the redirection does not work.

So to solve this problem we need to store the output in a buffer and need to flush that buffer at the end of the code.

So we use a php function called ob_start() to buffer all the output of our php code and ob_end_flush() to flush all the output when the execution of the whole code is done.

So whenever you are facing such problem like your header() function is not redirecting then just follow this simple rule to solve it. Below is the code to show how to use ob_start()  and ob_end_flush().


<?php
ob_start();
 
//more code
header("Location:URL");
 
ob_end_flush();
?>

Just put the ob_start() function in the starting of your code and ob_end_flush() in the end. This will definetly solve your problem.





//////////////Обработка изображений и GD 
http://php.net/manual/ru/book.image.php

...................................

Для начала убедитесь, что у Вас установлено PHP как минимум версии 5.2.4, используя встроенную функцию phpinfo() или набрав 
php -v в командной строке. Имейте в виду, что Вы можете иметь 2 установленных версии PHP: одну для командной строки, и другую для веб.


/////////////////////////////////

HTML-формы

Автор: Мухаметшин Д.Ф. (BossIT@yandex.ru)

Зачастую на Web – сайтах можно встретить страницы с размещенными на них HTML - формами. Веб-формы – удобный способ получения информации от посетителей вашего сайта. Пример тому – гостевая книга, – которая обеспечивает обратную связь с посетителями и разработчиками сайта. Формы так же удобны и для разработчиков сайта при разработке CMS, которая позволяет поддерживать главное свойство сайта - актуальность. Данная статья посвящена основам создания HTML-форм, их обработке и способам передачи данных из экранных форм в PHP-сценарии.

1) Создание простой формы

Теги <form> и </form> задают начало и конец формы. Начинающий форму тег <form> содержит два атрибута: action и method. Атрибут action содержит адрес URL сценария, который должен быть вызван для обработки сценария. Атрибут method указывает браузеру, какой вид HTTP запроса необходимо использовать для отправки формы; возможны значения POST и GET.

Замечание

Главное отличие методов POST и GET заключается в способе передачи информации. В методе GET параметры передаются через адресную строку, т.е. по сути в HTTP-заголовке запроса, в то время как в методе POST параметры передаются через тело HTTP-запроса и никак не отражаются на виде адресной строки.

<form method="post" action="../admin/add_story.php"> 

</form>
2) Флажок (checkbox)

Флажки checkbox предлагаю пользователю ряд вариантов, и разрешает выбор нескольких из них.

<input name="Имя переключателя" type="Тип" value="Значение">
Группа флажков состоит из элементов <input>, имеющих одинаковые атрибуты name и type(checkbox). Если вы хотите, чтобы элемент был отмечен по умолчанию необходимо пометить его как checked. Если элемент выбран, то сценарию поступит строка имя=значение, в противном случае в обработчик формы не придет ничего, т.е. не выбранные флажки вообще никак не проявляют себя в переданном наборе данных.

Пример:

<input name="mycolor" type="checkbox" value="red" checked>Красный(выбран по умолчанию) 
<input name="mycolor" type="checkbox" value="blue">Синий 
<input name="mycolor" type="checkbox" value="black">Черный 
<input name="mycolor" type="checkbox" value="white">Белый
3) Переключатель(radio)

Переключатели radio предлагают пользователю ряд вариантов, но разрешает выбрать только один из них.

<input name="Имя переключателя" type="Тип" value="Значение">
Переключатель (radio) имеет атрибуты name, type и value. Атрибут name задает имя переключателя, type задает тип radio, а атрибут value задает значение. Если пользователь выберет переключатель, то сценарию будет передана строка имя=значение. При необходимости можно указать параметр checked, который указывает на то, что перключатель будет иметь фокус (т.е. будет отмечен по умолчанию) при загрузке страницы. Переключатели также можно объединять в группы, для этого они должны иметь одно и тоже имя.

Пример:

  <input name="mycolor" type="radio" value="white"> Белый 
  <input name="mycolor " type="radio" value="green" checked> Зеленый (выбран по умолчанию) 
  <input name="mycolor " type="radio" value="blue"> Синий 
  <input name="mycolor " type="radio" value="red"> Красный 
  <input name="mycolor " type="radio" value="black"> Черный
4) Кнопка сброса формы(Reset)

<input type="Тип" name="Имя кнопки" value="Надпись на кнопке">
При нажатии на кнопку сброса(reset), все элементы формы будут установлены в то состояние, которое было задано в атрибутах по умолчанию, причем отправка формы не производиться.

Пример:

<input type="reset" name="Reset" value="Очистить форму">
5) Выпадающий список (select)

Тэг <select> представляет собой выпадающий или раскрытый список, при этом одновременно могут быть выбраны одна или несколько строк.

Список начинается с парных тегов <select></select>. Теги <option></option> позволяют определить содержимое списка, а параметр value определяет значение строки. Если в теге <option> указан параметр selected, то строка будет изначально выбранной. Параметр size задает, сколько строк будет занимать список. Если size равен 1, то список будет выпадающим. Если указан атрибут multiple, то разрешено выбирать несколько элементов из списка(при size = 1 не имеет смысла).

<select name="Имя списка" size = “Размер” multiple> 
<option value=”Значение”>Отображаемый текст в списке</option> 
</select>
При передаче данных выпадающего списка сценарию передается строка имя=значение, а при раскрытом списке передается строка имя=значение1&имя=значение2&имя=значениеN.

6) Текстовое поле (text)

Позволяет пользователям вводить различную информацию.

<input type="Тип" name="Имя поля" size="Размер" maxlength="Макс. количество символов">
При создании обычного текстового поля размером size и максимальной допустимой длины maxlength символов, атрибут type принимает значение text. Если указан параметр value, то поле будет содержать отображать value-текст. При создании поля не забывайте указывать имя поля, т.к. этот атрибут является обязательным.

Пример:

<input type="text" name="txtName" size="10" maxlength="5" value="Текст по умолчанию">
7) Поле для ввода пароля (password)

Полностью аналогичен текстовому полю, за исключением того что символы, набираемые пользователем, не будут отображаться на экране.

Пример:

<input type="password" name="txtName" size="10" maxlength="5">
8) Многострочное поле ввода текста (textarea)

Многострочное поле ввода текста позволяет отправлять не одну строку, а сразу несколько. По умолчанию тег создает пустое поле шириной в 20 символов и состоящее из двух строк.

<textarea name="Имя поля" cols="Ширина поля " rows="Число строк">Текст</textarea>
Многострочное поле ввода текста начинается с парных тегов <textarea></textarea>. Тэг name задает имя многострочного поля. Также можно указать ширину поля(cols) и число строк(rows). При необходимости можно указать атрибут readonly, который запрещает редактировать, удалять и изменять текст, т.е. текст будет предназначен только для чтения. Если необходимо чтобы текст был изначально отображен в многострочном поле ввода, то его необходимо поместить между тэгами <textarea></textarea>.

Пример:

<textarea name="txtArea" cols="15" rows="10" readonly> Текст, который изначально будет отображен в многострочном поле ввода и который нельзя изменять, т.к. указан атрибут readonly </textarea>
9) Скрытое текстовое поле

Позволяет передавать сценарию какую то служебную информацию, не отображая её на странице.

<input name="Имя" type="Тип" value="Значение">
Скрытое поле начинается с тега <input>, атрибуты которого являются name, type и value. Атрибут name задает имя поля, type определяет тип поля, а атрибут value задает значение поля.

Пример:

<input name="email" type="hidden" value="spam@nospam.ru">
10) Кнопка отправки формы (submit)

Служит для отправки формы сценарию.

<input type="Тип" name="Имя кнопки" value="Текст кнопки">
При создании кнопки для отправки формы необходимо указать 2 атрибута: type=“submit” и value=”Текст кнопки”. Атрибут name необходим если кнопка не одна, а несколько и все они созданы для разных операций, например кнопки "Сохранить", "Удалить", "Редактировать" и т.д. После нажатия на кнопку сценарию передается строка имя=текст кнопки.

11) Кнопка для загрузки файлов (browse)

Служит для реализации загрузки файлов на сервер. Объект browse начитается с парных тегов <form></form>. Начинающий тэг <form> содержит необходимый атрибут encrypt. Атрибут encrypt принимает значение multipart/form-data, который извещает сервер о том, что вместе с обычной информацией посылается и файл. При создании текстового поля также необходимо указать тип файла – “file”.

<form enctype="multipart/form-data" action="upload.php" method="post"> 
Загрузить файл: <input name="my_file" type="file"> 
  <input type="submit" value="Отправить"> 
</form>
12) Рамка (fieldset)

Объект fieldset позволяет вам нарисовать рамку вокруг объектов. Имеет закрывающий тэг </fieldset>. Заголовок указывается в тэгах <legend></legend>. Основное назначение объекта – задавание различных стилей оформления.

Пример:

<fieldset> 
<legend>Программное обеспечение(заголовок рамки)</legend> 
Текст, который будет помещен внутри рамки.</fieldset>
Обработка форм

Все данные, которые вы хотите получить из HTML-формы в PHP сценарий обрабатываются с помощью суперглобальных массивов $_POST или $_GET, в зависимости от указанного в атрибуте method метода передачи данных.

Задача: Вам необходимо получить данные из текстового поля и многострочного поля ввода и передать их сценарию.
Решение: Необходимо создать HTML форму и PHP – сценарий для обработки формы.

Обсуждение:

Создадим два файла: form.html и action.php. В файле form.html будет содержаться html-форма с текстовым полем mytext и текстовой областью msg:

<form action="action.php" name="myform" method="post"> 
   <input type="text" name="mytext" size="50"> 
  <textarea name="msg" cols="20" rows=”10” ></textarea> 
    <input name="Submit" type=submit value="Отправить данные"> 
</form>
В этой html-форме нас интересует 3 атрибута: action который указывает путь к обработчику формы, имя текстового поля (mytext) и имя многострочного поля вода (msg). Также в форме присутствует кнопка, при нажатии на которую происходит передача данных.

После того как html-форма готова нам необходимо создать обработчик формы action.php:

<?php 
  $text =  ($_POST['mytext']; 
  $msg =  ($_POST['mytext']; 
  echo $text; // Выводим содержимое текстового поля 
?>
После того как мы введем любые значение в текстовые поля и нажмем на кнопку "Отправить данные" html-форма отправить значения сценарию action.php. 
После этого в переменных $text и $msg будут содержаться значения текстового поля и многострочного поля ввода соответственно, значения которых взяты из суперглобальных переменных $_POST.

Если вы хотите, чтобы в многострочном текстовом поле соблюдалось html-форматирование, то используйте функцию nl2br():

<?php 
  $text = nl2br($_POST['mytext']); 
?>
Задача: Пусть необходимо создать выпадающий список с годами с 2000 по 2050.
Решение: Необходимо создать HTML форму c элементом SELECT и PHP – сценарий для обработки формы.

Обсуждение:

Для начала создадим два файла: form.html и action.php. В файле form.html будет содержаться html-форма с выпадающим списком. Причем значения в списке можно указать двумя способами:

I. Ввод данных вручную:

<select class="input" type=text name=years> 
<option value='2000'>2000</option> 
<option value='2001'>2001</option> 
<option value='2002'>2002</option> 
…………………………………………… 
<option value='2050'>2050</option> 
</select>
II. Ввод данных через цикл:

<select class="input" type=text name=years> 
<?php 
$year = 2000; 
for ($i = 0; $i <= 50; $i++) // Цикл от 0 до 50 
{ 
  $new_years = $year + $i; // Формируем новое значение 
  echo '<option value='.$new_years.'>'.$new_years.'</option>'; //Формируем новую строчку 
} 
?> 
</select>
Как видно, второй пример с циклом, более компактный. Думаю, не стоит приводить скрипт обработчика данной формы, потому что он обрабатывается точно так же как текстовое поле, т.е. значения списка можно извлечь из суперглобального массива $_POST.

Задача: Загрузка файла на сервер
Решение: Необходимо создать HTML форму и PHP – сценарий для обработки файла.

Описание:

Создадим HTML-форму для отправки файла на сервер.

<FORM ENCTYPE="multipart/form-data" ACTION="action.php" METHOD=POST> 
<INPUT NAME="myfile" TYPE="file"> 
<INPUT TYPE="submit" value="Передать файл"> 
</FORM>
В данной html-форме присутствует элемент browse, который открывает диалоговое окно для выбора файла для загрузки на сервер. При нажатии на кнопку "Передать файл", файл передается сценарию-обработчику.

Затем необходимо написать сценарий обработчик action.php. Перед написание обработчика необходимо определиться в какой каталог мы будет копировать файл:

<?php 
if(isset($_FILES["myfile"])) // Если файл существует 
{ 
  $catalog = "../image/"; // Наш каталог 
  if (is_dir($catalog)) // Если такой каталог есть 
  { 
    $myfile = $_FILES["myfile"]["tmp_name"]; // Времменый файл 
    $myfile_name = $_FILES["myfile"]["name"]; // Имя файла 
    if(!copy($myfile, $catalog)) echo 'Ошибка при копировании файла '.$myfile_name // Если неудалось скопировать файл 
  } 
  else mkdir('../image/'); // Если такого каталога нет, то мы его создадим 
} 
?>
Замечание

Если вы доверяете пользователям закачивать на ваш сервер любые файлы, нужно быть предельно осторожным. Злоумышленники могут внедрить «нехороший» код в картинку или файл и отправить на сервер. В таких случаях нужно жестоко контролировать загрузку файлов.

Данный пример демонстрирует создание каталога и копирование файла в этот каталог на сервер.

Также хотел бы продемонстрировать пример с элементом checkbox. Этот элемент немного отличается от других элементов тем, что если не один из элементов checkbox’a не выбран, то суперглобальная переменная $_POST вернет пустое значение:

<FORM ACTION="file.php" METHOD=POST> 
<input name="mycolor" type="checkbox" value="blue">Синий 
<input name="mycolor" type="checkbox" value="black">Черный 
<input name="mycolor" type="checkbox" value="white">Белый 
<input name="Submit" type=submit value="Выбрать"> 
</FORM>
<?php 
  if (!empty($_POST['mycolor'])) echo $_POST['mycolor']; // Если выбран хоть 1 элемент 
  else echo "Выберите значение"; 
?>

//////////////////////////////////////////////

	<!DOCTYPE html>
	<html>
	  <head>
		<title>hello, world</title>
	  </head>
	  <body>
		hello, world
	  </body>
	</html>
<?
for (initializations; condition; updates)
{
// do this again and again
}
• But now we add an additional loop, called a foreach loop, that lets us iterate over
an array without worrying about the details of indices:
foreach ($numbers as $number)
{
// do this with $number
}

• We can declare an array in PHP like this:
$numbers = [4, 8, 15, 16, 23, 42]

$quote = ["symbol" => "FB", "price" => "79.53"];           //associative arrays
# Each key, value pair is indicated by "key" # "value" .

# Any PHP file needs to start with the syntax <?php and end with ?> so the    // <?
computer knows to interpret everything between these tags as PHP code.

# We don’t need to run make hello on this, because PHP is not a compiled
language like C - it’s an interpreted language, meaning that it’s not compiled
into machine code, but rather passed as input to an interpreter, a program that
understands PHP code line by line.

# Implementing a hash table in PHP is just $table = []; , because a hash table
can be thought of as an associative array where the keys are the words and the
values are true to indicate that the word is present in the dictionary.

# Interpreted languages in general are going to be slower than compiled languages
like C, because the interpreter has to read them line by line, and so the conversion
to machine code is happening at the same time as the program running.


# Interpreted languages in general are going to be slower than compiled languages
like C, because the interpreter has to read them line by line, and so the conversion
to machine code is happening at the same time as the program running.

# Now let’s do the work of actually sending emails to all these addresses we’ve
constructed:

// instantiate mailer
$mail = new PHPMailer();
// configure mailer
// http://phpmailer.worxware.com/index.php?pg=methods
// http://phpmailer.worxware.com/index.php?pg=properties
// https://www.google.com/settings/u/0/security/lesssecureapps
$mail->IsSMTP();
$mail->Host = "smtp.gmail.com";
$mail->Password = "TODO";
$mail->Port = 587;
$mail->SMTPAuth = true;
$mail->SMTPDebug = 1;
$mail->SMTPSecure = "tls";
$mail->Username = "TODO";
// set From:
$mail->SetFrom("bot@cs50.net");
// set body
$mail->Body = "Miss you! love, CS50 Bot";
// iterate over email addresses
for ($i = 0, $n = count($addresses); $i < $n; $i++)
{
// add email address to To: field
$mail->addAddress($addresses[$i]);
// send email
if ($mail->Send())
{
print("Sent text #{$i}.\n");
}
else
{
print($mail->ErrorInfo);
}
// clear To: field
$mail->ClearAddresses();
}
?>
..........................................
<!DOCTYPE html>
<html>
<head>
<title>Frosh IMs</title>
</head>
<body>
<?php if (empty($_POST["name"]) || empty($_POST["comfort"])|| empty($_POST["dorm"])): ?>
You must provide your name, comfort, and dorm!
Go <a
href="froshims-2.php">back</a>.
<?php else: ?>
You are registered!
(Well, not really.)
<?php endif ?>
</body>
</html>

$_POST is an
example of a superglobal variable containing the values that were passed to
your backend using the HTTP POST method.
.................................
<?php
  date_default_timezone_set('US/Eastern');
 $time = date('H:i:s',time());
?>
<!DOCTYPE html>
	<html>
	  <head>
		<title>Current time in Cambridge</title>
	  </head>
	  <body>
		The current time in Cambridge  is <?= $time ?>.
              <pre><?php print_r($_POST); ?></pre>
	  </body>
	</html>
# <?= ... ?> is just syntactic sugar for <?php echo(...) ?> , where echo is
merely a variant of print . This makes our print statements significantly more
concise.
........................
<?php
• MVC stands for Model, View, Controller, and our code will be split up into model code,
view code, and controller code.
• We can oversimplify as follows:
# Controller code is the brains of your site - the loops, conditions, etc, the actual logic.
# View code is the aesthetics of your site - what the user sees.
# Model code is data- and database-related, and we’ll talk more about this part later.


<?php require("helpers.php"); ?>
 <?php renderHeader(["title" => "CS50"]); ?>
	<ul>
	<li><a href="lectures.php">Lectures</a></li>
	<li><a href="http://cdn.cs50.net/2015/fall/lectures/0/w/syllabus/cs50/
	cs50.html">Syllabus</a></li>
	</ul>
 <?php renderFooter(); ?>

<?
# Now instead of using require to insert the header and footer, we’re require ing
just a single file, called helpers.php (which just contains a bunch of helper
functions that we’ve written).
# In line 3 and line 10, we’re calling PHP functions renderHeader() and
renderFooter() , both of which we wrote in helpers.php .

# The argument to renderHeader() is an associative array, if you’ll recall from
last week - we’re passing in a single key-value pair, where the key is "title" and the
value is "CS50".
# Let’s look at what’s actually happening in renderHeader() in helpers.php
11
:
/**
* Renders header.
*/
function renderHeader($data = [])
{
	extract($data);
	require("header.php");
}
# renderHeader() takes an argument called $data , which has a default
value of an empty array.
# The extract function takes our $data array and turns it into variables that
we can use in header.php .

# Here’s our new version of header.php

<!DOCTYPE html>
 <html>
  <head>
   <title><?= htmlspecialchars($title) ?></title>
  </head>
  <body>
   <h1><?= htmlspecialchars($title) ?></h1>

# <?= ... ?> is just syntactic sugar for <?php echo(...) ?> , where echo is
merely a variant of print .
<?
# We just want to print the title, stored in $title , but we run it through the function
htmlspecialchars to make sure it doesn’t contain any characters or syntax
that will break our site.


<?php
/**
* Renders template.
*/
function render($template, $data = [])
{
$path = $template . ".php";
if (file_exists($path))
{
extract($data);
require($path);
}
}
?>
# We can pass this function "header" or "footer" as its $template argument,
where we think of a template as a blueprint for the HTML we want to output, but
with some different values substituted in.
# We’ll construct the path to the file by concatenating the argument passed as
$template with the .php file ending. In PHP, we use a period ( . ) to
concatenate strings - so much easier than concatenating strings in C, where we
have to worry about allocating enough space in memory for the combined string.

<?php require("helpers.php"); ?>
<?php render("header", ["title" => "CS50"]); ?>
<ul>
<li><a href="lectures.php">Lectures</a></li>
<li><a href="http://cdn.cs50.net/2015/fall/lectures/0/w/syllabus/
cs50/cs50.html">Syllabus</a></li>
</ul>
<?php render("footer"); ?>


////////////////
 <?php
  foreach($_GET as $key => $value)
  {
	print("<p>{$key}: {$value}</p>");
  
}
/////////////////
<table>
 <?php foreach($_GET as $key => $value): ?>
	<tr>
	  <td class = "key"><?= $key ?></td>
	  <td class = "value"><?= $value ?></td>
	</tr>
 <?php endforeach; ?>
</table>
////////////////////

#!/usr/bin/env php    //путь к программе в inux
<?php
.....
?>

<?
# This is called a shebang line (because it starts with a # , or sharp, and a ! , or
bang), and it tells the computer what program to use to run the rest of the file by
giving it a path to a program on the Linux system.
# /usr/bin/env is the path to a program that keeps track of where other programs
are on the system, so this shebang line tells the computer to find the PHP interpreter
for us and use it to interpret this file.


// file.csv     файл Excel






////////////////
Найди до вызова условия, строку где переопределяется массив $page['data']='xxx';// это и вызывает ошибку в условии
И замени на $page['data']['active'], или убери переопределение $page['data']='xxx'.
Или в условии проверяй значение одномерного массива $page['data'], без ключа active ( см. по факту логики кода).
Или перейди на php 5.3
Код PHP:
 
//создаем ошибку
$page['data']['active']='данные';//Многомерный ассоциативный массив- определяем значение
$page['data']='xxx';//переопределение массива в одномерный - определяем строковое значение
echo $page ['data'];//получаем значение  одномерного массива без ошибки
echo $page['data']['active'].' Illegal string offset - ошибка - неопределенная строка.';//получаем ошибку
Что вызывает ошибку Illegal string offset в PHP 5.4? 
Пытаемся обратиться к многомерному ассоциативному массиву $page['data']['active'] , получаем ошибку Illegal string offset, потому что, по ключу data расположены строковые значения , а ключа ['active'] в массиве $page не существует. 
Так без ошибок:
Код PHP:
 
echo '<p>норма---<p>';
$page2['data']['active']='норма';//Многомерный ассоциативный массив- определяем значение
$page2['data']['active']='и так норма';// переопределяем значение
echo $page2['data']['active'];//получаем значение
 


//////////
function reverser(string $sentence): string {                            //codewars      php7
  return join(' ',array_map('strrev',explode(' ',$sentence)));
}
///////////////

Включаем типизацию
declare(strict_types = 1)

............................
Null coalescing operator (oъединенный null оператор)

	possiblyNullValue ?? valueIfNull
Возвращ. левый .. если не null, в противном .. правый

$quux = $_POST['quux'] ?? $_GET['quux'] ?? $quuxDefault;
// Equivalent to:
if (isset($_POST['quux'])) {
    $quux = $_POST['quux'];
} elseif (isset($_GET['quux'])) {
    $quux = $_GET['quux'];
} else {
    $quux = $quuxDefault;
}


$pageTitle = $suppliedTitle ?? 'Default Title';

// Equivalent to:
$pageTitle = (isset($suppliedTitle) ? $suppliedTitle : 'Default Title');


///////////////////
Комбинированный оператор сравнения (<=>)
Он работает как strcmp() и version_compare(), то есть возвращает -1 если левый операнд меньше, чем правый, 0 - если они равны и 1 - если левый операнд больше. Основное отличие заключается в том, что он применим к любым двум операндам.

/ Pre Spacefaring^W PHP 7
function order_func($a, $b) {
   return ($a < $b) ? -1 : (($a > $b) ? 1 : 0);
}

// Post PHP 7
function order_func($a, $b) {
   return $a <=> $b;
}





