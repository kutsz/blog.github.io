<?
http://php.net/manual/ru/book.regex.php
http://php.net/manual/ru/book.pcre.php
http://ua2.php.net/manual/ru/regexp.reference.delimiters.php        разделители

 В каждом регулярном выражении есть как
минимум одна управляющая конструкция.

Управляющая конструкция может содержать обычные символы, управляющие ин-
струкции (о них отдельно), а также псевдосимволы — невидимые символы (конец
строки, перевод каретки, табуляция и т. д.).

К простым символам относятся только буквы и цифры, т. е. A – Z , a – z , 0 – 9 .  //TODO
Символы . ? * + {} [] | $ ^ называются управляющими.

Если нужно найти строку, содержащую управляющие символы, то перед каждым управляющим сим-
волом нужно добавить обратный слэш, например:
\[text\]
Данное выражение будет соответствовать строке [text] . Но, согласно синтаксису
PHP, перед символом \ требуется указывать еще один обратный слэш, поэтому по-
лучаем следующее выражение, которое нужно передать PHP-функции:
\\[text\\]

Теперь поговорим об управляющих символах. Начнем с точки. Точка заменяет
один произвольный символ. Например, регулярному выражению a.c соответствуют
строки:
aac, abc, acc ... azc, aAc ... aZc, a0c ... a9c .

Как видите, на месте точки может стоять любой символ. Если вы хотите уточнить,
какой именно символ должен стоять на месте точки (например, цифра), тогда ис-
пользуется следующее выражение:
a[0123456789]c
Все просто: нужно в квадратных скобках перечислить допустимые символы. Прав-
да, запись [0123456789] не очень компактна, поэтому ее лучше заменить на [0-9] .
Аналогично, можно указать последовательность букв, например: [a-e] , [a-z] ,
[A-Z] . Задать все буквы (строчные и прописные) тоже просто — [a-zA-Z] . Всем
алфавитно-цифровым символам соответствует выражение [a-zA-Z0-9_] .

Внутри квадратных скобок, кроме символов и диапазонов символов, допустимы
макросы
Макрос                           Соответствие

[:alpha:]                        Буква
[:digit:]                        Цифра
[:alnum:]                        Буква или цифра
[:space:]                        Пробел или пробельный символ
[:blank:]                        То же самое, что и [:space:], но учитываются также символы
                                  с кодами 0 и 255
[:cnrtl:]                        Любой управляющий символ
[:lower:]                        Строчная буква
[:upper:]                        Прописная буква
[:print:]                        Любой печатаемый символ
[:punct:]                        Знак пунктуации (точка, запятая и т. д.)
[:xdigit:]                       Цифра или прописная буква (A–Z)

ПРИМЕЧАНИЕ
Обратите внимание, что макрос может встречаться только внутри квадратных скобок. На-
пример, выражение [[:alpha:]] — правильное, а [:alpha:] нет.

Если вы ищете все, кроме какого-то символа (или каких-то символов), тогда можно
использовать операцию отрицания ^ :
[^0-9]
Данное выражение означает: все, кроме цифр.
...................
Управляющие конструкции


Квантификатор — это символ, использующийся для уточнения значения симво-
лов, которые идут перед ним. В основном квантификатор применяется для задания
повторения некоторых символов.

Вот небольшой пример квантификатора: 0*7 .Звездоч-
ка * означает "ноль или более символов".  7 (ноль символов нуля), 07 , 007 , 0007 и т. д.

Квантификатор + задает одно или более повторений ( * задает ноль или более по-
вторений).
Квантификатор ? задает ноль или одно повторение.
Квантификаторы * , + и ? называются простыми. Сложные квантификаторы позво-
ляют указать точное число повторов символов. Вот примеры сложных квантифика-
торов:
 0{n,k} — символ 0 может встречаться от n до k раз;
 0{n} — символ 0 должен встречаться n раз;
 0{n, } — символ 0 может встречаться n или более раз.
П РИМЕЧАНИЕ
Числа n и k принадлежат диапазону 0–255.

Альтернативный оператор |
Альтернативный оператор | позволяет задать альтернативные группы символов.
Рассмотрим несколько примеров (как говорится, лучше один раз увидеть):
 A|b|c — эквивалентно выражению [Abc] ;
 joker|alex — данному выражению соответствуют строки, содержащие подстро-
ку joker или подстроку alex .

Скобки
Предположим, что нам нужно найти подстроки Film1 , Film2 или Film3 . Это можно
сделать с помощью альтернативного оператора: Film1|Film2|Film3 . Данное выра-
жение можно немного сократить, а именно вынести общую часть за скобки:
Film(1|2|3) . Ведь так компактнее?

Псевдосимволы
Псевдосимволы служат для обозначения определенной позиции в строке:
 ^ — начало строки;
 $ — конец строки;
 [[:<:]] — начало слова;
 [[:>:]] — конец слова.
Примеры:
 ^a — все строки, которые начинаются с буквы a ;
 ddd$ — все строки, которые заканчиваются строкой ddd .

.................................................

Практическое использование
RegEx-функций

bool ereg(string $expression, string $str [, list &$Matches])

Функция сопоставляет регулярное выражение, заданное параметром $expression ,
строке $str . Если строка соответствует выражению (есть совпадения), тогда функция
возвращает true , в противном случае — false .В список Matches , если он задан, за-
носятся отдельные совпадения, если они есть.
>>>>>>>>>>>>>>>>>>>>>>>>


<?php

echo 'Front Controller ....'.date('l jS \of F Y h:i:s A').'<br>';
echo 'your request:'.$_SERVER['REQUEST_URI'];
echo "<br>...................<br>";

// ////.....................регулярные выражения..............

// Format: dd-mm-yyyy
$string = '21-11-2015'; // день-месяц-год
// Год 2015, месяц 11, день 21
$pattern = '/([0-9]{2})-([0-9]{2})-([0-9]{4})/';
$replacement = 'Год $3,месяц $2,день $1'; // $1 - первая подмаска([0-9]{2}) ,2я - ([0-9]{2}), 3я - ([0-9]{4})
echo preg_replace($pattern, $replacement, $string );


 preg_replace — Выполняет поиск и замену по регулярному выражению.
 Выполняет поиск совпадений в строке string с шаблоном pattern и заменяет их на replacement

 
echo "<br>";
// Month: 11, Day: 21, Year: 2015
$replacement1 = 'Month: $2, Day: $1, Year: $3';
echo preg_replace($pattern, $replacement1, $string );
echo "<br>...................<br>";

////////////////////////////////////////////////////////

$string = 'Ученик сидит за партой';

$pattern = '/Ученик/';
$result = preg_match($pattern,$string); // 1 если найдено и 0 если нет,false в случае ошибки
var_dump($result);  // int(1)
echo "<br>...................<br>";
////////////////////////////////////////////////////////
///

$string = 'Ученик закончил школу в 2000 году.Стал студентом в 2002.';

// $pattern = '/2000/';
// $pattern = '/200[0-5]/'; // [] задает диапазон поиска для одного символа
//$pattern = '/200[1,5,8]/'; // [] задает диапазон поиска для 1го символа (или 1,или 5, или 8)
// 2001  2005  2008 
// 
// Поиск от 0000 - 9999
 // $pattern = '/[0-9][0-9][0-9][0-9]/'; 
 
//квантификаторы - помогаут описать повторяющиеся символы в строке
$string = 'Apples and oranges ppp';

$pattern = '/p{2}/';// '/p/'  '/pp/'   {2} - квантификатор,указ.что мы ищем на 2 или (группа)
// символов которые находятся перед ним (в данном сл. 'p' ) 
// p{3,5} от 3 до 5 симв. подряд
// p{1,} от 1 и более
$string = 'Apples and oranges ppp 222';

$pattern = '/[0-9]{1,2}/';// ищет цифры сост. из от 1 до 2 знаков
// [0-9]+   ищем любое кол-во цифр больше одной    98797239893
// 
$result = preg_match($pattern,$string); // 1 если найдено и 0 если нет,false в случае ошибки
var_dump($result);  // int(1)
echo "<br>...................<br>";


///// http://php.net/manual/ru/regexp.reference.repetition.php ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

Регулярное выражение является шаблоном (набором правил), на соответствие
которому мы проверяем строку текста.

/^\d\d\d\d$/         ~           /^\d{4}$/ - 
четыре любых цифр
......................Метасимволы
^ - начало строки, чтобы указ. что соотв. должно быть в начале стр. // /^\d{3}/ ~ "300 приложений"   
    Но не соответствует  "Мы получили300 приложений" 
$ - конец строки  //  /^\w{7}\s\d{3}$/  ~ "Нянечка 411"
    Но не соответствует "Очень хорошая нянечка 411"

\d - этот метасимвол соответствует одной цифре - любой цифре от 0 до 9  //        \d\d  ~  \d{2}
\s - соотв. одному пробельному символу (символ горизонтальной и вертикальной табуляции и символ перевода строки)// \s\s ~ \s{2}
\w - соотв. любому алфавитно-цифровому символу (одному): a-z,A-Z,а-я,А-Я,0-9
. - метасимвол 'точка' - любой символ, кроме символа перевода строки (соотв. и букве, и цифре, а также символу пробела и
    символу табуляции)
Метасимволы предост. возможность описывать элементы шаблонов в рег.выраж.
Примеры:
/^\d{3}\s\d{7}$/                  555 7374751
/^\d{3}\s\d{3}\s\d{4}$/           555 238 4652
/^\d{3}\d{3}-\d{4} $/            555135-4652
/^\d{3}\s\w\w\s\w{5}$/           555 me ninja
...................Квантификатор
{min,max}  - определяют диапазон чисел возможных повторений символа или мeтасимвола, предшествующего квантификатору
/^\d{2,4}$/ - цифра может повторятся в строке 2,3 или 4 раза подряд.

+ - может повторятся в строке один и более раз.
? - может повторятся в строке один и более раз, или вообще не встречаться ни разу.

Квантификатор опрделяет сколько раз может появлятся в строке символ или метасимвол или их группа.
/^\d{3}-\d{3}-\d{4}(-\d{4})?$/  // (-\d{4}) гр. метасимволов закл. в () , квантификатор ? делает необязател. для соотв.

..................Символьный класс []
Если вы добавите в начале группы символов знак вставки (^), то тем самым установите соответствие для любого символа,
не включенного в символьный класс.

[0-2] Этому символьному классу соответствует любая из цифр О,1 или 2.
[A-D] Этому символьному классу соответствует любая из букв А, В, С или D
[^b-f]  (^) означает "не соответствует"
Символ вставки имеет разное значение, когда
используется в символьном классе и вне его.
Вместо того чтобы соответствовать началу
строки, как это происходит при использовании вне класса, в символьном классе он означает
"соответствует всем символам, кроме перечисленных в классе"

Символьный класс - это шаблон соответствия одному символу.

Примеры:

/^[3-7]{4}/ // 3457
/^([A-Z]\d){2}$/ // D5H8
______________________________________________________
/^\(?[2-9]\d{2}\)?[-\s]\d{3}-\d{4}$/
\(?  необязательная откр. круглая скобка,которая может появиться ноль или один раз...
[-\s]      ...дефис или символ пробела...
______________________________________________________
/[\(\)\-\s]/
\( - откр.(
\) - закр.)
\-   -  дефис
\s - симв. пробела
_______________________________________
[qksienchf]  - соотв. 1й строчной букве
[a-zA-Z] - соотв. 1й строчной или прописной букве
[0-9] - эквивалент метасимвола \d

Разве мы не должны вставлять запятые или пробелы между симвonами или диапаэонами символов в символьном классе?
Нет, если вы сделаете это, эти дополнительные символы
будут расценены интерпретатором регулярных выражений
как часть набора символов в символьном классе и будут также
использоваться для поиска соответствия.

/[qjdiweksoJIHTLK]+/  будет соответствовать одной или нескольким строчным или прописным гласным, следУЮЩИМ подряд

А если вы хотите, чтобы квантификатор относился к группе символов,
которая не является символьным классом, вы можете заключить
ее в круглые скобки, указывая таким образом, что эту группу в данном
контексте следует рассматривать как одно целое. Например, реГУЛЯРНОе
выражение /(привет)+/ будет соответствовать одному слову "привет"
В строке или нескольким таким словам, следующим подряд.

Что если мне необходимо задать два разных слова, имеющих
близкое значение, скажем, «кетчуп» И «соус»?
ВЫ можете использовать вертикальную черту (|), чтобы указать
несколько слов на выбор. Поэтому регулярное выражение
/(кетчуп|соус|подливка)/ будет соответствовать любому из этих слов.

Если у вас возникнет необходимость использовать в регулярном выражении
зарезервированные символы в их прямом значении, а не в качестве метасимволов
или квантификаторов, вы должны экранировать их путем установки непосредственно
перед ними символа обратной наклонной черты (\).








____________________________________

$new_phone = preg_replace('\[/(\)\-\s]/', '', $phone);
 ###-###-####                                             
 ### ###-####
                                 ##########
(###)-###-####
(###) ###-####
_________________________________________________________
LocalName@DomainPrefix.DomainSuffix   // эл. адрес
Префикс ДOMeHa.Суффикс ДOMeHa    // суффиксы   .соm, .edu, .org, .gov, .bу, .ru

checkdnsrr()
Вместо того чтобы делает возможным отслеживать все возможные имена доменов и при 
появлении новых имен корректировать свой код, мы можем проверять доменную часть адреса
электронной почты (ту его часть, которая расположена справа от символа @), используя РНР-функцию
checkdnsrr ( ) . Она соединяется с системой доменных имен (DNS) и проверяет достоверность домена.

checkdnsrr('headfirstlabs.com ' )

Если сервер на Windows, эта ф-ция не работает. Использ. нужно   win_checkdnsrr()



////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


Приложение № 3 - О регулярных выражениях.

Автор (участник forum.php.su): Champion 
Источник: forum.php.su
Обсуждение: Обсуждение уроков.

О регулярных выражениях.

Регулярные выражения - мощный гибкий инструмент для синтаксического анализа текста в соответствии с определенным шаблоном. 

Шаблон - строка символов, спецсимволов и модификаторов, описывающих правила, которым должен соответствовать разбираемый текст.


Синтаксис регулярных выражений.

Это раздел о том, из чего состоят шаблоны. 
Любой шаблон должен быть ограничен символами-ограничителями. В качестве таких символов можно использовать любой не буквенно-цифровой символ кроме '\'. 
Не рекомендуется использовать в качестве ограничителей и другие специальные символы, в виду того их использование внутри шаблона станет неудобным. Предпочтительнее всего использовать символ /, потому что он не выполняет никаких специальных функций.
Символ, используемый как ограничитель шаблона внутри шаблона должен экранироваться.
Пример: '/pattern/i' - соответствует строке, в которой есть слово pattern. i - это модификатор. Забегая вперед, скажу, что он означает регистронезависимое сравнение.

1 - Спецсимволы.
Сначала о них, потому что мне будет легче описать остальное.
\ - символ экранирования.
Пример: '/qwe\/rty/' - соответствует строке, в которой есть qwe/try. Символ / мы заэкранировали, после чего он перестал выполнять в данном месте свое специальное значение (он являлся ограничителем шаблона).
^ - символ начала данных.
$ - символ конца данных.
Пример: '/^pattern$/' - Соответствует строке, точно совпадающей с словом pattern. Т.е. с буквы p строка начинается и после n заканчивается.
. - любой символ, кроме перевода строки. Но есть модификатор, при использовании которого перевод строки тоже относится к "любым" символам.
Пример: '/pat.ern/' - Соответствует и строке, содержащей pattern, или patdern, или pat3ern...
[] - внутри этих скобок перечисляются символы, любой один символ из которых может стоять на данном месте. Это называется символьным классом. Спецсимволы, написанные в [] ведут себя немного по-другому. Это я напишу.
Пример: '/pat[aoe]rn/' - под соответствие попадут только строки, содержащие patarn, patorn или patern.
| - Или. Пример ниже.
() - подмаска. 
? - одно или ноль вхождений предшествующего символа или подмаски.
* - любое количество вхождений предшествующего символа или подмаски. В том числе и ноль.
+ - одно или более вхождений.
Пример: '/as+(es|du)?.*r/' - Буква а, потом одна или больше букв s, после этого сочетание es или du может быть один раз, а может м ни разу, потом любое количество любых символов и буква r.
Здесь же скажу про еще одно значения символа ?. Метасимвол звездочка по умолчанию жадный (и другие тоже). Это значит, что в нашем примере вот этой части '.*r' будет соответствовать, например, подстрока asdrfsrsfdr. Как видно, до последней буквы r в нее попало еще две. Вот эту жадность можно выключить. Т.е. шаблон станет соответствовать только подстроке asdr. До первого r. Для этого надо в до того места где необходимо отключить жадность поставит модификатор (?U). Вот еще одно применение символам ? и ().
{a,b} - количество вхождений предшествующего символа или подмаски от а до б. Если б не указан, считается, что верхней границы нет. Например, * - то же самое, что {0,}. ? - то же, что {0,1}. {5,7} - 5,6 или 7 повторений.

a) Спецсимволы внутри символьного класса.
^ - отрицание.
Пример: [^da] - соответствует любому символу кроме d и a.
Пример: [^^] - соответствует любому символу кроме ^.
Пример: [d^a] - соответствует любому символу из перечисленных трёх. [\^da] - то же самое.
В последнем примере, как видно символ стоит не в начале перечисления и свою метафункцию теряет. И экранировать его, кстати, тоже тут не надо.
- - внутри символьного класса означает символьный интервал.
Пример: [0-9a-e] - соответствует любому символу от 0 до 9 и от a до e. Если в символьном классе надо перечислить сам символ дефиса, то следует либо заэранироватьего, либо разместить перед ].
Осторожно в символьном классе надо использовать символ \. Если его поставить перед ], она окажется заэкранирована. Также окажется заэкранированным любой символ, который может быть заэкранирован. Иначе символ \ является обычным символом.
Символ $ тоже является обычным символом внутри символьного класса. И скобки тоже.

б) Символ \. Одна из его функций - снятие специального значения с спецсимволов. А другая, наоборот придание специальных функций обычным символам.
\cx - ctrl + x. На месте x может быть любой символ.
\e - escape.
\f - разрыв страницы.
\n, \r, \t - это нам и так привычно. Перевод строки, возврат каретки и табуляция.
\d - любой символ, означающий десятичную цифру.
\D - любой символ, не означающий десятичную цифру.
\s - любой пробельный символ.
\S - не пробельный.
\w - любая цифра, буква или знак подчеркивания.
\W - любой символ, но не \w.
\b - граница слова. Можно использовать вместо \w\W или \W\w или ^\w или \w$
\B - не граница слова. 
Две последние конструкции не соответствуют никаким реальным символам.
\xHH - символ с шестнадцатиричным кодом HH. x - это именно буква икс.
\DDD - символ с восьмиричным кодом DDD. Или ссылка на подмаску.

По поводу ссылки на подмаску: '/([0-9]{2,3}).\1/' - 2 или 3 символа от 0 до 9, потом любая последовательность символов и те же 2 или 3 конкретных символа, которые соответствовали подмаске. То есть строка 'as34sdf34' - подойдет. Там 34, и там. А 'sd34dg32' - нет.
Если анализатор находит \x, он считывает максимальное количество последующих символов, которые могут быть шестнадцатиричным числом. Максимальное - это не больше двух. Если из три, то считается два, если меньше - то сколько есть.
Если анализатор находит \0, он поступает аналогично. Только считывает не 16ричные, а восмеричные цифры. До двух штук. То есть \0\x\0325 означает два символа с кодом ноль, символ с восьмеричным кодом 32 и пятерка.
Если после слеша стоит отличная от нуля цифра, то ту посложнее. Вот напишем такую вещь: \40. Если в шаблоне есть 40 подмасок, то это будет воспринято как ссылка на 40ю подмаску. Сороковую - в десятичной системе счисления. Если же подмасок меньше, то это будет воспринято как символ с восьмеричном кодом 40. 
\040 - всегда символ с кодом и восьмеричным 40.
\7 - всегда ссылка на подмаску.
\13 - в зависимости от ситуации.
В символьном классе возможно указывать символьные диапазоны с помощью из кодов: [\044-\056]
Стоит также отметить, что ссылок на подмаски не может быть больше, чем 99.

2 - Обычные символы.
Это символы, не являющиеся специальными.

3 - Модификаторы. 
Указываются они либо в скобках, например так: (?Ui), либо после закрывающего символа '/pattern/Ui'.
i - регистронезависимость.
U - инвертирует жадность.
m - многострочный поиск.
s - если используется, то символ . соответствует и переводу строки. Иначе она ему не соответствует.
x - заставляет игнорировать все неэкранированные пробельные символы, если они не перечислены в символьном классе. Удобно, когда энтерами и пробелами вы хотите навести удобночитаемость в регулярке.
При использовании модификаторов, можно использовать знак '-' для отключения модификатора. (?m-i) - Bключаем многострочный поиск и отключаем регистронезависимый.
Здесь надо сказать, что все модификаторы что-то включают. Или отключают, если указаны с минусом. А вот U инвертирует. Т.е. если была жадность включена, он выключит без всяких минусов.

4 - Утверждения. 
Утверждения - это проверки касательно символов, идущих до или после текущей позиции сопоставления. Например, \b - это утверждение, что предыдущий символ словесный, а следующий - нет, либо наоборот. Но это как бы встроенное утверждение, а мы тут сейчас свои собственные научимся писать.
Утверждения касательно последующего текста начинаются с (?= для положительных утверждений и с (?! для отрицающих утверждений.
Утверждения касательно предшествующего текста начинаются с (?<= для положительных утверждений и (?<! для отрицающих.
Например, '/(?<!foo)bar/' не найдёт вхождения "bar", которым не предшествует "foo". Т.е. qwefoobar этот шаблон проигнорирует, а asacdbar под него подойдет.
(?<=\d{3})(?<!999)foo совпадает с подстрокой "foo", которой предшествуют три цифры, отличные от "999". Следует понимать, что каждое из утверждений проверяется относительно одной и той же позиции в обрабатываемом тексте.
Утверждения могут быть вложенными, причем в произвольных сочетаниях: (?<=(?<!foo)bar)baz соответствует подстроке "baz", которой предшествует "bar", перед которой, в свою очередь, нет 'foo'. 

a) Условные подмаски. 
По-моему, этого достаточно: (?(condition)yes-pattern|no-pattern)
Пример: (?(?=\d)u|p). (?=\d) - это условие. Мы утверждаем, что после этого места идет цифра. Если оно истинно, то на данном месте должна стоять буква u. Иначе - p.

5 - Комментарии. 
Комментарии начинаются с (?# и продолжаются до ближайшей закрывающей скобки. Так же как /* */ в PHP - без учета вложенности.

Вот и всё. Этой теории, в принципе, должно хватить.


Функции PHP для работы с регулярными выражениями.

mixed preg_match ( string $pattern, string $subject [, array $&a mp;matches [, int $flags [, int $offset]]] ) 
Ищет в заданном тексте subject совпадения с шаблоном pattern . Если совпадение не найдено - вернет false.
В случае, если дополнительный параметр matches указан, он будет заполнен результатами поиска. Элемент $matches[0] будет содержать часть строки, соответствующую вхождению всего шаблона, $matches[1] - часть строки, соответствующую первой подмаске, и так далее. $pattern - шаблон, $subject - где искать. В мануале есть пара примеров.

Похожая функция preg_match_all с теми же параметрами. Она отыскивает все совпадения в то время как preg_match - только первое.

array preg_split ( string $patte rn, string $subject [, int $limi t [, int $flags]] ) 
Возвращает массив, состоящий из подстрок заданной строки subject, которая разбита по границам, соответствующим шаблону pattern. 
В случае, если параметр limit указан, функция возвращает не более, чем limit подстрок. Специальное значение limit, равное -1, подразумевает отсутствие ограничения

mixed preg_replace ( mixed $patt ern, mixed $replacement, mixed $ subject [, int $limit] )
Выполняет поиск в строке subject совпадений с шаблоном pattern и заменяет их на replacement. В случае, если параметр limit указан, будет произведена замена limit вхождений шаблона; в случае, если limit опущен либо равняется -1, будут заменены все вхождения шаблона. 
$replacement может содержать ссылки на подмаски шаблона. Таким образом, можно поменять в строке местами части, соответствующие двум разным подмаскам.

mixed preg_replace_callback ( mi xed $pattern, callback $callback , mixed $subject [, int $limit] ) Выполняет поиск по регулярному выражению и замену с использованием функции обратного вызова. Пример:

<?PHP 
function rnd_replace($matches)
{
    if ($matches[1] > 'c')
        return '('.$matches[1].'->'.rand(0, 9).')';
    else 
        return $matches[1];
}
$src = 'sd4vaf345g534fgh43kj3';
$res = preg_replace_callback('/(\D)/', 'rnd_replace', $src);
echo $res
?>
Все не цифры, которые больше, чем с будут заменены сами увидите на что.








