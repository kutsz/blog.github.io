>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://www.youtube.com/watch?v=PMfcsYzj-9M&app=desktop

        typeof  undefined         // "Undefined"    
        typeof  3.14              // "Number"
	typeof  true              // "Boolean"
	typeof  "foo"             // "String"
	typeof  {bar:"baz"}       // "Object"
	typeof  null              // "NULL"          "object"

	typeof  function f(){}    // "Function" 
        typeof  ["dff",43]        // "Array" 
        typeof  /fgju/            // "RegExp"  

        x = null;          // спец. значение (само себе тип) «пустое» значение
	x = undefined;     // спец. значение (само себе тип)  «значение не присвоено»

var
Объявляет переменную, инициализация переменной значением является необязательной.
let
Объявляет локальную переменную в области видимости блока, инициализация переменной значением является необязательной.
const
Объявляет именованную константу, доступную только для чтения.

Идентификатор в JavaScript должен начинаться с 'буквы, нижнего подчеркивания (_) или знака доллара ($)'; последующие символы могут также быть цифрами (0-9). Поскольку JavaScript чувствителен к регистру, буквы включают символы от "A" до "Z" (верхний регистр) и символы от "a" до "z" (нижний регистр).

Используя ключевое слово var. Например, var x = 42. 
Данный синтаксис может быть использован для объявления как 'локальных', так и 'глобальных' переменных.

Просто присвоить переменной значение. Например, x = 42. Переменные, объявленные данным способом, являются 'глобальными'. Такое объявление генерирует строгое предупреждение  (strict mode). 'Не рекомендуется' использовать данный способ.

Используя ключевое слово let. Например, let y = 13. 
Данный синтаксис может быть использован для объявления 'локальной' переменной в области видимости блока.

	var a;
	console.log("The value of a is " + a); //Значение переменной a undefined

	console.log("The value of b is " + b); //Uncaught ReferenceError: b не определена

	console.log("The value of c is " + c); //Значение переменной c undefined
	var c;

	console.log("The value of x is " + x); //Uncaught ReferenceError: x не определена
	let x;

Переменная, объявленная через var или let без присвоения начального значения, имеет значение undefined.
	var input;
	if (input === undefined) {} //true

Значение undefined ведет себя как false, когда используется в логическом контексте. 
	var myArray = []; // неопределен
	if ( !myArray[0] ) myFunction();

Значение undefined конвертируется в NaN, когда используется в числовом контексте:
	var a;
	a + 2; // NaN

Значение null ведет себя как 0 в числовом контексте и как false в логическом контексте:
	var n = null;
	console.log(n * 32); // В консоль выведется 0

                                    ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ   //TODO
Когда вы объявляете переменную вне функции, то такая переменная называется 'глобальной' переменной, т.к. доступна любому коду в текущем документе.
Когда вы объявляете переменную внутри функции, то такая переменная называется 'локальной' переменной, т.к. доступна только внутри данной функции.
???????????//TODO
До ECMAScript 6 в JavaScript отсутствовала 'область видимости блока'; переменная, объявленная внутри блока, является локальной для функции (или глобальной области видимости), внутри которой находится данный блок. Например, следующий код выведет значение 5, т.к. областью видимости переменной x является функция (или глобальный контекст), внутри которой объявлена переменная x, а не блок, которым в данном случае является оператор if:

	if (true) {
	  var x = 5;
	}
	console.log(x); // 5

Такое поведение меняется, если используется оператор let, введенный в ECMAScript 6:

	if (true) {
	  let y = 5;
	}
	console.log(y); // ReferenceError


				ПОДНЯТИЕ ПЕРЕМЕННЫХ

Другим необычным свойством переменных в JavaScript является то, что можно сослаться на переменную, которая объявляется позже, и не получить при этом исключения. Эта концепция известна как поднятие (hoisting) переменных; переменные в JavaScript поднимаются в самое начало функции или выражения. Однако, переменные, которые еще не были инициализированы, возвратят значение undefined:
	/*
	 * Example 1
	*/
	console.log(x === undefined); // true
	var x = 3;

	/*
	 * Example 2
	*/
	var myvar = "my value";
	 
	(function() {
	  console.log(myvar); // undefined
	  var myvar = "local value";
	})();

Приведенные выше примеры будут интерпретироваться так же, как:

	/*
	 * Example 1
	*/
	var x;
	console.log(x === undefined); // true
	x = 3;
	 
	/*
	 * Example 2
	*/
	var myvar = "my value";
	 
	(function() {
	  var myvar;
	  console.log(myvar); // undefined
	  myvar = "local value";
	})();

Из-за поднятия переменных, все операторы var в функции следует размещать настолько близко к началу функции, насколько это возможно. Следование этому правилу улучшает ясность кода.

В ECMAScript 2015, let (const) не будет подниматься вверх блока. Однако, ссылки на переменную в блоке до объявления переменной вызовут  ReferenceError. Переменная во "временной мёртвой зоне" в начале блока, до объявления.

	function do_something() { 
	  console.log(foo); // ReferenceError 
	  let foo = 2; 
	}

 			ПОДНЯТИЕ ФУНКЦИЙ

Для функций: только определения функций поднимаются наверх, но не функции, определённые через выражения.

	/* Определение функции */
	foo(); // "bar"

	function foo() {
	  console.log("bar");
	}

	/* Определение функции через выражение */
	baz(); // TypeError: baz is not a function

	var baz = function() {
	  console.log("bar2");
	};

				ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ

Глобальные переменные на самом деле являются свойствами глобального объекта. 
На веб-страницах глобальным объектом является 'window', поэтому вы можете устанавливать глобальные переменные и обращаться к ним, используя синтаксис window.variable:

	window.foo = 'bar';

Следовательно, вы можете обращаться к глобальным переменным, объявленным в одном объекте window или frame из другого объекта window или frame, указав имя window или frame. 
Например, если переменная phoneNumber объявлена в документе, то вы можете сослаться на эту переменную из iframe как parent.phoneNumber.

				КОНСТАНТЫ

Вы можете создать именованную константу, доступную только для чтения, используя ключевое слово const. Синтаксис идентификатора константы является таким же, как и у идентификатора переменной: он должен начинаться с буквы, нижнего подчеркивания или знака $ и может содержать буквы, цифры или нижнее подчеркивание.

	const prefix = '212';

Нельзя изменить значение константы через присваивание или повторное объявление во время выполнения скрипта. 
Значение должно быть указано при инициализации.//TODO

Правила, касающиеся области видимости, для констант являются такими же, как и для переменных, объявленных через let. Если ключевое слово const не указано, то идентификатор будет являться переменной.

Нельзя объявить константу с таким же именем, как у функции или переменной в одной области видимости. Следующие примеры выбросят исключение TypeError:

	// Это вызовет ошибку 
	function f() {}
	const f = 5; 

	// Это тоже вызовет ошибку 
	function f() {
	  const g = 5;
	  var g;

	  // какие-то выражения 
	}

Однако, атрибуты объектов не защищены, так что следующее выражение выполнится без проблем

	const MY_OBJECT = {"key": "value"}; 
	MY_OBJECT.key = "otherValue";

..........................  ТИПЫ ДАННЫХ ..............................

Последний стандарт ECMAScript определяет 'семь' типов данных:   //TODO

Шесть типов данных,  которые являются примитивами:

Boolean.    true и false.
null.       Специальное ключевое слово, обозначающее нулевое или «пустое» значение. Поскольку JavaScript чувствителен к 
            регистру, null не то же самое, что Null, NULL или любой другой вариант.
undefined.  Свойство глобального объекта; переменная, не имеющая присвоенного значения, обладает типом undefined.
Number.     42 или 3.14159.
String.     "Howdy".
Symbol    (ECMAScript 6) (Символ) — примитивный тип данных, экземпляры которого уникальны и неизменяемы. В некоторых языках
           программирования символы также называются атомами.
           В JavaScript символы является примитивами, а объект Symbol служит обёрткой символьного примитива.


и Object

 Объекты и функции являются другими фундаментальными элементами языка. 
Вы можете думать об объектах как об именованных контейнерах для значений и о функциях как о процедурах, которые ваше приложение может исполнять.

	ПРЕОБРАЗОВАНИЕ ТИПОВ ДАННЫХ

JavaScript — это динамически типизированный язык. Это означает, что вам не нужно указывать тип данных переменной, когда вы ее объявляете, 
типы данных преобразуются автоматически по мере необходимости во время выполнения скрипта. 
Так, например, вы можете определить переменную следующим образом:

	var answer = 42;

А позже вы можете присвоить этой переменной строковое значение, например:

	answer = "Thanks for all the fish...";

В выражениях, включающих числовые и строковые значения с оператором '+',  //TODO
JavaScript преобразует 'числовые значения в строковые'. 
Например:

	x = "The answer is " + 42 // "The answer is 42"
	y = 42 + " is the answer" // "42 is the answer"

В выражениях с другими операторами JavaScript не преобразует числовые значения в строковые. Например:

	"37" - 7 // 30
	"37" + 7 // "377"


	ПРЕОБРАЗОВАНИЕ СТРОК В ЧИСЛА

В том случае, если значение, представляющее число, хранится в памяти как строка, можно использовать методы для преобразования строк в числа:

	parseInt(numString, [radix])
	parseFloat(numString)

 parseInt  преобразует строку в целочисленное значение. Хорошей практикой является всегда указывать основание системы
           счисления (параметр radix).

Альтернативным способом для получения 'числа из строки' является использование оператора "унарный плюс":

	"1.1" + "1.1"       // "1.11.1"
	(+"1.1") + (+"1.1") // 2.2
	// Обратите внимание на то, что скобки не являются обязательными и используются для ясности

..............................  ЛИТЕРАЛЫ .....................
Литералы используются для представления значений в JavaScript. Они являются фиксированными значениями, а не переменными.

ЛИТЕРАЛ МАССИВА — это список из нуля или более выражений, каждое из которых представляет элемент массива, заключенный в квадратные скобки ( [] ). Когда вы создаете массив, используя литерал массива, он инициализируется с помощью переданных значений, которые будут являться его элементами, длина массива будет равна числу переданных аргументов.
Замечание : Обратите внимание на то, что литерал массива является инициализатором объекта
Если массив создается с помощью литерала в скрипте верхнего уровня, то JavaScript интерпретирует массив каждый раз, когда вычисляет выражение, содержащее литерал. Кроме того, литерал, используемый в функции, создается каждый раз, когда вызывается функция.

Литералы массива также являются объектами Array.

ЛИШНИЕ ЗАПЯТЫЕ В ЛИТЕРАЛАХ ARRAY

Не обязательно указывать все элементы в литерале array. Если вы поставите две запятые подряд, то пропущенные элементы будут иметь значение undefined. Например:

	var fish = ["Lion", , "Angel"]; // ["Lion", undefined, "Angel"]

У этого массива есть 2 элемента со значениям и один пустой 
(fish[0] - "Lion", fish[1] - undefined, а fish[2] - "Angel").

Если вы поставите запятую в конце списка элементов, то она будет проигнорирована.
 В следующем примере, длина массива равна 3. Нет myList[3]. Все другие запятые в списке говорят о новом элементе.

Замечание : Лишние запятые могут вызывать ошибки в старых версиях браузеров, поэтому лучше избегать их использования.
	var myList = ['home', , 'school', ]; // ["home", undefined, "school"]
В следующем примере длина массива равна четырем, элементы myList[0] и myList[2] имеют значение undefined:

	var myList = [ , 'home', , 'school']; // [undefined, "home", undefined, "school"]
В следующем примере длина массива равна четырем, элементы myList[1] и myList[3] имеют значение undefined. Игнорируется только последняя запятая.

	var myList = ['home', , 'school', , ]; // ["home", undefined, "school", undefined]

ЛОГИЧЕСКИЕ ЛИТЕРАЛЫ

Логический (Boolean) тип имеет два литеральных значения: true и false.

Не путайте примитивные логические значения true и false со значениями true и false объекта Boolean. Объект Boolean является объектом-обёрткой над примитивом логического типа. 

ЛИТЕРАЛ ЦЕЛОГО ЧИСЛА

Целые числа могут быть записаны в десятичной, шестнадцатеричной, восьмеричной и двоичной системах счисления.

Десятичный целочисленный литерал состоит из последовательности цифр без ведущего нуля.
Ведущий ноль в целочисленном литерале указывает на то, что он записан в восьмеричной системе счисления. Восьмеричные целые числа состоят только из цифр 0-7.
Ведущие символы 0x (или 0X) указывают на то, что число шестнадцатеричное. Шестнадцатеричные целые числа могут состоять из цифр 0-9 и букв a-f и A-F. 
Ведущие символы 0b (или 0B) указывают на то, что число двоичное. Двоичные числа могут включать в себя только цифры 0 и 1.
Несколько примеров целочисленных литералов:

0, 117 и -345 (десятичная система счисления)
015, 0001 и -077 (восьмеричная система счисления) 
0x1123, 0x00111 и -0xF1A7 (шестнадцатеричная система счисления)

ЛИТЕРАЛ ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ

Числа с плавающей точкой могут состоять из следующих частей:

Десятичное целое число, которое может иметь знак (символ "+" или "-", стоящий перед числом),
Десятичная точка ("."),
Дробная часть (другое десятичное число),
Экспонента.

Экспонента состоит из символа "e" или "E", за которым следует целое число, которое может иметь знак. Число с плавающей точкой должно состоять по крайней мере из одной цифры и либо десятичной точки, либо символа "e" (или "E").

В более сжатой форме синтаксис выглядит следующим образом:

	[(+|-)][digits][.digits][(E|e)[(+|-)]digits]
Примеры:

3.14
-3.1E+12
-.3333333333333333333
-3.1E+12

ЛИТЕРАЛ ОБЪЕКТА

Литерал объекта — это список из нуля или более пар, состоящих из имен свойств и связанных с ними значений, заключенный в фигурные скобки ( {} ). Вам не следует использовать литерал объекта в начале выражения, т.к. это приведет к ошибке или к поведению, которого вы не ожидаете, потому что символ "{" будет интерпретироваться как начало блока.

В следующем примере свойству myCar объекта car присваивается строка "Saturn", свойству getCar — результат вызова функции CarTypes("Honda"), свойству special — значение переменной Sales:

	var Sales = "Toyota";

	function CarTypes(name) {
	  if (name == "Honda") {
	    return name;
	  } else {
	    return "Извините, мы не продаём " + name + ".";
	  }
	}

	var car = { myCar: "Saturn", getCar: CarTypes("Honda"), special: Sales };

	console.log(car.myCar);   // Saturn
	console.log(car.getCar);  // Honda
	console.log(car.special); // Toyota

Кроме того, вы можете использовать 'числовой или строковой' литералы в именах свойств или вкладывать один объект в другой. Например:

	var car = { manyCars: {a: "Saab", "b": "Jeep"}, 7: "Mazda" };

	console.log(car.manyCars.b); // Jeep
	console.log(car[7]);         // Mazda

Именем свойства объекта может быть любая строка, в том числе пустая строка. Если имя свойства не является корректным JavaScript идентификатором, то оно должно быть заключено в кавычки. Для обращения к таким именам следует использовать квадратные скобки ( [] ), а не точку ( . ):

	var unusualPropertyNames = {
	  "": "An empty string",
	  "!": "Bang!"
	}
	console.log(unusualPropertyNames."");   // SyntaxError: Unexpected string
	console.log(unusualPropertyNames[""]);  // "An empty string"
	console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
	console.log(unusualPropertyNames["!"]); // "Bang!"

В ES2015 литералы объектов расширены до поддержки установки прототипа в конструкции короткой записи для foo: задание foo,  определение методов, создание супер вызовов и вычисление имён свойств в выражениях. Вместе, они делают похожими объектные литералы и объявления классов, а также позволяют объектному дизайну получать выгоду одинаковых возможностей.

	var obj = {
	    // __proto__
	    __proto__: theProtoObj,
	    // Короткая запись для ‘handler: handler’
	    handler,
	    // Методы
	    toString() {
	     // Супер вызовы
	     return "d " + super.toString();
	    },
	    // Динамическое вычисление имён свойств
	    [ 'prop_' + (() => 42)() ]: 42
	};

Обратите внимание на следующий пример:

	var foo = {a: "alpha", 2: "two"};
	console.log(foo.a);               // alpha
	console.log(foo[2]);              // two
	// console.log(foo.2);            // SyntaxError: Unexpected number
	// console.log(foo[a]);           // ReferenceError: a is not defined
	console.log(foo["a"]);            // alpha
	console.log(foo["2"]);            // two

 RegExp ЛИТЕРАЛ

Литерал regexp - шаблон между слешами. Следующий пример литерал regex:

var re = /ab+c/;

 СТРОКОВЫЙ ЛИТЕРАЛ

Строковый литерал — это ноль или более символов, заключенных в двойные ( " ) или одинарные ( ' ) кавычки. Строка должна быть ограничена кавычками одного типа, т.е. либо обе одинарные, либо обе двойные. Например:

	"foo"
	'bar'
	"1234"
	"one line \n another line"
	"John's cat"
​Вы можете вызвать любой из методов объекта String для строкового литерала: JavaScript автоматически преобразует строковой литерал во временный объект String, вызовет метод, а затем уничтожит временный объект String. Вы также можете использовать свойство String.length со строковым литералом:

	console.log("John's cat".length);
// Число символов в строке, включая пробел.
// В данном случае длина строки равна 10.
В ES2015 также доступны шаблоны строк. Шаблоны строк представляют собой синтаксический сахар для конструирования строк. Это похоже на возможности интерполяции строк в Perl, Python и других. Дополнительно, может быть добавлен тег, позволяющий настраивать конструирование строк, избегая атак внедрения и построения структур данных высокого уровня из содержимого строки.

// Простое создание строки через литерал string
	`In JavaScript '\n' is a line-feed.`

// Мультистроковые строки
	`In JavaScript this is
	 not legal.`

// Интерполяция строк
	var name = "Бобби", time = "сегодня";
	`Привет ${name}, как ты ${time}?`

// Строим префикс HTTP запроса, используемый для интерпретации замен и конструирования
	POST`http://foo.org/bar?a=${a}&b=${b}
	     Content-Type: application/json
	     X-Credentials: ${credentials}
	     { "foo": ${foo},
	       "bar": ${bar}}`(myOnReadyStateChangeHandler);

Вам следует использовать строковые литералы до тех пор, пока вам специально не понадобится объект String. Чтобы получить более подробную информацию об объекте String, прочитайте String.

ИСПОЛЬЗОВАНИЕ СПЕЦИАЛЬНЫХ СИМВОЛОВ В СТРОКАХ

Кроме обычных символов вы также можете включать специальные символы в строки.

"one line \n another line"
В следующей таблице перечислены специальные символы, которые вы можете использовать.

Специальные символы в JavaScript
	Символ	Значение
	\b	Возврат (Backspace)
	\f	Перевод или прогон страницы (Form feed)
	\n	Перевод строки (New line)
	\r	Возврат каретки (Carriage return)
	\t	Табуляция (Tab)
	\v	Вертикальная табуляция (Vertical tab)
	\'	Апостроф или одинарная кавычка
	\"	Двойная кавычка
	\\	Обратная косая черта (Backslash)
\XXX	
Символ в кодировке Latin-1, представленный тремя восьмеричными числами XXX от 0 до 377. Например, \251 (символ ©).

\xXX	
Символ в кодировке Latin-1, представленный двумя шестнадцатеричными числами XX от 00 до FF. Например, \xA9 (символ ©).

\uXXXX	
Символ в Unicode, представленный четырьмя шестнадцатеричными числами XXXX. Например, \u00A9 (символ ©).

\u{XXXXX}	
Символ в UTF-32BE. Например, \u{2F804} обозначает то же, что обычная запись \uD87E\uDC04.

ЭКРАНИРУЮЩИЕ СИМВОЛЫ

Для символов, не перечисленных в вышеприведенной таблице, предваряющая обратная косая черта игнорируется. Такое использование не является рекомендованным (deprecated) и вам следует избегать его.

Вы можете вставить кавычку в строку, если поставите перед ней обратную косую черту. Это называется экранированием кавычек. Например:

	var quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
	console.log(quote); // He read "The Cremation of Sam McGee" by R.W. Service.
Чтобы включить обратную косую черту в строку, перед ней нужно поставить еще одну обратную косую черту. Например:

	var home = "c:\\temp"; // c:\temp
Вы также можете экранировать перевод строки. Обратная косая черта и перевод строки будут удалены из содержимого строки. Например:

	var str = "this string \
	is broken \
	across multiple\
	lines."
	console.log(str); // this string is broken across multiplelines.

Хотя JavaScript не поддерживает синтаксис "heredoc" (форматированный текст в одной строковой переменной), но вы можете эмулировать его, добавив перевод строки и обратную косую черту в конец каждой строки:

	var poem = 
	"Roses are red,\n\
	Violets are blue.\n\
	I'm schizophrenic,\n\
	And so am I."

 Точка с запятой ( ; ) используется для разделения инструкций в коде.

	ИНСТРУКЦИЯ BLOCK
Инструкция block является фундаментальной и используется для группировки других инструкций. Блок ограничивается фигурными скобками:

	{ statement_1; statement_2; ... statement_n; }
Блок обычно используется с управляющими инструкциями (например, if, for, while).

	while (x < 10) { x++; }
В вышеприведенном примере { x++; } является блоком.

Обратите внимание на то, что в JavaScript отсутствует область видимости блока до ECMAScript 6. Переменные, объявленные внутри блока, имеют область видимости функции (или скрипта), в которой находится данный блок. Такие переменные доступны за пределами блока. Другими словами, блок не создает новую область видимости. Хотя "автономные" (standalone) блоки являются корректными синтаксическими конструкциями, но вам не следует их использовать, т.к. они не делают то, что вы ожидаете, если вы ожидаете, что они ведут себя как блоки в C или Java. Например:

	var x = 1;
	{
	  var x = 2;
	}
	console.log(x); // 2

В вышеприведенном примере инструкция var x внутри блока находится в той же области видимости, что и инструкция var x перед блоком. В C или Java эквивалентный код выведет значение 1.

Начиная с ECMAScript 6, оператор let позволяет объявить переменную в области видимости блока. Чтобы получить более подробную информацию, прочитайте let...................................

let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];
.....................
	var a = 5;
	var b = 10;

	if (a === 5) {
	  let a = 4; // The scope is inside the if-block
	  var b = 1; // The scope is inside the function

	  console.log(a);  // 4
	  console.log(b);  // 1
	} 

	console.log(a); // 5
	console.log(b); // 1
................
	for (let i = 0; i<10; i++) {
	  console.log(i); // 0, 1, 2, 3, 4 ... 9
	}

	console.log(i); // i is not defined
.............................................
let (var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]]) block;
let блок предоставляет локальную область видимости для перемнных. Работа его заключается в привязке нуля или более переменных к области видимости этого блока кода, другими словами, он является блоком операторов.

	var x = 5;
	var y = 0;

	let (x = x+10, y = 12) {
	  console.log(x+y); // 27
	}

	console.log(x + y); // 5

......................../////////////////и многое другое

ЛОЖНЫЕ ЗНАЧЕНИЯ

Следующие значения являются ложными:

	false
	undefined
	null
	0
	NaN
	пустая строка ( "" )

Все остальные значения, включая все объекты, будут восприняты как истина при передаче в условное выражение.

Не путайте примитивные логические значения true и false со значениями true и false объекта Boolean. Например:

	var b = new Boolean(false);
	!!b; // true

..........................
	switch (expression) {
	   case label_1:
	      statements_1
	      [break;]
	   case label_2:
	      statements_2
	      [break;]
	   ...
	   default:
	      statements_default
	      [break;]
	}
..................
		ИНСТРУКЦИИ ОБРАБОТКИ ИСКЛЮЧЕНИЙ

Инструкция throw используется, чтобы выбросить исключение, а инструкция try...catch, чтобы его обработать.

Типы исключений

Практически любой объект может быть выброшен как исключение. Тем не менее, не все выброшенные объекты создаются равными. Обычно числа или строки выбрасываются как исключения, но часто более эффективным является использование одного из типов исключений, специально созданных для этой цели:

Исключения ECMAScript
DOMException и DOMError

	ИНСТРУКЦИЯ throw

Используйте инструкцию throw, чтобы выбросить исключение. При выбросе исключения нужно указать выражение, содержащее значение, которое будет выброшено:

	throw expression;

Вы можете выбросить любое выражение, а не только выражения определенного типа. В следующем примере выбрасываются исключения различных типов:

	throw "Error2";                                              // string
	throw 42;                                                    // number
	throw true;                                                  // boolean
	throw { toString: function() { return "I'm an object!"; } }; // object

Примечание: Вы можете выбросить объект как исключение. Вы можете обращаться к свойствам данного объекта в блоке catch.
В следующем примере объект UserException выбрасывается как исключение:

	function UserException (message) {
	  this.message = message;
	  this.name = "UserException";
	}

	UserException.prototype.toString = function () {
	  return this.name + ': "' + this.message + '"';
	}

	throw new UserException("Value too high");


	ИНСТРУКЦИЯ try...catch

Инструкция try...catch состоит из блока try, который содержит одну или несколько инструкций, и нуля или более блоков catch, которые содержат инструкции, определяющие порядок действий при выбросе исключения в блоке try. Иными словами, если в блоке try будет выброшено исключение, то управление будет передано в блок catch. Если в блоке try не возникнет исключений, то блок catch будет пропущен. Блок finally будет выполнен после окончания работы блоков try и catch, вне зависимости от того, было ли выброшено исключение.

В следующем примере вызывается функция getMonthName, которая возвращает название месяца по его номеру. Если месяца с указанным номером не существует, то функция выбросит исключение "InvalidMonthNo", которое будет перехвачено в блоке catch:

	function getMonthName (mo) {
	  mo = mo - 1;
	  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
	  if (months[mo] != undefined) {
	    return months[mo];
	  } else {
	    throw "InvalidMonthNo";
	  }
	}

	try {
	  monthName = getMonthName(myMonth);
	} catch (e) {
	  monthName = "unknown";
	}

	БЛОК catch

Используйте блок catch, чтобы обработать исключения, сгенерированные в блоке try.

catch (catchID) { statements }

JavaScript создает идентификатор catchID, которому присваивается перехваченное исключение, при входе в блок catch; данный идентификатор доступен только в пределах блока catch и уничтожается при выходе из него.

В следующем примере выбрасывается исключение, которое перехватывается в блоке catch:

	try {
	  throw "myException"
	} catch (e) {
	  console.error(e);
	}

	БЛОК finally

Блок finally содержит код, который будет выполнен после окончания работы блоков try и catch, но до того, как будет выполнен код, который следует за инструкцией try...catch. Блок finally выполняется вне зависимости от того, было ли выброшено исключение. Блок finally выполняется даже в том случае, если исключение не перехватывается в блоке catch.

В следующем примере открывается файл, затем в блоке try происходит вызов функции writeMyFile, который может выбросить исключение. Если возникает исключение, то оно обрабатывается в блоке catch. В любом случае файл будет закрыт функцией closeMyFile, вызов которой находится в блоке finally.

	openMyFile();
	try {
	  writeMyFile(theData);
	} catch(e) {
	  handleError(e);
	} finally {
	  closeMyFile();
	}

Если блок finally возвращает значение, то данное значение становится возвращаемым значением всей связки try-catch-finally. Значения, возвращаемые блоками try и catch, будут проигнорированы.

	function f() {
	  try {
	    console.log(0);
	    throw "bogus";
	  } catch(e) {
	    console.log(1);
	    return true;    // приостанавливается до завершения блока `finally`
	    console.log(2); // не выполняется
	  } finally {
	    console.log(3);
	    return false;   // заменяет предыдущий `return`
	    console.log(4); // не выполняется
	  }
	  // `return false` выполняется сейчас
	  console.log(5);  // не выполняется
	}
	f();               // отображает 0, 1, 3 и возвращает `false`

Замена возвращаемых значений блоком finally распространяется в том числе и на исключения, которые выбрасываются или перевыбрасываются в блоке catch:

	function f() {
	  try {
	    throw "bogus";
	  } catch(e) {
	    console.log('caught inner "bogus"');
	    throw e;      // приостанавливается до завершения блока `finally`
	  } finally {
	    return false; // заменяет предыдущий `throw`
	  }
	  // `return false` выполняется сейчас
	}

	try {
	  f();
	} catch(e) {
	  // Не выполняется, т.к. `throw` в `catch `заменяется на `return` в `finally`
	  console.log('caught outer "bogus"');
	}

	// В результате отображается сообщение caught inner "bogus"
	// и возвращается значение `false`

	ВЛОЖЕННЫЕ ИНСТРУКЦИИ try...catch

Вы можете вкладывать инструкции try...catch друг в друга. Если внутренняя инструкция try...catch не имеет блока catch, то исключение будет перехвачено во внешнем блоке catch.

	ИСПОЛЬЗОВАНИЕ ОБЪЕКТА Error

В зависимости от типа ошибки вы можете использовать свойства name и message, чтобы получить более подробную информацию. Свойство name содержит название ошибки (например, DOMException или Error), свойство message — описание ошибки.

Если вы выбрасываете собственные исключения, то чтобы получить преимущество, которое предоставляют эти свойства (например, если ваш блок catch не делает различий между вашими исключениями и системными), используйте конструктор Error. Например:

	function doSomethingErrorProne () {
	  if ( ourCodeMakesAMistake() ) {
	    throw ( new Error('The message') );
	  } else {
	    doSomethingToGetAJavascriptError();
	  }
	}

	try {
	  doSomethingErrorProne();
	} catch (e) {
	  console.log(e.name);    // 'Error'
	  console.log(e.message); // 'The message' или JavaScript error message
	}
.............................

	ОБЪЕКТ Promise

Начиная с ECMAScript 6, JavaScript поддерживает объект Promise, который используется для отложенных и асинхронных операций.

Объект Promise может находиться в следующих состояниях:

ожидание (pending): начальное состояние, не выполнено и не отклонено.
выполнено (fulfilled): операция завершена успешно.
отклонено (rejected): операция завершена с ошибкой.
заданный (settled): обещание выполнено или отклонено, но не находится в состоянии ожидания.

.........................
	ЗАГРУЗКА изображения при помощи XHR

Простой пример использования объектов Promise и XMLHttpRequest для загрузки изображения доступен в репозитории MDN promise-test на GitHub. Вы также можете посмотреть его в действии. Каждый шаг прокомментирован, что позволяет вам разобраться в архитектуре Promise и XHR. Здесь приводится версия без комментариев:

	function imgLoad(url) {
	  return new Promise(function(resolve, reject) {
	    var request = new XMLHttpRequest();
	    request.open('GET', url);
	    request.responseType = 'blob';
	    request.onload = function() {
	      if (request.status === 200) {
		resolve(request.response);
	      } else {
		reject(Error('Image didn\'t load successfully; error code:' 
		             + request.statusText));
	      }
	    };
	    request.onerror = function() {
	      reject(Error('There was a network error.'));
	    };
	    request.send();
	  });
	}

///////////////

Циклы - простой способ сделать какое-то действие несколько раз. Эта глава руководства JavaScript Guide познакомит вас с различными операторами доступными в JavaScript.

Вы можете представить цикл в виде компьютеризированной версии игры, где вы говорите кому-то сделать X шагов в одном направлении, затем Y шагов в другом; для примера, идея игры "Иди 5 шагов на восток" может быть выражена в виде цикла:

	var step;
	for (step = 0; step < 5; step++) {
	  // Запускается 5 раз, с шагом от 0 до 4.
	  console.log('Идём 1 шаг на восток');
	}

Существует множество различных видов циклов, но все они по сути делают тоже самое: повторяют какое-либо действие несколько раз (не забывайте про нулевой раз повторения, отсчёт в массиве начинается с 0). Различные по строению циклы предлагают разные способы для определения начала и окончания цикла. Для различных задач программирования существуют свои операторы цикла, с помощью которых они решаются намного проще.

Операторы предназначеные для организации циклов в  JavaScript:

	Цикл_for
	Цикл_do...while
	Цикл_while
	Метка_(label)
	break
	continue
	for...in
	for...of


	ЦИКЛ for 
Цикл for  повторяет действия, пока не произойдёт какое-либо специальное событие завершения цикла. Оператор for в JavaScript аналогичен оператору for в Java и C. Объявление оператора for выглядит следующим образом:

	for ([начало]; [условие]; [шаг]) выражения
	При его выполнении происходит следущее:

Выполняется выражение начало, если оно указано. Это выражение обычно инициализирует один или несколько счётчиков, но синтаксис позволяет выражению быть любой сложности. Также используется для объявления переменных.
Выполняется условие. Если условие истинно, то выполняются выражения. Если оно ложно, цикл for прерывается. Если же условие полностью пропущено, то оно считается истинным.
Выполняются выражения. Чтобы выполнить несколько выражений, используются выражение блок ({ ... })  для группировки выражений.
Обновляется шаг, если он есть, а затем управление возвращается к шагу 2.
Пример

В следующей функции есть цикл for, который считает количество выбранных жанров в списке прокрутки (элемент <select>, который позволяет выбрать несколько элементов). Цикл for объявляет переменную i и задаёт ей значение 0. Также он проверяет, что i меньше количества элементов в элементе <select>, выполняет оператор if и увеличивает i на один после каждого прохода цикла.

	<form name="selectForm">
	  <p>
	    <label for="musicTypes">Выберите некоторые жанры музыки, а затет нажмите на кнопку ниже:</label>
	    <select id="musicTypes" name="musicTypes" multiple="multiple">
	      <option selected="selected">R&B</option>
	      <option>Jazz</option>
	      <option>Blues</option>
	      <option>New Age</option>
	      <option>Classical</option>
	      <option>Opera</option>
	    </select>
	  </p>
	  <p><input id="btn" type="button" value="Как много выбрано?" /></p>
	</form>

	<script>
	function howMany(selectObject) {
	  var numberSelected = 0;
	  for (var i = 0; i < selectObject.options.length; i++) {
	    if (selectObject.options[i].selected) {
	      numberSelected++;
	    }
	  }
	  return numberSelected;
	}

	var btn = document.getElementById("btn");
	btn.addEventListener("click", function(){
	  alert('Выбрано элементов: ' + howMany(document.selectForm.musicTypes))
	});
	</script>

	ЦИКЛ do...while 
Цикл do...while повторяется пока заданное условие истинно. Оператор do...while имеет вид:

	do
	  выражения
	while (условие);

выражения выполняются пока условие истинно. Чтобы использовать несколько выражений, используйте оператор блок ({ ... }), чтобы сгруппировать их. Если условие истинно, выражения выполнятся снова. В конце каждого прохода условие проверяется. Если условие ложно, выполнение приостанавливается и управление передаётся выражению после do...while.

Пример

В следующем пример, цикл do выполнится минимум 1 раз и запускается снова, пока i меньше 5.

	do {
	  i += 1;
	  console.log(i);
	} while (i < 5);

	ЦИКЛ while
Цикл while выполняет выражения пока условие истинно. Выглядит он так:

	while (условие)
	  выражения

Если условие становится ложным, выражения в цикле перестают выполняться и управление переходит к выражению после цикла.

Условие проверяется на истинность до того, как выполняются выражения в цикле. Если условие истинно, выполняются выражения, а затем условие проверяется снова. Если условие ложно, выполнение приостанавливается и управление переходит к выражению после while.

Чтобы использовать несколько выражений, используйте оператор блок ({ ... }), чтобы сгруппировать их.

Пример 1

Следующий цикл while работает, пока n меньше трёх:

	var n = 0;
	var x = 0;
	while (n < 3) {
	  n++;
	  x += n;
	}

С каждой итерацией, цикл увеличивает n и добавляет это значение к x. Поэтому, x и n получают следующие значения:

После первого прохода: n = 1 и x = 1
После второго: n = 2 и x = 3
После третьего прохода: n = 3 и x = 6
После третьего прохода, условие n < 3 становится ложным, поэтому цикл прерывается.

Пример 2

Избегайте бесконечных циклов. Убедитесь, что условие цикла в итоге станет ложным; иначе, цикл никогда не прервётся. Выражения в следующем цикле while будут выполняться вечно, т.к. условие никогда не станет ложным:

	while (true) {
	  console.log("Hello, world");
	}
	

	МЕТКА (label)

Метка представляет собой оператор с индентификатором, который позволяет вам ссылаться на какое-то место в вашей программе. Например, вы можете использовать метку, чтобы обозначить цикл, а затем использовать операторы break или continue, чтобы указать, должна ли программа прерывать цикл или продолжать его выполнение.

Синтаксис метки следующий:

	метка :
	   оператор

Значение метки может быть любым корректным JavaScript индентификатором, не являющимся зарезервированным словом. Оператор, указанный вами после метки может быть любым выражением.

Пример

В этом примере, метка markLoop обозначает цикл while.

	markLoop:
	while (theMark == true) {
	   doSomething();
	}


	break
Используйте оператор break, чтобы прерывать цикл, переключать управление или в сочетании с оператором метка.

Когда вы используете break без метки, он прерывает циклы while, do-while и for или сразу переключает управление к следующему выражению.//TODO
Когда вы используете break с меткой, он прерывает специально отмеченное выражение.

Синтаксис оператора может быть таким:

	break;
	break Метка;                //TODO

Первая форма синтаксиса прерывает цикл совсем или переключает управление; вторая прерывает специально обозначенное выражение.

Пример 1

Следующий пример проходит по элементам в массиве, пока не найдёт элемент, чьё значение - theValue:

	for (i = 0; i < a.length; i++) {
	  if (a[i] == theValue) {
	    break;
	  }
	}

Пример 2: Прерывание метки

	var x = 0;
	var z = 0
	labelCancelLoops: while (true) {
	  console.log("Внешний цикл: " + x);
	  x += 1;
	  z = 1;
	  while (true) {
	    console.log("Внутренний цикл: " + z);
	    z += 1;
	    if (z === 10 && x === 10) {
	      break labelCancelLoops;
	    } else if (z === 10) {
	      break;
	    }
	  }
	}

	continue
Оператор continue используется, чтобы шагнуть на шаг вперёд в циклах while, do-while, for или перейти к метке.//TODO

Когда вы используете continue без метки, он прерывает текущую итерацию циклов while, do-while и for и продолжает выполнение цикла со следующей итерации. В отличие от break, continue не прерывает выполнение цикла полностью. В цикле while он прыгает к условию. А в for увеличивает шаг.//TODO
Когда вы используете continue с меткой, он применяется к циклу с этой меткой.

Синтаксис continue может выглядеть так:

	continue;
	continue label;

Пример 1

Следующий пример показывает цикл while с оператором continue, который срабатывает, когда значение i равно 3. Таким образом, n получает значения 1, 3, 7 и 12.

	var i = 0;
	var n = 0;
	while (i < 5) {
	  i++;
	  if (i == 3) {
	    continue;
	  }
	  n += i;
	}

Пример 2

Выражение, отмеченное checkiandj содержит выражение с меткой checkj. При столкновении с continue, программа прерывает текущую итерацию checkj и начинает новую итерацию. Каждый раз при попадании на continue, checkj переходит на новую итерацию, пока условие возвращает false. Когда возвращается false, после вычисления остатка от деления checkiandj, checkiandj переходит на новую итерацию, пока его условие возвращает false. Когда возвращается false, программа продолжает выполнение с выражения после checkiandj.

Если у continue проставлена метка checkiandj, программа может продолжится с метки checkiandj.

	checkiandj:
	  while (i < 4) {
	    console.log(i);
	    i += 1;
	    checkj:
	      while (j > 4) {
		console.log(j);
		j -= 1;
		if ((j % 2) == 0) {
		  continue checkj;
		}
		console.log(j + " чётное.");
	      }
	      console.log("i = " + i);
	      console.log("j = " + j);
	  }

	for...in _____________________________________

Оператор for...in проходит по всем перечислимым свойствам объекта. JavaScript выполнит указанные выражения для каждого отдельного свойства. Цикл for...in выглядит так:

	for (variable in object) {
	  выражения
	}

Пример

Следующая функция берёт своим аргументом объект и его имя. Затем проходит по всем свойствам объекта и возвращает строку, которая содержит имена свойств и их значения.

	function dump_props(obj, obj_name) {
	  var result = "";
	  for (var i in obj) {
	    result += obj_name + "." + i + " = " + obj[i] + "<br>";
	  }
	  result += "<hr>";
	  return result;
	}

Для объекта car со свойствами make и model, результат будет:

	car.make = Ford
	car.model = Mustang

	МАССИВЫ

Хотя, очень заманчиво использовать for...in как способ пройтись по всем элементам Array, этот оператор возвращает имя свойств определённых пользователем помимо числовых индексов. Таким образом лучше использовать стандартный for для числовых индексов при взаимодействии с массивами, поскольку оператор for...in проходит по определённым пользователем свойствам в дополнение к элементам массива, если вы изменяете массив, например, добавляете свойства и методы.

	for...of _______________________________

Оператор for...of создаёт цикл, проходящий по перечислимым объектам (включая Array, Map, Set, объект arguments и так далее), вызывая на каждой итерации функцию с выражениями, которые надо выполнить для получения значения каждого отдельного свойства.

	for (variable of object) {
	  выражения
	}

Следующий пример показывает разницу между циклами for...of и for...in. Тогда как for...in проходит по именам свойств, for...of проходит по значениям свойств:

	let arr = [3, 5, 7];
	arr.foo = "hello";

	for (let i in arr) {
	   console.log(i); // выводит "0", "1", "2", "foo"
	}

	for (let i of arr) {
	   console.log(i); // выводит "3", "5", "7"
	}


////////////////////

		ФУНКЦИИ в JavaScript

Функции - ключевая концепция в JavaScript. Важнейшей особенностью языка является первоклассная поддержка функций​ (functions as first-class citizen). Любая функция это объект, и следовательно ею можно манипулировать как объектом, в частности:

•передавать как аргумент и возвращать в качестве результата при вызове других функций (функций высшего порядка).
•создавать анонимно и присваивать в качестве значений переменных или свойств объектов

Это определяет высокую выразительную мощность JavaScript и позволяет относить его к числу языков, реализующих функциональную парадигму программирования (что само по себе есть очень круто по многим соображениям).

Функция в JavaScript - специальный тип объектов, позволяющий формализовать средствами языка определённую логику поведения и обработки данных. 
Для понимания работы функций необходимо (и достаточно?) иметь представление о следующих моментах:

	способы объявления 
	способы вызова 
	параметры и аргументы вызова (arguments)
	область данных (Scope) и замыкания (Closures)
	объект привязки (this)
	возращаемое значение (return)
	исключения (throw)
	использование в качестве конструктора объектов
	сборщик мусора (garbage collector)

	ОБЪЯВЛЕНИЕ ФУНКЦИЙ
Функция (как и всякий объект) должна быть объявлена(определена, define) перед её использованием. 

Объявление(определение) функции - указание сигнатуры и тела функции:

	Сигнатура - имя(необязательно) и список входных формальных параметров 
	Тело функции - комбинация управляющих конструкций и выражений языка над внешними и локальными данными

Объявление пользовательской функции всегда находится в теле некоторой внешней функции-контейнера, которая, в свою очередь, возможно также вложена в некоторую функцию. Цепочка всех таких внешних функций, вложенных друг в друга, образует лексический диапазон функции. 

Во избежание оговорок о глобальных переменных и функциях, удобно полагать, что программа на языке JavaScript представляет собой тело неявной функции [[ main]]().

Существует три способа объявить функцию:

	В ДЕКЛАРАТИВНОМ СТИЛЕ

Для 'декларативного объявления' функции используется синтаксическая конструкция

	function идентификатор(параметры) {

	  инструкции

	  return выражение

	}

	Ключевое слово function
	Идентификатор (обязательно).
	Список имён формальных параметров (и значений по умолчанию) в круглых скобках разделенных запятыми
	тело функции в фигурных скобках вида {}.

Пример. Следующий код объявляет функцию  с именем square и параметром number; тело состоит из инструкции return и выражения, которое дословно формализуют следующую логику: "вернуть результат произведения аргумента  number на самого себя". :

	function square(number) {

	  return number * number;
	}

Особенностью декларативного объявления является его "всплытие"(hoisting) в начало функции, независимо от того в каком месте контейтера оно находится. 

В примере ниже декларативное объявление функции находится после вызова:

	{
	  print(square(5));

	  // инициализация "всплывает" вместе с декларацией переменной square
	  // Аналогичный код в функциональном стиле работать не будет
	  function square(n){return n*n}
	}

	В ФУНКЦИОНАЛЬНОМ СТИЛЕ

Функции также могут быть созданы внутри выражения. Такие функции, как правило, анонимны:

	var square = function(number) {
	  return number * number;
	}

Но могут иметь определённое имя. (это имя удобно использовать для рекурсии, или в отладчике(debugger)):

	var factorial = function fac(n) {return n<2 ? 1 : n*fac(n-1)};

	print(factorial(3));

	CТРЕЛОЧНЫЕ ФУНКЦИИ

Современный стандарт языка поддерживает 'аномимные стрелочные функции'(fat arrow function).

	(param1, param2, …, paramN) => { statements }
	(param1, param2, …, paramN) => expression

Они особенно удобны, когда надо задать аргумент для функции высшего порядка:

	[0, 1, 2, 5, 10].map((x) => x * x * x); // вернет [0, 1, 8, 125, 1000].

Помимо упрощённого синтаксиса, такие функции всегда неявно привязываются в МОМЕНТ ОБЪЯВЛЕНИЯ к текущему лексическому контексту выполнения:

	function Person(){
	  this.age = 0;

	  setInterval(() => {
	    this.age++; // в данном случае this будет ссылаться на создаваемый объект obj, а не на window
	  }, 1000);
	}

	var obj = new Person();

Полное описание в статье справочника Functions/Arrow_functions

Смотри также статью на hacks.mozilla.org: "ES6 In Depth: Arrow functions".

	В СТИЛЕ ООП

Учитывая то, что функция по сути является объектом, можно использовать оператор new и Function конструктор чтобы создавать функции динамически во время выполнения (подобно тому как это делает eval()). 

Однако такого подхода следует избегать из соображений производительности и безопасности.

	var powerOfFive = new Function('x',
		          'return ' + Array(5).map(()=>'x').join('*'));

 	МЕТОДЫ

Функции очень часто используются как методы объектов, реализующих ООП. 

Метод - это функция, заданная как значение свойства объекта.

Специальный синтаксис вызова методов позволяет неявно передавать объект в качестве привязки(this).

	class Greeting{

	  constructor(prefix){
	    this.prefix = prefix;
	  }

	  // это метод:
	  hello(name){
	    return `${this.prefix}, ${name}`;
	  }
	}

	var obj = new Greeting("Привет");

	// вызов метода (obj передаётся в качестве контекста `this`)
	obj.hello('Вася');

Больше информации об объектах и методах в Работа с Объектами.

 	ВЫЗОВ ФУНКЦИЙ
Помимо манипуляций c ними как с обычными объектами, функции можно вызывать - запустить процесс вычисления выражений над данными

	Вызов (call) функции - последовательное выполнение управляющий инструкций и выражений из тела функции применительно к входным данным и контексту. 

	Выражение (expression) - комбинация математических и специальных операций, а также вызовов функций, которые описывают способ вычисления результирующего значения(result) в зависимости от входящих данных(input).
 
В момент вызова фунции могут быть переданы 

	•входные данные в виде списка аргументов-значений,
	•а также объект привязки - специальный аргумент, именуемый ключевым словом this.

Кроме этого, выражения в функции могут адресоваться:

	к константам (строковые литералы, числа и т.д.)
	к локальным переменным,
	а также к внешним свободным переменным по цепочке замыкания.

В результате выполнения функция

	возвращает некоторое значение (явно с помощью return или неявно) 
	или бросает исключение.

Например, вызвать  square() можно следующим образом:

	// Функция выполняет свои инструкции над аргументом 5 
	// и возвращает значение-результат 25

	var result = square(5);

Вызов функции должен быть выполнен в пределах её области видимости после того как функция объявлена. Область видимости функции определяется точно также как и для переменной любого другого типа.

	РЕКУРСИЯ

Рекурсивная функция - функция, содержащая вызов самой себя непосредственно в своём теле либо через другие функции.

Классический пример рекурсивной функции вычисляющей факториал:

	function factorial(n) {
	  if ((n == 0) || (n == 1))
	    return 1;
	  else
	    return (n * factorial(n - 1));
	}

	//вычислить факториал пяти:
	var e = factorial(5); // e будет равно 120

	ВЫЗОВ С ПОМОЩЬЮ .apply() и .call()

Существуют и другие способы вызывать функции. Поскольку функции сами являются объектами, они содержат собственные методы. В частности, метод apply(), может использоваться, например, когда нужно адресоваться к функции динамически, или передать различное количество аргументов, или явно указать контекст.

	var fn = resolveAction();
	fn.apply(context, [number1, number2]);

Смотрите Function объект для более детального понимания.

	ПАРАМЕТРЫ И АРГУМЕНТЫ ВЫЗОВА
Параметры функции - список идентификаторов (и возможно сопоставленных им значений по умолчанию и типов данных), заданный В МОМЕНТ ОБЪЯВЛЕНИЯ.

Параметры удобно рассматривать как объявления локальных переменных, каждая из которых инициализируются в МОМЕНТ ВЫЗОВА соответствующим значением из списка аргументов (или значением по умолчанию).

Аргументы(входные данные) функции - произвольный список значений, передаваемых функции В МОМЕНТ ВЫЗОВА.

Соответствие имён параметров и значений аргументов задано тупо порядком их перечисления при обявлении/вызове.
Параметры в  Javascript никак не ограничивают ни количество, ни содержание аргументов.
 

	ПО ЗНАЧЕНИЮ ИЛИ ПО ССЫЛКЕ

Типы аргументов функции могут быть как примитивами (строки, числа, логические(boolean)), так и объектами (включая Array или функции):

Значения-примитивы передаются в функции по значению: значение КОПИРУЕТСЯ, так что если функция изменит значение параметра, это изменение не будет иметь внешнего эффекта.

Объекты передаются в фунцию по ссылке:  переприсваивание самой ссылки также не имеет внешнего эффекта, НО если функция изменяет свойства объекта, то эти изменения будут видимы вне функции (побочный эффект).

пример:  Стрёмный побочный эффект от изменения свойств объекта-аргумента:

	function myFunc(patient) {
	  patient.gender= "F";
	}

	var he = {gender: "M"};

	myFunc(he);

	var y = he.gender;     // y gets the value "F", oops

	Назначение параметру новой ссылки на объект не имеет влияния вне функции. Это продемонстрировано в примере ниже:

	function myFunc(theObject) {
	  theObject = {make: "Ford", model: "Focus", year: 2006};
	}

	var mycar = {make: "Honda", model: "Accord", year: 1998},
	    x,
	    y;

	x = mycar.make;     // x gets the value "Honda"

	myFunc(mycar);
	y = mycar.make;     // y still gets the value "Honda"

В первом случае, объект mycar был передан в функцию myFunc, которая изменила его состояние. Во втором случае, функция не изменяла переданный объект; вместо этого, она создавала новую локальную переменную с тем же именем что и имя параметра функции, так что никак не влияет на глобальный объект передаваемый в функцию.

	ИСПОЛЬЗОВАНИЕ ОБЪЕКТА arguments

Доступ к аргументам может быть получен непосредственно (без обращения по именам объявленных параметров).

Ключевое слово arguments адресует структуру, где содержится список входных аргументов в порядке передачи при вызове. Общее количество аргументов содержится в arguments.length, а значение отдельного аргумента можно получить как arguments[i], где i - порядковый номер аргумента начиная с нуля. Таким образом, например, первый аргумент переданный в функцию будет arguments[0]. .

Используя объект arguments, можно адресоваться к большему количеству аргументов, чем это описано в параметрах функции. Это часто полезно, если вы не знаете заранее как много аргументов будет передаваться в функцию. 

Заметьте, что структура arguments крякает как утка похожа на массив, но массивом не является.

Рассмотрим, например, функцию которая объединяет произвольное количество строк. Единственный аргумент параметр в определении функции - это строка-разделитель:

	function myConcat(separator) {
	   var result = ""; // initialize list
	       
	   // iterate through arguments
	   for (var i = 1; i < arguments.length; i++) {
	      result += arguments[i] + separator;
	   }
	   return result;
	}

	// returns "red, orange, blue, " 
	myConcat(", ", "red", "orange", "blue"); 

	// returns "elephant; giraffe; lion; cheetah; " 
	myConcat("; ", "elephant", "giraffe", "lion", "cheetah");

	АРГУМЕНТЫ И ОПЕРАТОР РАЗВЁРТКИ

Современный стандарт языка позволяет в элегантной функциональной манере отказаться от arguments, заменив его оператором развёртки(spread) (...) :

	const myConcat = (sep, ...strings) => strings.join(sep) // !!!

	ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ

В JavaScript, значения параметров по умолчанию устанавливаются в undefined.

В определённых ситуациях было бы удобно назначать другие значения по умолчанию. В прошлом, общий подход состоял в ручной проверке значения параметра на undefined и в зависимости от результата, установки более подходящего значения по умолчанию:

	function multiply(a, b) {
	  b = typeof b !== 'undefined' ?  b : 1;

	  return a*b;
	}

	multiply(5); // 5

Современный стандарт языка вводит прекрасную возможность явного указания значения по умолчанию с помощью выражения при ОБЪЯВЛЕНИИ функции:

	function multiply(a, b = 1) {
	  return a*b;
	}

	multiply(5); // 5

Заметим что вычисление значения по умолчанию будет происходить В МОМЕНТ ВЫЗОВА функции
 
Также будет нелишним заметить что такие выражения могут адресоваться к предыдущим параметрам:

	function multiply(a, b = 2*a) { return a*b; } 

	multiply(5); // 50

Детальная информация в статье справочника default parameters 

	ОБЛАСТЬ ДАННЫХ И ЗАМЫКАНИЯ

В момент вычисления выражений имена переменных необходимо подменить соответствующими значениями.

Для этих целей в JavaScript реализован  механизм разрешения имён на основе области данных(Scope) и замыканий(Closure):

	var prefix = "Привет";
	function sayHi(name) {
	  var phrase = prefix + ", " + name;
	  alert( phrase );
	}
	// логика разрешения переменных
	RESOLVE = (env, id) => {
	 if (env[id]) return env[id];
	 if (env.OUTER_SCOPE) return RESOLVE(env.OUTER_SCOPE, id);
	 throw new Error('ReferenceError: variable %id is not declared')
	}
	...
	// внешний область данных, актуальный на момент создания функции
	SCOPE = { prefix: "Привет" , sayHi: undefined} 
	...
	// замыкание = функция + внешнее окружение
	var sayHi = { 
	 OUTER_SCOPE: SCOPE, //захвачен в момент создания функции
	 PARAMETERS:['name'] 
	 BODY: ()=>{

	  // внутренняя область данных, создаваемая неявно в момент вызова
	  SCOPE = { 
	    name: 'Вася', 
	    phrase: undefined,
	    OUTER_SCOPE: sayHi.OUTER_SCOPE // образуем цепочку 
	  }

	  var phrase = 
		     RESOLVE(SCOPE,'prefix') // будет извлечён из внешней области
		     + ", "
		     + RESOLVE(SCOPE,'name'); // будет извлечён из внутренней области

	  alert( RESOLVE(SCOPE,'phrase' );

	 }
	}

	// передаётся контекст null и список аргументов
	CALL_FUNCTION(sayHi, null, ['Вася']);

1) Каждый раз В МОМЕНТ ВЫЗОВА функции, происходит неявное создание нового экземпляра области данных(Scope) - специального объекта , где ДО НАЧАЛА ВЫПОЛНЕНИЯ(hoisting) регистрируются

	переменные из списка параметров функции, проинициализированные соответствующими аргументами-значениями.
	переменные, явно объявленные в теле функции с помощью var
	вложенные функции, объявленные в теле в декларативном стиле
	неявная ссылка-замыкание[[OuterScope]] данной функции (образуя цепочку замыканий лексического диапазона)

2) В МОМЕНТ ОБЪЯВЛЕНИЯ объект-функция неявно получает постоянную ссылку [[OuterScope]] на актуальную область переменных  выполняющейся функции-контейнера.

Эта ссылка (или в более общем смысле - связка функция + ссылка) называется замыканием. Она позволяет адресоваться из тела функции  к внешним(свободным) переменным.

3) Если искомое имя переменной не обнаружено в собственной области переменных, то поиск продолжается последовательно вдоль по цепочке замыканий(scope chain) пока имя не будет найдено (в противном случае сработает исключение  ReferenceError).

В спецификации ECMA-262,  присутствует гораздо больше деталей, в частности речь идёт о двух объектах: VariableEnvironment и LexicalEnvironment. Но мы абстрагируемся и используем везде термин Scope, это позволяет достаточно точно описать происходящее.

Более формальное описание находится в спецификации ECMA-262, секции 10.2-10.5 и 13.
Таким образом, общее правило видимости и доступности переменных таково

 "Локальные переменные и параметры функции, видны ТОЛЬКО в пределах этой функции и внутри всех вложенных функций на всю глубину. Они доступны на протяжении всего времени существования функций, которые к ним обращаются."

Замыкание продожает существовать пока существует сама функция (несмотря на то, что внешняя функция возможно уже завершила выполнение и снесена сборщиком мусора).

Таким образом, время жизни локальных переменных функции определяется временем выполнения/использования этой функции и всех вложенных функций.

Современный стандарт языка позволяет определять локальные переменые в рамках отдельно взятого блока кода с помощью let и const. В этом случае, все правила продолжают работать как если бы каждый блок кода был неявной вложенной функцией.

пример:  Вложенная функция incrementor обращается к параметру base внешней функции factory (замыкание продолжает существовать после завершения внешней функции):

	function factory (base) {
	  
	  // returning function has access to external `base` parameter  
	  return function incrementor(inc) { return base + inc; };
	}

	var sum2 = factory(2);

	sum2(5); // Returns 7

пример:  это может быть немного сложнее, но принцип тот же - внутри вложенных функций секс доступен во всех направлениях - на запись и на чтение)).

	var createPet = function(name) {
	  var sex;
	  
	  return {
	    setName: function(newName) {
	      name = newName;
	    },
	    
	    getName: function() {
	      return name;
	    },
	    
	    getSex: function() {
	      return sex;
	    },
	    
	    setSex: function(newSex) {
	      if(typeof newSex == "string" && (newSex.toLowerCase() == "male" || newSex.toLowerCase() == "female")) {
		sex = newSex;
	      }
	    }
	  }
	}

	var pet = createPet("Vivie"); 
	pet.setSex("female"); 
	pet.getName(); // Vivie
	pet.getSex(); // female 

	var pet2 = createPet("Oliver"); 
	pet2.setSex("male"); 
	pet2.getName(); // Oliver
	pet2.getSex();  // male

Переменные внутренней функции могут использоваться в качестве безопасных хранилищ для закрытых(private) данных:

	var getCode = (function(){
	  // никто не попробует сахарку
	  var secureCode = "сахарок";
	​ 
	  return function (token) {
	    return mix(secureCode, token);
	  };
	})();

	getCode();    // Returns the secret code

Если замкнутая функция определяет переменную с тем же именем что и переменная во внешней области видимости, то становится невозможным более получить ссылку на переменную во внешней области видимости.

Пример со перекрытием имён переменных внешней и внутренней функций

	var createPet = function(name) {  // Outer function defines a variable called "name"
	  return {
	    setName: function(name) {    // Enclosed function also defines a variable called "name"
	      name = name;               // ??? How do we access the "name" defined by the outer function ???
	    }
	  }
	}

	ОБЪЕКТ ПРИВЯЗКИ (this)

Oбъект привязки - специальный аргумент, именуемый ключевым словом this.

Основное назначение объекта привязки состоит в поддержке вызовов методов объектов в стиле ООП (см. выше).

	// для методов объекта 
	obj.method(param); // ->  obj.method.call(obj, param)

	// или для внешних функций:
	var obj = {}, fn = function(){};
	obj::fn(param) // -> fn.call(obj, param)

	Ссылка на объект привязки this передаётся

	для обычных функций - каждый раз В МОМЕНТ ВЫЗОВА.
	для стрелочных функций - связывается в МОМЕНТ ОБЪЯВЛЕНИЯ

	Стандарт языка предоставляет средства явного связывания 

	var obj = { some : function (){...} }

	var boundSome = some.bind(obj);

	// или ещё проще:

	var boundSome2 = ::obj.some;

/////////////////////////




















<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Порядок обработки скриптов и таблиц стилей


Важно понимать порядок, в котором происходит обработка скриптов. Рассмотрим следующий пример, где я попытался продемонстрировать все возможные способы подключения скриптов и стилей.


	<html>
	  <head>
		<script src="script1.js"></script>
		<script src="http://site.com/script3.js"></script>

		<script defer src="script4.js"></script>
		<script async src="script5.js"></script>

		<link rel="style" src="style.css"></link>
	  </head>
	  <body>

		...

		<script src="script2.js"></script>

	  </body>
	</html>


Скрипт 1. Первое, что нужно знать про скрипты, — когда при парсинге html анализатор встречает скрипт, он останавливает дальнейший парсинг документа. Т. е., как только анализатор дошел до скрипта 1, браузеру ничего неизвестно о том, что будет дальше. И пока скрипт 1 не выполнится, дальнейший анализ документа происходить не будет.

Но при этом браузер продолжает выполнять ориентировочный синтаксический анализ. Что это значит? Браузер все равно смотрит, что следует за скриптом. Если находятся ссылки на внешние ресурсы, которые нужно скачать и загрузить, он подгрузит эти данные, пока выполняется скрипт 1. Сделано это для оптимизации.

При этом скрипт 3 все равно не будет выполняться, пока не выполнится скрипт 1. К моменту, когда скрипт 1 уже выполнится, скрипт 3 уже может быть полностью загружен. Скрипты можно вставлять в теги head и body. Разница в том, что в скрипте 2, в отличии от скрипта 1, практически весь документ уже будет проанализирован.
У скрипта могут быть атрибуты, такие как defer и async. Они похожи, но у них есть отличия:

Атрибут 'defer' сообщает браузеру, чтобы тот не ждал окончания выполнения скрипта, а продолжал парсинг html-страницы. При этом скрипт 4 выполнится только после того, как весь html-документ будет проанализирован и построено DOM-дерево.
Атрибут 'async' тоже говорит браузеру, что дальнейший html-документ может быть проанализирован, пока скрипт выполняется. Но при этом он выполняется в параллельном потоке, т. е. он на самом деле выполняется асинхронно. Это означает, что он может быть выполнен раньше, чем скрипт1, если последний тоже имеет атрибут async. Т. е. порядок подключения в этом случае не соблюдается.


В случае с defer скрипт 4 всегда выполняется после скрипта 1. С атрибутом async неизвестно, когда он будет выполнен и какая часть документа уже будет проанализирована к этому моменту.




>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Асинхронные скрипты: defer/async
<script src="1.js" async></script>
<script src="2.js" async></script>

<script src="1.js" defer></script>
<script src="2.js" defer></script>
Атрибуты async/defer работают только в том случае, 
если назначены на внешние скрипты, т.е. имеющие src.
...............?????????
		alert(сообщение)
	alert('Привет')
		result = prompt(title, default);  // Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.
	var years = prompt('Сколько вам лет?', 100);
	alert('Вам ' + years + ' лет!')
	var test = prompt("Тест", '');
		result = confirm(question);
	Результатом будет true при нажатии OK и false – при CANCEL(Esc)


Директива выглядит как строка "use strict"; или 'use strict'; и ставится в начале скрипта.

Есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип – объекты object. //TODO

	var user = 'John', age = 25, message = 'Hello';
	var str = "Мама мыла раму";
	var checked = true;
	var age = null;                  //специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

	x = 1;             // число
	x = "Тест";        // строка, кавычки могут быть одинарные или двойные
	x = true;          // булево значение true/false
	x = null;          // спец. значение (само себе тип) «пустое» значение
	x = undefined;     // спец. значение (само себе тип)  «значение не присвоено»

Значение null не является «ссылкой на нулевой адрес/объект» или чем-то подобным. Это просто специальное значение.//TODO
представляющим нулевое или «пустое» значение, то есть, когда нет никакого объектного значения

Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. //TODO
Оно имеет смысл «значение не присвоено».
	var x;
	alert( x ); // выведет "undefined"

	var user = { name: "Вася" };   //объект

Результатом typeof является строка, содержащая тип:
	typeof undefined      // "undefined"
	typeof 0              // "number"
	typeof true           // "boolean"
	typeof "foo"          // "string"
	typeof {}             // "object"
	typeof null           // "object"  (1)
	typeof function(){}   // "function"  (2)

Константа – это переменная, которая никогда не меняется
	var COLOR_ORANGE = "#FF7F00";
	var color = COLOR_ORANGE;
	alert( color ); // #FF7F00

	Операнд – то, к чему применяется оператор
	Унарным называется оператор, который применяется к одному выражению
	Бинарным называется оператор, который применяется к двум операндам

 Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:

	var a = "моя" + "строка"; // моястрока
	alert( '1' + 2 );         // "12"
	alert( 2 + '1' );         // "21"

 Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

	alert( 2 - '1' );  // 1
	alert( 6 / '2' );  // 3

	var a, b, c;
	a = b = c = 2 + 2;
	var c = 3 - (a = b + 1);
	alert( 5 % 2 );        // 1, остаток от деления 5 на 2
	alert( 8 % 3 );        // 2, остаток от деления 8 на 3
	alert( 6 % 3 );        // 0, остаток от деления 6 на 3
	var i = 0;
	alert( ++i ); // 1
	var i = 0;
	alert( i++ ); // 0
	var i = 1;
	alert( 2 * ++i ); // 4
	var i = 1;
	alert( 2 * i++ ); // 2, выполнился раньше но значение вернул старое

Один из самых необычных операторов – запятая ','.
Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается.
	var a = (5, 6);
	alert( a ); // 6
Запятая – единственный оператор, приоритет которого ниже присваивания. В выражении a = (5,6) для явного задания приоритета использованы скобки, 
иначе оператор '=' выполнился бы до запятой ',', получилось бы (a=5), 6.

var b = 3 > 4; // или как результат сравнения
alert( b ); // false

alert( 'Б' > 'А' ); // true
В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.
alert( 'а' > 'Я' ); // true, строчные буквы больше прописных

Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.
alert( 'Банан' > 'Аят' );
alert( 'Вася' > 'Ваня' ); // true, т.к. 'с' > 'н'
При этом любая буква больше отсутствия буквы:
alert( 'Привет' > 'Прив' ); // true, так как 'е' больше чем "ничего".
alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14  //строки сравниваются посимвольно, а первый символ '2' больше '1'
Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними +:
alert( +"2" > +"14" ); // false, теперь правильно
 При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.//TODO
	alert( '2' > 1 ); // true, сравнивается как 2 > 1
	alert( '01' == 1 ); // true, сравнивается как 1 == 1
	alert( false == 0 ); // true, false становится числом 0
	alert( true == 1 ); // true, так как true становится числом 1.
	alert( '' == false ); // true
Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно)(типы сравниваемых значений являются одинаковыми) и !==.
alert( 0 === false ); // false, т.к. типы различны
Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так.
Они ведут себя по-другому.

Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.//TODO
При преобразовании в число null становится 0, а undefined становится NaN.
Значение undefined вообще нельзя сравнивать:

 alert( undefined > 0 ); // false (1)
 alert( undefined < 0 ); // false (2)
 alert( undefined == 0 ); // false (3)
Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, 
что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.
Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null и ничему другому.
Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью.

access = (age > 14) ? true : false;

Последовательность операторов '?' позволяет вернуть значение в зависимости не от одного условия, а от нескольких.

var age = prompt('возраст?', 18);

var message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );

То же самое через if..else:
if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}

	|| запинается на «правде»,
	&& запинается на «лжи».

	alert( true || true ); // true
	alert( false || true ); // true
	alert( true || false ); // true
	alert( false || false ); // false
	alert( true && true ); // true
	alert( false && true ); // false
	alert( true && false ); // false
	alert( false && false ); // false

Преобразование типов для примитивов////////////////
alert( String(null) === "null" ); // true
alert( true + "test" ); // "truetest"
alert( "123" + undefined ); // "123undefined"
var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект
Boolean(value)

Значение     	Преобразуется в...
undefined	    NaN
null	             0
true / false	    1 / 0
Строка	           Пробельные символы по краям обрезаются.
                   Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

alert( +true ); // 1
alert( +false ); // 0
.........................
Метки – единственный способ для break/continue повлиять на выполнение внешнего цикла.
Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:
....................................
outer:
for(;;) {
    ...
  for(;;) {
    ...
    break outer;
  }
}
.....................................
outer: for (var i = 0; i < 3; i++) {

  for (var j = 0; j < 3; j++) {

    var input = prompt('Значение в координатах '+i+','+j, '');

    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // (*)

  }
}
alert('Готово!');
.................................
Аргументы по умолчанию
Если параметр не передан при вызове – он считается равным undefined.

function showMessage(from, text) {
  if (text === undefined) {
    text = 'текст не передан';
  }

  alert( from + ": " + text );
}

showMessage("Маша", "Привет!"); // Маша: Привет!
showMessage("Маша"); // Маша: текст не передан
.............
function calcD(a, b, c) {
   return b*b - 4*a*c;
}

var test = calcD(-4, 2, 1);
alert(test); // 20
..................

function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true

...............
Функциональные выражения////////////////////////////////////////////////////////////////////////////////////
Объявление    Function Expression

	var f = function(параметры) {
	  // тело функции
	};
	...............
	function sayHi() {   // (1)
	  alert( "Привет" );
	}

	var func = sayHi;    // (2)
	func(); // Привет    // (3)

	sayHi = null;
	sayHi();             // ошибка (4)
	...........................................................................................

«Классическое» объявление функции, о котором мы говорили до этого, вида function имя(параметры) {...}, 
называется в спецификации языка «Function Declaration».

	Function Declaration  – функция, объявленная в основном потоке кода.
	Function Expression   – объявление функции в контексте какого-либо выражения, например присваивания.(Функциональное выражение)

	// Function Declaration
	function sum(a, b) {
	  return a + b;
	}

	// Function Expression        (Анонимные)
	var sum = function(a, b) {
	  return a + b;
	}
Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

	sayHi("Вася"); // Привет, Вася

	function sayHi(name) {
	  alert( "Привет, " + name );
	}
	...................
	sayHi("Вася"); // ошибка!

	var sayHi = function(name) {
	  alert( "Привет, " + name );
	}

Function Declaration при use strict видны только внутри блока, в котором объявлены.............................
var age = +prompt("Сколько вам лет?", 20);

if (age >= 18) {
  function sayHi() {
    alert( 'Прошу вас!' );
  }
} else {
  function sayHi() {
    alert( 'До 18 нельзя' );
  }
}

sayHi();

если использовать Function Expression (Анонимные)........................................................................

var age = prompt('Сколько вам лет?');

var sayHi;

if (age >= 18) {
  sayHi = function() {
    alert( 'Прошу Вас!' );
  }
} else {
  sayHi = function() {
    alert( 'До 18 нельзя' );
  }
}

sayHi();

Или даже так:.........................................................................................

 var age = prompt('Сколько вам лет?');

var sayHi = (age >= 18) ?
  function() { alert('Прошу Вас!');  } :
  function() { alert('До 18 нельзя'); };

sayHi();

...............Анонимные функции.............................................................................

	function ask(question, yes, no) {
	    if (confirm(question)) yes()
	    else no();
	  }

	function showOk() {
	  alert( "Вы согласились." );
	}

	function showCancel() {
	  alert( "Вы отменили выполнение." );
	}

	// использование
	ask("Вы согласны?", showOk, showCancel);
	то же самое можно написать более коротко:

	function ask(question, yes, no) {
	  if (confirm(question)) yes()
	  else no();
	}

	ask(
	  "Вы согласны?",
	  function() { alert("Вы согласились."); },
	  function() { alert("Вы отменили выполнение."); }
	);
Здесь функции объявлены прямо внутри вызова ask(...), даже без присвоения им имени.

 Функциональное выражение, которое не записывается в переменную, называют АНОНИМНОЙ функцией.
..............................
Пора немного потренироваться в передаче функций другим функциям.(с.465 javaScript O'Reilly)
	function sayIt(translator) {
		var phrase = translator("Hello");
		alert(phrase);
	}
	function hawaiianTranslator(word) {
		if (word = = = "Hello") return "Aloha";
		if (word = = = "Goodbye") return "Aloha";
	}
	sayIt(hawaiianTranslator);

.........new Function...........................
функция создаётся вызовом new Function(params, code)

	var sum = new Function('a,b', ' return a+b; ');
	var result = sum(1, 2);
	alert( result ); // 3
...................................................

Области видимости

Каждая функция, точнее даже каждый запуск функции задает свою индивидуальную область видимости.

Переменные можно объявлять в любом месте. Ключевое слово var задает переменную в текущей области видимости. Если его забыть, то переменная попадет в глобальный объект window. Возможны неожиданные пересечения с другими переменными окна, конфликты и глюки.

	function f() {
	  a = 4;                   // будет глобальной(даже если она впервые используется внутри функции)
	}

Если функции передано меньше параметров, чем есть в определении, то отсутствующие считаются undefined.
..............................................................................
Если нет явной причины использовать Function Expression – предпочитайте Function Declaration.
...................
Специально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, которое называется 
«Named Function Expression» (сокращённо NFE) или, по-русски, «именованное функциональное выражение».

	var f = function sayHi(...) { /* тело функции */ };
	Имя функционального выражения (sayHi) имеет особый смысл. Оно доступно только изнутри самой функции.
	var f = function sayHi(name) {
	  alert( sayHi ); // изнутри функции - видно (выведет код функции)
	};

	alert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')
	Кроме того, имя NFE нельзя перезаписать:
	var test = function sayHi(name) {
	  sayHi = "тест"; // попытка перезаписи
	  alert( sayHi ); // function... (перезапись не удалась)
	};

	test();

Как правило, имя NFE используется для единственной цели – позволить изнутри функции вызвать саму себя.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	alert( "Привет, мир!".length ); // 12
	var str = "Привет, мир!";
	alert( str.length ); // 12

	var hello = "Привет, мир!";
	alert( hello.toUpperCase() ); // "ПРИВЕТ, МИР!"

	var n = 12.345;
	alert( n.toFixed(2) ); // "12.35"
	alert( n.toFixed(0) ); // "12"
	alert( n.toFixed(5) ); // "12.34500"

	alert( 12.34.toFixed(1) ); // 12.3
	alert(12.toFixed(1)); // ошибка!
	alert( 12..toFixed(1) ); // 12.0

	alert( 0xFF ); // 255 в шестнадцатиричной системе
	// еще пример научной формы: 3 с 5 нулями
	alert( 3e5 ); // 300000
	// здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
	alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль

	alert( 1 / 0 ); // Infinity
	alert( 12345 / 0 ); // Infinity
	Infinity – особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.
	Infinity больше любого числа.
	Добавление к бесконечности не меняет её.
	alert( Infinity > 1234567890 ); // true
	alert( Infinity + 5 == Infinity ); // true

	Бесконечность можно присвоить и в явном виде: var x = Infinity
	Бывает и минус бесконечность -Infinity:
	alert( -1 / 0 ); // -Infinity
	alert( 1e500 ); // Infinity

	Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).
	alert( 0 / 0 ); // NaN
	Значение NaN используется для обозначения математической ошибки и обладает следующими свойствами:
	Значение NaN – единственное, в своем роде, которое не равно ничему, включая себя.
	Следующий код ничего не выведет:
	if (NaN == NaN) alert( "==" ); // Ни один вызов
	if (NaN === NaN) alert( "===" ); // не сработает
	Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, 
	и false – для любого другого значения.
	var n = 0 / 0;
	alert( isNaN(n) ); // true
	alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
	Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN
	alert( NaN + 1 ); // NaN
	Если аргумент isNaN – не число, то он автоматически преобразуется к числу.

	Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
	alert( isFinite(1) ); // true
	alert( isFinite(Infinity) ); // false
	alert( isFinite(NaN) ); // false

	var s = "12.34";
	alert( +s ); // 12.34   //Преобразование к числу,перед значением ставят унарный плюс '+'
	alert( +"12test" ); // NaN
	alert( +"  -12" ); // -12
	alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
	alert( +"" ); // 0, пустая строка становится нулем
	alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
	alert( '12.34' / "-2" ); // -6.17

	В мире HTML/CSS многие значения не являются в точности числами. Например, метрики CSS: 10pt или -12px.
	Оператор '+' для таких значений возвратит NaN:
	alert( parseInt('12px') ); // 12
	Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
	alert( parseInt('12px') ) // 12, ошибка на символе 'p'
	alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
	alert( parseInt('a123') ); // NaN
	alert( parseInt('FF', 16) ); // 255

	Проверка на число
	function isNumeric(n) {
	  return !isNaN(parseFloat(n)) && isFinite(n);
	}

	toString(система счисления)
	Основание может быть любым от 2 до 36.
	var n = 255;
	alert( n.toString(16) ); // ff

	var n = 4;
	alert( n.toString(2) ); // 100

	var n = 1234567890;
	alert( n.toString(36) ); // kf12oi

	Округление

	alert( Math.floor(3.1) );  // 3    Округляет вниз
	alert( Math.ceil(3.1) );   // 4    Округляет вверх
	alert( Math.round(3.1) );  // 3     Округляет до ближайшего целого

	var n = 12.34;
	alert( n.toFixed(1) ); // "12.3"  кругляет число num до точности precision и возвращает результат в виде строки
	var n = 12.34;
	alert( +n.toFixed(5) ); // 12.34

	alert( 0.1 + 0.2 ); // 0.30000000000000004

	Другие математические методы////////////////////////////////////////////////////////////////////////////////////////////////

	Тригонометрия
	Встроенные функции для тригонометрических вычислений:

	Math.acos(x)     
	Возвращает арккосинус x (в радианах)
	Math.asin(x)
	Возвращает арксинус x (в радианах)
	Math.atan(x)
	Возвращает арктангенс x (в радианах)
	Math.atan2(y, x)
	Возвращает угол до точки (y, x). Описание функции: Atan2.
	Math.sin(x)
	Вычисляет синус x (в радианах)
	Math.cos(x)
	Вычисляет косинус x (в радианах)
	Math.tan(x)
	Возвращает тангенс x (в радианах)

	Функции общего назначения
	Разные полезные функции:
	Math.sqrt(x)
	Возвращает квадратный корень из x.
	Math.log(x)
	Возвращает натуральный (по основанию e) логарифм x.
	Math.pow(x, exp)
	Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
	Math.abs(x)
	Возвращает абсолютное значение числа
	Math.exp(x)
	Возвращает ex, где e – основание натуральных логарифмов.
	Math.max(a, b, c...)
	Возвращает наибольший из списка аргументов
	Math.min(a, b, c...)
	Возвращает наименьший из списка аргументов
	Math.random()
	Возвращает псевдо-случайное число в интервале [0,1) – то есть между 0(включительно) и 1(не включая). Генератор случайных чисел инициализуется текущим временем.
	Форматирование
	Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():

	 var number = 123456789;
	alert( number.toLocaleString() ); // 123 456 789

.............. Строки........../////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	Специальные символы
	\b	Backspace
	\f	Form feed
	\n	New line
	\r	Carriage return
	\t	Tab
	\uNNNN	Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\u00A9` -- юникодное представление символа копирайт ©

Экранирование специальных символов
	var str = 'I\'m a JavaScript programmer';
	var str = "I'm a JavaScript \"programmer\" ";
	alert( str ); // I'm a JavaScript "programmer"
................................................
	var str = "My\n"; // 3 символа. Третий - перевод строки
	alert( str.length ); // 3

	var str = "jQuery";
	alert( str.charAt(0) ); // "j"              //Чтобы получить символ, используйте вызов charAt(позиция)

	var str = "Я - современный браузер!";
	alert( str[0] ); // "Я"
	Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined:
	alert( "".charAt(0) ); // пустая строка
	alert( "" [0] ); // undefined
Обратите внимание, str.length – это свойство строки, а str.charAt(pos) – метод, т.е. функция.

Изменения строк
	var str = "строка";
	str = str[3] + str[4] + str[5];
	alert( str ); // ока

	alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС
	alert( "Интерфейс" [0].toLowerCase() ); // 'и'

Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
	ar str = "Widget with id";
	alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
	alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
	alert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр

Поиск всех вхождений
	var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
	var target = "Иа"; // цель поиска

	var pos = 0;
	while (true) {
	  var foundPos = str.indexOf(target, pos);
	  if (foundPos == -1) break;

	  alert( foundPos ); // нашли на этой позиции
	  pos = foundPos + 1; // продолжить поиск со следующей
	}

Взятие подстроки: substr, substring, slice.
substring(start [, end])
Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.
	var str = "stringify";
	alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
Если аргумент end отсутствует, то идет до конца строки:
	var str = "stringify";
	alert(str.substring(2)); // ringify, символы с позиции 2 до конца
substring()	Extracts the characters from a string, between two specified indices
var str = "Hello world!";
var res = str.substring(1, 4);  // ell
The substring() method extracts the characters from a string, between two specified indices, and returns the new sub string.
This method extracts the characters in a string between "start" and "end", not including "end" itself.
If "start" is greater than "end", this method will swap the two arguments, meaning str.substring(1,4) == str.substring(4,1).
If either "start" or "stop" is less than 0, it is treated as if it were 0.
Note: The substring() method does not change the original string.


substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.
	var str = "stringify";
	str = str.substr(2,4); // ring, со 2-й позиции 4 символа
	alert(str)
Если второго аргумента нет – подразумевается «до конца строки».
substr()	Extracts the characters from a string, beginning at a specified start position, and through the specified number of character
var str = "Hello world!";
var res = str.substr(1, 4); // ello
The substr() method extracts parts of a string, beginning at the character at the specified position, and returns the specified number of characters.
Tip: To extract characters from the end of the string, use a negative start number (This does not work in IE 8 and earlier).
Note: The substr() method does not change the original string.


slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.

Отрицательные аргументы
Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:
alert( "testme".substring(-2) ); // "testme", -2 становится 0
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
alert( "testme".substring(4, -1) ); // "test"
// -1 становится 0 -> получили substring(4, 0)
// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"

slice
Отрицательные значения отсчитываются от конца строки:
alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.

!!!! Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет slice: 
он и отрицательные аргументы поддерживает и работает наиболее очевидно.

String.fromCharCode(code)
Возвращает символ по коду code:
alert( String.fromCharCode(1072) ); // 'а'

str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.
 alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'

символы сравниваются не по алфавиту, а по коду
Строчные буквы идут после заглавных, поэтому они всегда больше.
Ряд букв, например ё, находятся вне основного алфавита.


var str = "Ёлки";
alert( str.localeCompare("Яблони") ); // -1
Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.

charAt()
 method returns the character at the specified index in a string
The index of the first character is 0, the second character is 1, and so on.
var str = "HELLO WORLD";
var res = str.charAt(0); //  H

concat()	Joins two or more strings, and returns a new joined strings
var str1 = "Hello ";
var str2 = "world!";
var res = str1.concat(str2); // Hello world!

includes()	Checks whether a string contains the specified string/characters
This method returns true if the string contains the characters, and false if not.
var str = "Hello world, welcome to the universe.";
var n = str.includes("world");      // true

indexOf()	Returns the position of the first found occurrence of a specified value in a string
This method returns -1 if the value to search for never occurs.
var str = "Hello world, welcome to the universe.";
var n = str.indexOf("welcome");  // 13

localeCompare()	Compares two strings in the current locale

match()	Searches a string for a match against a regular expression, and returns the matches,as an Array object.
Note: If the regular expression does not include the g modifier (to perform a global search), the match() method will return only the first match in the string.
This method returns null if no match is found.
var str = "The rain in SPAIN stays mainly in the plain"; 
var res = str.match(/ain/g);  // ain,ain,ain

repeat()	Returns a new string with a specified number of copies of an existing string
var str = "Hello world!";
str.repeat(2); // Hello world!Hello world!

replace()	Searches a string for a specified value, or a regular expression, and returns a new string where the specified values are replaced
var str = "Visit Microsoft!";
var res = str.replace("Microsoft", "W3Schools"); // Visit W3Schools!
Note: If you are replacing a value (and not a regular expression), only the first instance of the value will be replaced. To replace all occurrences of a specified value, use the global (g) modifier (see "More Examples" below).

search()	Searches a string for a specified value, or regular expression, and returns the position of the match
var str = "Visit W3Schools!";
var n = str.search("W3Schools"); // 6
The search value can be string or a regular expression.
This method returns -1 if no match is found.

slice()	Extracts a part of a string and returns a new string
var str = "Hello world!";
var res = str.slice(1,5); // ello
Use the start and end parameters to specify the part of the string you want to extract.
The first character has the position 0, the second has position 1, and so on.
Tip: Use a negative number to select from the end of the string.

split()	Splits a string into an array of substrings
var str = "How are you doing today?";
var res = str.split(" "); // The result of res will be an array with the values: How,are,you,doing,today?
The split() method is used to split a string into an array of substrings, and returns the new array.
Tip: If an empty string ("") is used as the separator, the string is split between each character.
Note: The split() method does not change the original string.

startsWith()	Checks whether a string begins with specified characters
endsWith()	Checks whether a string ends with specified string/characters

toLocaleLowerCase()	Converts a string to lowercase letters, according to the host's locale
toLocaleUpperCase()	Converts a string to uppercase letters, according to the host's locale
toLowerCase()	        Converts a string to lowercase letters
toString()	        Returns the value of a String object
toUpperCase()	        Converts a string to uppercase letters
trim()	                Removes whitespace from both ends of a string
valueOf()	        Returns the primitive value of a String object


////////////////////////////////
Объект можно заполнить значениями при создании, указав их в фигурных скобках: { ключ1: значение1, ключ2: значение2, ... }.
Пустой объект («пустой шкаф») может быть создан одним из двух синтаксисов:
1. o = new Object();
2. o = {}; // пустые фигурные скобки
/ при присвоении свойства в объекте автоматически создаётся "ящик"
// с именем "name" и в него записывается содержимое 'Вася'
person.name = 'Вася';
person.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25
Свойства можно удалять из объектов оператором delete.
delete person.age;


Цикл for in перебирает все свойства объекта в произвольном порядке.
for (var key in menu) {
// этот код будет вызван для каждого свойства объекта
  // ..и выведет имя свойства и его значение

  alert( "Ключ: " + key + " значение: " + menu[key] );
}
console.log(key + ": " + menu[key]);
Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).

Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
Его синтаксис: "prop" in obj, причем имя свойства – в виде строки, например:
if ("name" in person) {
  alert( "Свойство name существует!" );
}
Впрочем, чаще используется другой способ – сравнение значения с undefined.
var person = {
  name: "Василий"
};

alert( person.lalala === undefined ); // true, свойства нет
alert( person.name === undefined ); // false, свойство есть.

var person = {};
person['name'] = 'Вася'; // то же что и person.name = 'Вася'
.........................
Итого:
Объекты – это ассоциативные массивы с дополнительными возможностями:
Доступ к элементам осуществляется:
Напрямую по ключу obj.prop = 5
Через переменную, в которой хранится ключ:
var key = "prop";
obj[key] = 5
Удаление ключей: delete obj.name.
Существование свойства может проверять оператор in: if ("prop" in obj), как правило, работает и просто сравнение if (obj.prop !== undefined).
..................

В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.
var user = { name: "Вася" }; // в переменной - ссылка
var admin = user; // скопировали ссылку

При присваивании объекта переменной в переменной хранится ссылка на объект, а не сам объект.
Еще раз напомним, что ссылку можно рассматривать как указатель на объект.
При вызове функции и передаче ей объекта вы передаете не сам объект, а ссылку на него. Получается, что при использовании семантики
передачи по значению в параметре передается копия ссылки, которая также указывает на исходный объект.
Представьте себе this как переменную, которой присваивается объект, чей метод был только что вызван. Иначе говоря, если
вы­звать метод start объекта fiat в записи fiat.start() и использовать this в теле метода start , это ключевое слово будет ссылаться на объект fiat.
this в теле этого метода будет указывать на объект, метод которого был вызван.
Чтобы обратиться к свойствам объекта в методе,
необходимо использовать точечную запись с ука-
занием this вместо имени объекта.



В отличие от переменных, содержащих примитив-
ные значения (строки, числа и булевские вели-
чины), переменная не может содержать объект.
Вместо этого в ней хранится ссылка на объ-
ект. Такие переменные называются ссылочными.
При передаче объекта функция получает копию
ссылки на объект, а не копию объекта. Таким обра-
зом, изменение свойств объекта в функции приво-
дит к изменениям в исходном объекте.
Для вызова методов мы указываем имя свойства (вместо того, чтобы явно назначить имя функции и обращаться к ней по этому имени)

Новый метод можно добавить в любой момент:
// Добавление метода engageTurbo
car.engageTurbo =
function() { ... };

..................
chevy.color          =              chevy["color"]
Эти две формы эквивалентны и делают одно и то же.
chevy["co" + "lor"]
...........
Объектный литерал представляет собой полное описание объекта:
	var fiat = {
		make: "Fiat",
		model: "500",
		year: 1957,
		color: "Medium Blue",
		passengers: 2,
		convertible: false,
		mileage: 88000,
		fuel: 0,
		started: false,
		start: function() {
				if (this.fuel == 0) {
							alert("The car is on empty, fill up before starting!");
				} else {
							this.started = true;
					}
			},

		stop: function() {
				this.started = false;
			},
		drive: function() {
				if (this.started) {
						if (this.fuel > 0) {
								alert(this.make + " " + this.model + " goes zoom zoom!");
								this.fuel = this.fuel - 1;
						} else {
								alert("Uh oh, out of fuel.");
								this.stop();
							}
						} else {
								alert("You need to start the engine first.");
							}
						},
		addFuel: function(amount) {
					this.fuel = this.fuel + amount;
			}
Объектные литералы позволяют легко создавать объекты в любой точке кода.
......................................................................................................
Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.
	var user = {
	  name: "Вася",
	  age: 30
	};

	var clone = {}; // новый пустой объект

// скопируем в него все свойства user
	for (var key in user) {
	  clone[key] = user[key];
	}
// теперь clone - полностью независимая копия
	clone.name = "Петя"; // поменяли данные в clone
	alert( user.name ); // по-прежнему "Вася"

Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.
..................................................
Конструкторы объектов, или сокращенно «конструкторы»
В программном коде конструктор напоминает функцию, возвращающую объект: он определяется один раз, а затем вызывается везде, где потребуется создать новый объект.
Использование конструкторов проходит в два этапа: сначала мы создаем конструктор, а потом используем его для создания объектов.

  function Dog(name, breed, weight) {
        this.name = name;
        this.breed = breed;
        this.weight = weight;
  }

 var fido = new Dog("Fido", "Mixed", 38);
У конструкторов есть одна особенность, к которой нужно относиться очень внимательно:не забывайте про ключевое слово new .
Cначала new создает новый, пустой объект:
Затем new заносит в this ссылку на новый объект.
После подготовки this вызывается функция Dog,которой передаются аргументы "Fido", "Mixed" и 38.
Затем вызывается тело функции. Как и большинство конструкторов, Dog задает значения свойств только что созданного объекта this.
Наконец, после того как функция Dog будет выполнена, оператор new возвращает this, то есть ссылку на только что созданный объект. Обратите внимание: ссылка this возвра-
щается автоматически, вам не придется явно возвращать ее в своем коде. И после того как новый объект будет возвращен, эта ссылка присваивается переменной fido.
Наряду со свойствами в конструкторе могут задаваться методы объекта. Расширим код конструктора Dog и включим в него метод bark :

имена конструкторов начинаются с прописной буквы (помогает отличить конструкторы от обычных функций.)
function Dog(name, breed, weight) {
        this.name = name;
        this.breed = breed;
        this.weight = weight;

        this.bark = function() {
             if (this.weight > 25) {
                alert(this.name + " says Woof!");
             } else {
                alert(this.name + " says Yip!");
             }
        };
}

Пример
var fido = new Dog("Fido", "Mixed", 38);
var fluffy = new Dog("Fluffy", "Poodle", 30);
var spot = new Dog("Spot", "Chihuahua", 10);
       var dogs = [fido, fluffy, spot];
           for (var i = 0; i < dogs.length; i++) {
                   dogs[i].bark();
           }

fido.bark();

С конструктором можно делать все то же, что и с обычной функцией: объявлять и использовать переменные,
включать циклы for, вызывать другие функции и т. д. Единственное, чего не следует делать в конструкторе, так это возвращать
значение (отличное от this), потому что в этом случае конструктор не вернет объект, который ему положено конструировать.

Объектные литералы иногда упрощают код, делают его более понятным и упрощают его сопровождение.
Пример:
1.
function Car(make, model, year, color, passengers, convertible, mileage) {
	this.make = make;
	this.model = model;
	this.year = year;
	this.color = color;
	this.passengers = passengers;                                               // приходится следить за тем, чтобы параметры передавались строго в указанном порядке
	this.convertible = convertible;
	this.mileage = mileage;
	this.started = false;
	}
	this.start = function() {
	    this.started = true;
	};
	// Остальные методы
}
var cadi = new Car("GM", "Cadillac", 1955, "tan", 5, false, 12892);

2.
	var cadiParams = { make: "GM",
		model: "Cadillac",
		year: 1955,
		color: "tan",
		passengers: 5,
		convertible: false,
		mileage: 12892 };

	var cadi = new Car(cadiParams);

	function Car(params) {
		this.make = params.make;
		this.model = params.model;
		this.year = params.year;
		this.color = params.color;
		this.passengers = params.passengers;
		this.convertible = params.convertible;
		this.mileage = params.mileage;
		this.started = false;

		this.start = function() {
		     this.started = true;
		};
		this.stop = function() {
		     this.started = false;
		};
		this.drive = function() {
		    if (this.started) {
		       alert("Zoom zoom!");
		    } else {
		       alert("You need to start the engine first.");
		    }
	       };
	}

	cadi.start();
	cadi.drive();
	cadi.drive();
	cadi.stop();


if (cadi instanceof Car) {
console.log("Congrats, it's a Car!");            // Оператор instanceof возвращает true, если объект был создан указанным конструктором.
};

Оператор instanceof использует эту информацию для проверки того,является ли объект экземпляром, созданным указанным конструктором.
В JavaScript объекты являются динамическими структурами и относятся к типу “object” независимо от того, какие свойства или методы они содержат.
Конструкторы не запрещают изменять объект, поскольку это можно проделать после того, как объект создан.
	var fido = new Dog("Fido", "Mixed", 38);
	fido.owner = "Bob";             //Мы можем добавить новое свойство, просто задавая его значение в объекте.
	delete fido.weight;          // А можем удалить свойство оператором delete.
 В объекты даже можно добавлять новые методы:
   Чтобы добавить новый метод, назначьте метод свойству с новым именем в объекте.

	fido.trust = function(person) {
			     return (person = = = "Bob");
	             };

Обратите внимание: здесь изменяется ТОЛЬКО объект fido . Если добавить метод в fido ,то метод появится только в этом объекте.
    var notBite = fido.trust("Bob");  // Переменной notBite присваивается значение true.
..............................
JavaScript поставляется с набором готовых конструкторов для создания экземпляров полезных объектов, например объектов для работы
с датой и временем, объектов для поиска текста по шаблону и даже объектов, расширяющих возможности работы с массивами.
Пример
Начнем со встроенного объекта даты. Для создания этого объекта 
используется следующий конструктор:
var now = new Date(); // Вызов конструктора Date возвращает экземпляр Date, представляющий текущее местное время и дату.
var dateString = now.toString();  // Возвращает строковое представление даты вида “Thu Feb 06 2014 17:29:29 GMT-0800 (PST)”.
var theYear = now.getFullYear(); // Возвращает год из даты.
var theDayOfWeek = now.getDay();   //  Возвращает номер дня недели, представленного объектом даты, например 1 (понедельник).


Еще один интересный встроенный объект предназначен для работы с массивами.
var oddNumbers = new Array(3);   // Создаем массив длины 3 и заполняем данными уже после создания
oddNumbers[0] = 1;
oddNumbers[1] = 3;
oddNumbers[2] = 5;

oddNumbers.reverse(); // 5,3,1
var aString = oddNumbers.join(" - "); // Метод join создает строку из значений oddNumbers, разделяя их последовательностью “ - ”, и возвращает полученную строку.“5 - 3 - 1” 
var areAllOdd = oddNumbers.every(function(x) {
                  return ((x % 2) != = 0);
});
Метод every получает функцию, и для каждого значения в массиве проверяет,какой результат вернет функция для этого значения — true или false. Если функция
возвращает true для всех элементов массива, то и метод every возвращает true.








..........................................
В JavaScript используется модель наследования через прототипы; соответственно, объект, от которого наследуется поведение, называется прототипом.Вся суть этой схемы
заключается в наследовании и повторном использовании существующих свойств (включая методы), с расширением свойств во вновь созданном объекте.
Свойства и методы всегда можно переопределить в объекте.Переопределение работает, потому что JavaScript всегда обращается за свойством к экземпляру (то есть конкретному объекту) до того, как продолжить поиски в прототипе.Если метод вызывается для экземпляра, в котором указанный метод отсутствует, проверяется прототип метода.Свойства работают примерно так же.
Свойства и методы всегда можно переопределить в объекте.Переопределение работает,потому что JavaScript всегда обращается за свойством к экземпляру (то есть конкретному объекту собаки) до того,как продолжить поиски в прототипе.
  Dog.prototype
В двух словах:
в JavaScript функции являются объектами. Более того, в JavaScript практически все базируется на объектах — даже массивы.
Просто знайте, что функции (помимо всего, что вы о них уже знаете) могут обладать свойствами, и в данном случае конструктор всегда содержит свойство prototype.
Объект-прототип задается в свойстве prototype конструктора "Dog".(c.592)

	function Dog(name, breed, weight) {          // Конструктор Dog
	this.name = name;
	this.breed = breed;
	this.weight = weight;
	}

       // А здесь в прототипе добавляются свойства и методы.
       //  Мы добавляем в прототип одно свойство и три метода.

	Dog.prototype.species = "Canine";          

	Dog.prototype.bark = function() {
		if (this.weight > 25) {
		console.log(this.name + " says Woof!");
		} else {
		console.log(this.name + " says Yip!");
		}
	};

	Dog.prototype.run = function() {
		console.log("Run!");
	};
	Dog.prototype.wag = function() {
		console.log("Wag!");
	};

	// Затем объекты создаются , как обычно...

	var fido = new Dog("Fido", "Mixed", 38);
	var fluffy = new Dog("Fluffy", "Poodle", 30);
	var spot = new Dog("Spot", "Chihuahua", 10);

	fido.bark();
	fido.run();
	fido.wag();

	fluffy.bark();
	fluffy.run();
	fluffy.wag();

	spot.bark();
	spot.run();
	spot.wag();

   // Чтобы предоставить ему(spot) нестандартный метод bark, необходимо переопределить прототип.

	var spot = new Dog("Spot", "Chihuahua", 10);

	spot.bark = function() {
		console.log(this.name + " says WOOF!");  //объект spot получает собственную реализацию метода bark.
	};

	spot.bark();
	spot.run();
	spot.wag();


Когда вы вызываете метод объекта, ссылке this присваивается объект, метод которого был вызван. Если метод в этом объекте отсутствует, но обнару-
живается в прототипе, это не влияет назначение this . Ссылка this всегда ссылается на исходный объект — то есть объект, метод которого был вызван,
даже если метод находится в прототипе.

Когда у нас имеется прототип, при добавлении в него каких-либо методов (даже после того, как мы уже создали объекты),все объекты, наследующие
от прототипа, немедленно и автоматически получают новое поведение.
	var barnaby = new Dog("Barnaby", "Basset Hound", 55);

	Dog.prototype.sit = function() {
	console.log(this.name + " is now sitting");
	}

	barnaby.sit();

Если вы изменяете свойство в прототипе, такое изменение отражается на всех объектах, наследующих от прототипа, если только объект не переопределил это свойство.

Давайте сделаем метод sit чуть более интересным: в исходном состоянии собака стоит. Если при получении команды «сидеть» собака стоит, она садится. В противном случае выводится сообщение о том,что собака уже сидит. Для этого нам понадобится дополнительное свойство sitting , в котором будет храниться информация о том, сидит собака или нет. Код будет выглядеть так:

	Dog.prototype.sitting = false;

	Dog.prototype.sit = function() {
		if (this.sitting) {
			console.log(this.name + " is already sitting");
		} else {
			this.sitting = true;
			console.log(this.name + " is now sitting");
		}
	};
	
Обратите внимание: экземпляр теперь имеет собственное локальное свойство sitting, равное true.
В этом коде прежде всего стоит обратить внимание на то, что в начале своего существования экземпляр наследует значение по умолчанию для sitting . Но при вызове метода sit экземпляр добавляет собственное значение sitting , в результате чего новое свойство создается в экземпляре. Оно переопределяет унаследованное свойство sitting из прототипа. Таким образом, мы можем определить значение по умолчанию для всех объектов, а затем, если понадобится, создать его специализированную версию в каждом конкретном объекте.
с.601









////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Синтаксис для создания нового массива – квадратные скобки со списком элементов внутри.
Пустой массив:
var arr = [];
Массив fruits с тремя элементами:
var fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits.length ); // 3
alert( fruits ); // Яблоко,Апельсин,Груша
alert( fruits.pop() ); // удалили "Груша"]
fruits.push("Груша");// Добавляет элемент в конец массива:
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....
alert( fruits.shift() ); // удалили Яблоко
fruits.unshift('Яблоко'); //Добавляет элемент в начало массива:
Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.
Ещё одно следствие – можно присваивать в массив любые свойства.
var arr = ["Яблоко", "Апельсин", "Груша"];
for (var i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
Не используйте for..in для массивов
// микс значений
var arr = [ 1, 'Имя', { name: 'Петя' }, true ];

// получить объект из массива и тут же -- его свойство
alert( arr[2].name ); // Петя
............................
При уменьшении length массив укорачивается.
var arr = [1, 2, 3, 4, 5];

arr.length = 2; // укоротить до 2 элементов
alert( arr ); // [1, 2]

arr.length = 5; // вернуть length обратно, как было
alert( arr[3] ); // undefined: значения не вернулись
.....................
var arr = new Array(2, 3);  //Существует еще один синтаксис для создания массива
alert( arr[0] ); // 2, создан массив [2, 3], всё ок

arr = new Array(2); // создаст массив [2] ?
alert( arr[0] ); // undefined! у нас массив без элементов, длины 2
...................................
Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:
var matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // центральный элемент
//////////////////////////////////////////////////
Объектная модель документа (DOM) – это внутреннее представление HTML-страницы в виде дерева.
Глобальный объект document даёт возможность взаимодействовать с содержимым страницы.
объект document, формально, является DOM-узлом, самым-самым корневым.
Всего различают 12 типов узлов, но на практике мы работаем с четырьмя из них:

Документ – точка входа в DOM.
Элементы – основные строительные блоки.
Текстовые узлы – содержат, собственно, текст.
Комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна из JS.
Узел HTML можно получить как document.documentElement, а BODY – как document.body.
У элементов DOM есть свойства и методы, которые позволяют изменять их. 
IE8- не генерирует пробельные узлы.
document.body.style.background = 'red';
alert( 'Элемент BODY стал красным, а сейчас обратно вернётся' );
document.body.style.background = '';

Объектная модель браузера (BOM)
BOM – это объекты для работы с чем угодно, кроме документа.

Например:

Объект navigator содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства: navigator.userAgent – содержит информацию о браузере и navigator.platform – содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.
Объект location содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.
Функции alert/confirm/prompt – тоже входят в BOM.
alert( location.href ); // выведет текущий адрес
......................................
Массивы: методы              >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s.

var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ');
for (var i = 0; i < arr.length; i++) {
  alert( 'Вам сообщение ' + arr[i] );
}
.........
 метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен:

                              alert( "a,b,c,d".split(',', 2) ); // a,b
.......................................................
ызов split с пустой строкой разобьёт по буквам:
var str = "тест";
alert( str.split('') ); // т,е,с,т
..........................................................................
Метод join
Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.
var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');// Маша;Петя;Марина;Василий
.................
 new Array(4).join("ля"); // ляляля
Как видно, new Array(4) делает массив без элементов длины 4, который join объединяет в строку, вставляя между его элементами строку "ля".
В результате, так как элементы пусты, получается повторение строки. Такой вот небольшой трюк.

.....................................

Удаление из массива
Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete (Удаляет объект, свойство объекта или элемент массива по указанному индексу.)
var arr = ["Я", "иду", "домой"];
delete arr[1]; // значение с индексом 1 удалено

// теперь arr = ["Я", undefined, "домой"];
alert( arr[1] ); // undefined
Да, элемент удален из массива, но не так, как нам этого хочется. Образовалась «дырка».
Поэтому для удаления используются специальные методы: из начала – shift, с конца – pop, а из середины – splice, с которым мы сейчас познакомимся.

Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.
arr.splice(index[, deleteCount, elem1, ..., elemN])  Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов.
Начнём с удаления:
var arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); //  осталось ["Я", "JavaScript"]

	var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 3 первых элемента и добавить другие вместо них
	arr.splice(0, 3, "Мы", "изучаем")
	alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"]
Здесь видно, что splice возвращает массив из удаленных элементов:
	var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 2 первых элемента
	var removed = arr.splice(0, 2);
	alert( removed ); // "Я", "сейчас" <-- array of removed elements
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
	var arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0
// вставить "сложный", "язык"
	arr.splice(2, 0, "сложный", "язык");
	alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
 	var arr = [1, 2, 5]
// начиная с позиции индексом -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
	arr.splice(-1, 0, 3, 4);
	alert( arr ); // результат: 1,2,3,4,5

Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
	var arr = ["Почему", "надо", "учить", "JavaScript"];
	var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
	alert( arr2 ); // надо, учить
Если не указать end – копирование будет до конца массива:
	 var arr = ["Почему", "надо", "учить", "JavaScript"];
	alert( arr.slice(1) ); // взять все элементы, начиная с номера 1
Можно использовать отрицательные индексы, они отсчитываются с конца:
	var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше
Если вообще не указать аргументов – скопируется весь массив:
	var fullCopy = arr.slice();

Сортировка, метод sort(fn)   // ««быстрая сортировка»»
	var arr = [ 1, 2, 15 ];
	arr.sort();
	alert( arr );  // 1, 15, 2
Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.// "2" > "15".
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
	function compareNumeric(a, b) {
  		if (a > b) return 1;
  		if (a < b) return -1;
	}

	var arr = [ 1, 2, 15 ];
	arr.sort(compareNumeric);  //  compareNumeric, без вызова через скобки
	alert(arr);  // 1, 2, 15
Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, их взаимный порядок не имеет значения.
	[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  		alert( a + " <> " + b );
	});

Функцию compareNumeric для сравнения элементов-чисел можно упростить до одной строчки.

function compareNumeric(a, b) {
  return a - b;
}
Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, если наоборот, и 0, если числа равны.

Метод arr.reverse() меняет порядок элементов в массиве на обратный.
	var arr = [1, 2, 3];
	arr.reverse();
	alert( arr ); // 3,2,1

Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
	var arr = [1, 2];
	var newArr = arr.concat(3, 4);
	alert( newArr ); // 1,2,3,4
Если аргумент concat – массив, то concat добавляет элементы из него.
	var arr = [1, 2];
	var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)
	alert( newArr ); // 1,2,3,4,5

Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.
Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
Для поиска используется строгое сравнение ===.
	var arr = [1, 0, false];
	alert( arr.indexOf(0) ); // 1
	alert( arr.indexOf(false) ); // 2
	alert( arr.indexOf(null) ); // -1
Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.


метод Object.keys(obj). Он поддерживается везде, кроме IE8-:
	var user = {
	  name: "Петя",
	  age: 30
	}

	var keys = Object.keys(user);
	alert( keys ); // name, age

Методы:

push/pop, shift/unshift, splice – для добавления и удаления элементов.
join/split – для преобразования строки в массив и обратно.
slice – копирует участок массива.
sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.
reverse – меняет порядок элементов на обратный.
concat – объединяет массивы.
indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-).
>>>>>>>>>>>>>>>>>>>>>>

https://learn.javascript.ru/array-iteration

Массив: перебирающие методы




///////////////////////////////////////////////////////////////////////////
////////////////////////////////  ПРАКТИКА  ///////////////////////////////

<!DOCTYPE html>
<html>
<head>
<script>
function validateForm() {
    var x = document.forms["myForm"]["fname"].value;
    if (x == null || x == "") {
        alert("Name must be filled out");
        return false;
    }
}
</script>
</head>
<body>

<form name="myForm" action="demo_form.asp"
onsubmit="return validateForm()" method="post">
Name: <input type="text" name="fname">
<input type="submit" value="Submit">
</form>

</body>
</html>


...........................................

<!DOCTYPE html>
<html>
<body>

<h1>JavaScript Can Validate Input</h1>

<p>Please input a number between 1 and 10:</p>

<input id="numb">

<button type="button" onclick="myFunction()">Submit</button>

<p id="demo"></p>

<script>
function myFunction() {
    var x, text;

    // Get the value of the input field with id="numb"
    x = document.getElementById("numb").value;

    // If x is Not a Number or less than one or greater than 10
    if (isNaN(x) || x < 1 || x > 10) {
        text = "Input not valid";
    } else {
        text = "Input OK";
    }
    document.getElementById("demo").innerHTML = text;
}
</script>

</body>
</html>

..............................................................................

<!DOCTYPE html>
<html>
<body>

<form action="demo_form.asp" method="post">
  <input type="text" name="fname" required>
  <input type="submit" value="Submit">
</form>

<p>If you click submit, without filling out the text field,
your browser will display an error message.</p>

</body>
</html>

............................................

//////////////////////////////////////////////////////////////////////////////////

Calling all JavaScript programmers, you can now apply this important yet simple to use JavaScript tips that would be most beneficial for your web purposes.
1) First thing first, use === instead of ==
JavaScript utilizes two different kinds of equality operators: === ( or !==) and == ( or !=). Our tip is that you should use the former set of codes. To elaborate, if the 2 operands are of the same type and value, the === code produces true results while the !== code produces false results. If you apply the == ( or !=) code, you will run into issues when working with different operand types whereby the == ( or !=) will try a futile attempt to force the values when it executes an automatic type conversion.
On the other hand, the === (or !==) operator will not convert but instead balance the value and the type of operands which would be way faster than == ( or !=).

[10] === 10 // is false
[10] == 10 // is true
'10' == 10 // is true
'10' === 10 // is false
[] == 0 // is true
[] === 0 // is false
'' == false // is true but true == "a" is false
'' === false // is false


2) Use strict!

With regards to web browser support, applying the 'Use strict' command is under ECMAScript 5 and is supported by Safari 5.1+, Chrome 13+ and IE10. By entering 'Use strict', the browser is able to remove an error when you make mistakes in your coding such as: making a global variable or accessing arguments.callee or arguments.caller. This would allow programmers to easily monitor bugs and glitches if the application encounters a malfunction. 'Use Strict' can be applied to the scope of a function or an entire file.
For example:

1. (function(){
2.  x = 1;
3.  console.log(a);
4. })();
5. 
6. (function(){
7.  "use strict";
8. 
9.  y = 2;
10. })();
You will then achieve this.
1. > 1
2. > ReferenceError: b is not defined

3) Quick method in building a String

Instead of using the "for" statement when you need to loop through an array or object, you may try this series of codes for a quicker job.

"Using native methods (like join()), regardless of what's going on behind the abstraction layer, is usually much faster than any non-native alternative." 
- James Padolsey, james.padolsey.com

1 var arr = ['item a', 'item b', 'item c', ...];
2 var list = '<ul><li>' + arr.join('</li><li>') + '</li></ul>';

4) Prevent yourself from using try-catch-finally inside a loop

Reason is that the try-catch-finally command produces a new variable in that particular scope whenever the catch clause is applied. This will cause the caught exception object to be assigned to a variable.

Instead of using this:
var object = ['foo', 'bar'], i;
for (k = 0, len = object.length; k <len; k++) {
try {
// do something that throws an exception
}
catch (e) {
// handle exception
}
}

You can try this out:
var object = ['foo', 'bar'], i;
try {
for (p = 0, len = object.length; p <len; p++) {
// do something that throws an exception
}
}
catch (e) {
// handle exception
}

The very essential Immediately Invoked Function Expressions (IIFE)
IIFE works by having a pair of parenthesis to encapsulate the anonymous function which forms a function expression or a variable expression. You will then possess an unnamed function expression that will provide you with beneficial uses.

5) Use of IIFE to prevent your Global Scope from being contaminated

With this technique you can definitely avoid stating variables in the global scope. Such a technique is commonly used among JavaScript libraries, JavaScript professionals and jQuery developers. It is also recommended to use IIFE in top-level applications such as main.js as well.
How to apply it? By using IFFE in the global scope, it keep all variables local to the anonymous function, the variables outside of the global scope will be able to block other defined variables with the exact name.

// All the code is wrapped in the IIFE

 (function () {
 var firstName = "James";

 function init () {
 doStuff (firstName);
 // code to start the application

 }
 

 function doStuff () {

 // Do stuff here

 }
 

 function doMoreStuff () {

 // Do more stuff here

 }
 

 // Start the application

 init ();
 }) ();
You can also pass jQuery or any other object or variable via the parameter (the last 2 parentheses)

6) Use of IIFE to execute complex logic

A rather powerful too as you can execute complex logic without having a setup and call a named function. Do pay special attention to the 2 anonymous functions in the conditional statement
r unnamedDocs = [], namedDocs = ["one_republic", "counting_stars"];
 

 function createDoc(documentTitle) {

  var docName = documentTitle
 

  ?
 

  (function (theName) {
  var newDocName = theName.toLocaleLowerCase().replace(" ", "_");
  namedDocs.push(newDocName);
 

  return newDocName;
  })(documentTitle)
 

 

  :
 

 

  (function () {
  var newUnnamedDoc = "untitled_" + Number(namedDocs.length + 1);
  unnamedDocs.push(newUnnamedDoc);
  return newUnnamedDoc;
  })();
 

 

  return docName;
 }
 createDoc("MyTechLogy_is_great"); // over_the rainbow

 createDoc(); // untitled_4

7) Use of IIFE to avoid any fold over.

By using IIFE, you can stop the common bugs which will prevent close over in for loops. The bug side effects can be eradicated by:

function actorIDCreator (theActor) {
  var i;
  var uniqueID = 100;
  for (i = 0; i < theActor.length; i++) {
  theActor[i]["id"] = function (j) { // the j parametric variable is the i passed in on invocation of this IIFE

  return function () {
  return uniqueID + j; // each iteration of the for loop passes the current value of i into this IIFE and it saves the correct value to the array

  }
  } (i); // immediately invoke the function passing the i variable as a parameter

  }
 

  return theActor;
 }
 

 var actionActor = [{name:"Statham", id:0}, {name:"Berry", id:0}, {name:"Fox", id:0}];
 

 var createIdForActionActor = actorIDCreator (actionActor);
 

 var stathamID = createIdForActionActor [0];

 console.log(stathamID.id()); // 100

 

 var flightID = createIdForActionActor [1];console.log(flightID.id()); // 101

8) Be wary when using typeof, instanceof and constructor

typeof : a JavaScript unary operator is made to recur a string that constitutes an old type of variable. Be reminded that typeof null will return object, and like most object types (such as Array), it will return object.

var arr = ["x", "y", "z"];
typeof arr; // return "object"

constructor: Part of the internal prototype property, it can be quashed by code.
arr.constructor(); //[]

instanceof: A JavaScript operator that scrutinizes all the prototypes chain. The constructor it returns is true if its found and false if not.

arr instanceof Array // true 

9) A good habit to comment on your code

It may be an inconvenience to some, but it is a very good practice to comment on your code as much as possible. For instance, while returning back to your coding developments after a prolonged period, and to your horror, you'll find out that you can't easily remember what your coding was about! . Hence, it is a fundamental habit to comment on your code.

1)// Cycle through array and echo out each name.
2)for(var p = 0, len = array.length; p < len; p++) {
3)console.log(array[p]);
4)}

10) Lastly, don't use the 'with' statement 

It may seem that "With" statements could probably be a good idea. The idea is that they coders will be able to use a shortcut for accessing intricate objects. For example

1) With (being.vehicle.car.bodyparts) {
2) doors = true;
3) tyres = true;
4) }

instead of

1)being.vehicle.car.bodyparts.doors = true;
2)being.vehicle.car.bodyparts.tyres = true;
However, what will happen is that the codes will be very messy when setting new members. My advice would be to use var instead.

var i = being.vehicle.car.bodyparts;
i.doors = true;
i.tyres = true;
Well that's that! These are the top 10 tips you should adopt when using JavaScript. If you like to challenge the recommendations given or share your own piece of advice, do leave a comment below!

/////////////////////////////////////////

String Methods

	Method	        	Description

	charAt()		Returns the character at the specified index (position)
	charCodeAt()		Returns the Unicode of the character at the specified index
	concat()		Joins two or more strings, and returns a new joined strings
	endsWith()		Checks whether a string ends with specified string/characters
	fromCharCode()		Converts Unicode values to characters
	includes()		Checks whether a string contains the specified string/characters
	indexOf()		Returns the position of the first found occurrence of a specified value in a string
	lastIndexOf()		Returns the position of the last found occurrence of a specified value in a string
	localeCompare()		Compares two strings in the current locale
	match()			Searches a string for a match against a regular expression, and returns the matches
	repeat()		Returns a new string with a specified number of copies of an existing string
	replace()		Searches a string for a specified value, or a regular expression, and returns a new string where the specified values are replaced
	search()		Searches a string for a specified value, or regular expression, and returns the position of the match
	slice()			Extracts a part of a string and returns a new string
	split()			Splits a string into an array of substrings
	startsWith()		Checks whether a string begins with specified characters
	substr()		Extracts the characters from a string, beginning at a specified start position, and through the specified number of character
	substring()		Extracts the characters from a string, between two specified indices
	toLocaleLowerCase()	Converts a string to lowercase letters, according to the host's locale
	toLocaleUpperCase()	Converts a string to uppercase letters, according to the host's locale
	toLowerCase()		Converts a string to lowercase letters
	toString()		Returns the value of a String object
	toUpperCase()		Converts a string to uppercase letters
	trim()			Removes whitespace from both ends of a string
	valueOf()		Returns the primitive value of a String object


///////////////////
AJAX (аббревиатура от «Asynchronous Javascript And Xml») – технология обращения к серверу без перезагрузки страницы.



///////////////////////
ТЕРМИНОЛОГИЯ
	Пространство имён
Контейнер, который позволяет разработчикам связать весь функционал под уникальным, специфичным для приложения именем.

	Класс
Определяет характеристики объекта. Класс является описанием шаблона свойств и методов объекта.

	Объект
Экземпляр класса.

	Свойство
Характеристика объекта, например, цвет.

	Метод
Возможности объекта, такие как ходьба. Это подпрограммы или функции, связанные с классом.

	Конструктор
Метод, вызываемый в момент создания экземпляра объекта. Он, как правило, имеет то же имя, что и класс, содержащий его.

	Наследование
Класс может наследовать характеристики от другого класса.

	Инкапсуляция
Способ комплектации данных и методов, которые используют данные.

	Абстракция
Совокупность комплексных наследований, методов и свойств объекта должны адекватно отражать модель реальности.

	Полиморфизм
Поли означает "много", а морфизм "формы". Различные классы могут объявить один и тот же метод или свойство.



............
                    < requests
          server   -----------   client
                    responses >

Клиенты являются обычными пользователями, подключенных к Интернету устройств (например, компьютер подключен к Wi-Fi, или ваш телефон подключен к мобильной сети) и программного обеспечения, доступного на этих устройствах (как правило, браузер, например, Firefox или Chrome).
Серверы - компьютеры, которые хранят веб-страницы, сайты или приложения. Когда клиентское устройство пытается получить доступ к веб-странице, копия страницы загружается с сервера на клиентский компьютер для отображения в браузере пользователя.



Ваше Интернет-подключение: Позволяет отправлять и принимать данные по сети. Оно подобно улице между домом и магазином.
TCP / IP: Протокол Управления Передачей и Интернет-протокол являются коммуникационными протоколами, которые определяют, каким образом данные должны передаваться по сети. Они как транспортные средства, которые позволяют сделать заказ, пойти в магазин и купить ваши товары. В нашем примере, это как автомобиль или велосипед (или собственные ноги).
DNS: Система Доменных Имён напоминают записную книжку для веб-сайтов. При вводе веб-адреса в браузере, браузер обращается к DNS перед запрашиванием сайта. Она необходима браузеру, чтобы выяснить, на каком сервере "живёт" сайт, поэтому он может отправлять HTTP запросы в нужное место (см. ниже). Это как посмотреть на адрес магазина, чтобы попасть в него.
HTTP:Протокол Передачи Гипертекста - это протокол, который определяет язык для клиентов и серверов, чтобы общаться друг с другом. Он, как язык, который вы используете, чтобы заказать ваш товар.
Файлы компонентов: Сайт состоит из нескольких различных файлов, которые подобны различным отделам товаров в магазине. Эти файлы бывают двух основных типов:
Файлы кода: Сайты построены преимущественно на HTML, CSS и JavaScript, хотя вы познакомитесь с другими технологиями чуть позже.
Материалы: Это собирательное название для всех других вещей, составляющих сайт, такие как изображения, музыка, видео, документы Word и PDF.


ТАК ЧТО НА САМОМ ДЕЛЕ ПРОИСХОДИТ?
При вводе веб-адреса в адресную строку браузера (для нашей аналогии это как посещение магазина):

Браузер обращается к DNS серверу и находит реальный адрес сервера, на котором "живет" сайт (Вы находите адрес магазина).
Браузер посылает HTTP запрос к серверу, запрашивая его отправить копию сайта для клиента (Вы идёте в магазин и заказываете товар). Это сообщение, и все остальные данные, передаваемые между клиентом и сервером, передается по интернет-соединению с использованием протокола TCP / IP.
Если запрос клиента корректен, сервер отправляет клиенту статус "200 ОК", которое означает "Конечно, вы можете посмотреть на этот сайт! Вот он", а затем начинает отправку файлов сайта в браузер в виде небольших порций, называемых пакетными данными (магазин дает вам ваш товар или вам привозят его домой).
Браузер собирает маленькие куски в полноценный сайт и показывает его вам (товар прибывает к вашей двери — новые вещи, потрясающе!).


DNS
Реальные веб-адреса не удобные, незапоминающиеся строки, которые Вы вводите в адресную строку, чтобы найти ваши любимые веб-сайты. Это строки из чисел, типа этой: 63.245.217.105.

Она называется IP-адресом, и он представляет собой уникальное местоположение в Интернете. Впрочем, его не очень легко запомнить, правда? Вот почему изобрели Систему Доменных Имён. Это специальные сервера, которые связывают веб-адрес, который вы вводите в браузере (например, "mozilla.org"), с реальным IP-адресом сайта.

Сайты можно найти непосредственно через их IP-адреса. Попытайтесь зайти на сайт Mozilla, набрав 63.245.217.105 в адресной строке на новой вкладке браузера.

ПАКЕТЫ
Ранее мы использовали термин "пакеты", чтобы описать формат, в котором данные передаются от сервера к клиенту. Что мы имеем в виду здесь? В основном, когда данные передаются через Интернет, они передается в виде тысячи мелких кусков, так что много разных пользователей могут скачивать один и тот же сайт одовременно. Если бы сайты отправлялись как один большой кусок, тогда бы только один пользователь мог скачать его за один раз, и это, очевидно, сделало бы пользование интернетом не эффективным и не очень радостным.



















