New Features of PHP7

1) Scalar type declarations
<?php
function addition(int $a, float $b) {
return $a+$b;
}
?>

2) Return type declarations


<?php
function addition(int $a, float $b) {
return(float) ($a+$b);
}
?>

3) Null coalescing operator

<?php
$arr = [‘key’=>’value’];
$message = isset($arr[‘key’])?$arr[‘key’]:’not set’;
?>

4) Spaceship operator

<?php
echo 1 <=> 1; // 0
echo 1.5 <=> 2.5; // -1
 echo "a" <=> "b"; // -1
?>

5) Constant arrays using define()


<?php
define(‘AREA, [
    ‘triangle’,
    'circle',
    'rectangle'
]);
echo  AREA [1]; // outputs  "triangle"
?>

6) Anonymous classes

<?php
$str = new class {
public function str() {
return ‘string’;
}
}
Calling ->  $str->str();
?>
   
7) Unicode codepoint escape syntax


<?php
echo "\u{0000aa}";
?>

8) Closure::call()


<?php
class A {private $x = 1;}
$getXCB = function() {return $this->x;};
$getX = $getXCB->bindTo(new A, 'A');
echo $getX();
?>

9) Filtered unserialize()


<?php
$data = unserialize($foo, ["allowed_classes" => false]);
?>

10) Group use declarations


<?php
use some\namespace\ClassA;
use function some\namespace\fn_a;
use some\namespace\{ClassA, ClassB, ClassC as C};
?>

11) Generator Return Expressions


<?php
$gen = (function() {
yield 1;
yield 2;
return 3;
})();
foreach ($gen as $val) {
echo $val, PHP_EOL;
}
echo $gen->getReturn(), PHP_EOL;
?>

12) Generator delegation


<?php
function gen()
{
yield 1;
yield 2;
yield from gen2();
}
function gen2()
{
yield 3;
yield 4;
}
foreach (gen() as $val)
{
echo $val, PHP_EOL;
}
?>

13) Integer division with intdiv()



<?php
var_dump(intdiv(10, 3));
?>

14) preg_replace_callback_array()


The new preg_replace_callback_array() function enables code to be written more cleanly when using the preg_replace_callback() 


PHP CMS WordPress is working properly with New version of PHP7 framework Laravel is also supported all features and function added in new generation of PHP and all other frameworks and CMS are replacing deprecated function by updating library new generation is going to make web experience faster.

Now you can test your web application on PHP7 with WAMP new wamp is available with new APACHE and PHP7 support.

/////////////////////////////////////////////////////////
Решение проблем совместимости

Самым важным (и более незаметным) дополнением стало введение абстрактного синтаксического дерева (AST) - промежуточное представление кода в процессе компиляции (разделение парсера и компилятора). Имея такой инструмент мы сможем не только костыли с проблемных участков, но и создавать более производительный opcode.

Второй важный пункт - введение универсального синтаксиса для переменных. Именно он и может добавить разработчикам головной боли. Это дополнение решает многочисленные несоответствия, связанных с вычислением значений переменных. Например, получить значение свойства можно как при помощи ($object->closureProperty)(), так и путем цепочки статичных вызовов:

<?php

class foo { static $bar = 'baz'; }
class baz { static $bat = 'Hello World'; }

baz::$bat = function () { echo "Hello World"; };

$foo = 'foo';
($foo::$bar::$bat)();

Так же изменения коснулись семантики. В частности переменных-переменных/свойств.

До PHP 7, $obj->$properties['name'] давало доступ к свойству чьё имя содержится в ключах массива $properties. При работе с универсальным синтаксисом переменных ключ name даст вам доступ к свойству чьё имя содержится в $properties.

Рассмотрим на примере:

<?php

$obj->$properties['name']
В PHP 5.6 эта строка была бы обработана следующим образом:

<?php

$obj->{$properties['name']}
а в PHP 7:

<?php

{$obj->$properties}['name']

Конечно применение переменных-переменных встречается довольно редко, что не скажешь об обращении к свойствам объекта. Конечно, вы можете легко избавится от этой проблемы при помощи фигурных скобок, как показано в примере выше, таким образом получив одинаковое поведение в PHP обоих версий.

Производительность

Одна из основных причин перехода на PHP 7 - это значительное повышение производительности за счет применения phpng. Такой прирост производительности должен помочь небольшим хостингам, так как они смогут принять на себя большее число клиентов не внося никаких изменений в оборудование.

На данный момент, в зависимости от того чей тест производительности вы увидите, производительность PHP 7 стала соизмерима с Facebook HHVM, который использует JIT-компиляцию. Именно она компилирует команды PHP до уровня машинных команд (при возможности).

Не смотря на то, что JIT-компилятор очень много обсуждался, он не был включен в PHP 7. Конечно, нельзя сказать наверняка насколько повысилась бы производительность, если бы было принято иное решение, но было бы довольно интересно взглянуть на результаты, если вдруг кто-то решит создать подобный компилятор!

В дополнение к производительности, в PHP 7 улучшен процесс работы с памятью путем оптимизации структуры внутренних данных. А такая оптимизация, как правило, оказывает немалое влияние на производительность.

Проблемы обратной совместимости

Хотя разработчики определенно старались сохранить обратную совместимость, но, как правило, существуют моменты в которых это просто невозможно.

Но, хотелось бы отметить, что почти все эти проблемы малозначительны, как например ошибки при обращении к методу не объекта, за исключением проблем в универсальным синтаксисом переменных:

<?php

set_error_handler(function($code, $message) {
   var_dump($code, $message);
});

$var = null;
$var->method();
echo $e->getMessage(); // Fatal Error: Call to a member function method() on null
echo "Hello World"; // Still runs

Были удалены ASP и script теги, то есть вы больше не сможете использовать теги <%, <%= и <script language=”php”> и, соответственно, их закрывающие теги.

Другой важный момент - удаление всего функционала, отмеченного как deprecated. Были удалены регулярные выражения совместимые с POSIX (ext/reg PHP 5.3) и старое расширение ext/mysql (deprecated c PHP 5.5).

Очередная проблема обратной совместимости проявилась в возможности использования нескольких default выражений в switch. До PHP 7 было допустимо:

<?php

switch ($expr) {
   default:
        echo "Hello World";
        break;
   default:
        echo "Goodbye Moon!";
        break;
}
Раньше обрабатывался только последний default. А в PHP 7 вы получите ошибку:

Fatal error: Switch statements may only contain one default clause
Новые возможности

Довольно нехотя нам приходится разбираться с проблемами обратной совместимости. Мы увидели прирост в производительности. Но, мы также получаем новый функционал. Именно все новое и доставляет удовольствие в работе с новыми программными продуктами и PHP 7 не исключение.

Тайпхинтинг по скалярным величинам и возвращаемое значение

Начнем с самого противоречивого нововведения в PHP 7 - тайпхинтинг для скалярных типов. Внедрение этого функционала было принято на грани отказа в голосовании. В последствии автор RFC покинул проект. За чем последовали несколько новых RFC и соревнующихся между собой решений по ним. Но в итоге прошел оригинальный RFC.

Для конечных пользователей это означает, что вы сможете использовать тайпхинтинг при работе со скалярными величинами. А именно: int, float, string и bool. По-умолчанию тайпхинтинг не строгий, то есть допускается применение значения другого типа. Что означает, что при передачи int(1) в функцию, которая ожидает увидеть float, то такой вызов будет сконвертирован в float(1.0). Вызвав float(1.5) в функцию, требующую int, вы получите int(1).

Приведем пример:

<?php

function sendHttpStatus(int $statusCode, string $message) {
    header('HTTP/1.0 ' .$statusCode. ' ' .$message);
}

sendHttpStatus(404, "File Not Found"); // integer and string passed
sendHttpStatus("403", "OK"); // string "403" coerced to int(403)

В дополнение к этому вы можете установить строгий вариант тайпхинтинга, указав declare(strict_types=1) в начале файла. Таким образом все функции, которые будут вызваны в этом файле будут полностью соблюдены своему объявлению. Хочу отметить, что это распространяется только на определенный файл, а не на тот, в котором описана переменная.

Если функции будет передан несоответствующий параметр, то будет вызвана ошибка:

<?php

declare(strict_types=1); // must be the first line

sendHttpStatus(404, "File Not Found"); // integer and string passed
sendHttpStatus("403", "OK"); 

// Catchable fatal error: Argument 1 passed to sendHttpStatus() must be of the type integer, string given
Дальше больше. PHP 7 поддерживает тайпхинтинг по возвращаемым типам. Чтобы указать возвращаемый тип, следует применять следующий синтаксис:

<?php

function isValidStatusCode(int $statusCode): bool {
   return isset($this->statuses[$statusCode]);
}
В этом примере функция должна вернуть булево значение. На возвращаемые значения накладываются те же правила, что и на тайпхинтинг типов.

Комбинированный оператор сравнения

Мое любимое дополнение в PHP 7 - комбинированный оператор сравнения (<=>). Он является дополнительным к операторам больше и меньше.

Он работает как strcmp() и version_compare(), то есть возвращает -1 если левый операнд меньше, чем правый, 0 - если они равны и 1 - если левый операнд больше. Основное отличие заключается в том, что он применим к любым двум операндам.

Этот оператор часто встречается в функциях обратного вызова при работе с сортировкой данных:

<?php

// Pre Spacefaring^W PHP 7
function order_func($a, $b) {
   return ($a < $b) ? -1 : (($a > $b) ? 1 : 0);
}

// Post PHP 7
function order_func($a, $b) {
   return $a <=> $b;
}

............
Синтаксис для использования символов юникода

Новый экранирующий символ \u позволит указывать символы юникода в шестнадцатеричном формате внутри строк PHP:

Формат использования имеет следующий вид: \u{CODEPOINT}, например символ зеленого сердца можно напечатать так: '\u{1F49A}.'

Объединенный null оператор

Следующая новинка - объединенный оператор null - ??. Он возвращает левый операнд если он не null, а в противном случае возвращает правый.

Стоит отметить, что в случае если левый операнд - не объявленная ранее переменная, ошибка не возникает. Поведение этого оператора идентично isset() и полностью противоположно тернарному оператору ?:.

Так же при помощи нового оператора можно строить цепочки, в результате которых будет возвращен первый не null оператор:

<?php

$config = $config ?? $this->config ?? static::$defaultConfig;

Привязка замыкания при вызове

Начиная с PHP 5.4 мы видели новый метод Closure->bindTo()|Closure::bind(). Он позволяет изменить область видимости и значение переменной $this, по отдельности или вместе через создание копии замыкания.

В PHP 7 этот процесс значительно упрощен, привязка к области видимости, и $this одного объекта происходит через метод Closure->call(). Он принимает сам объект в качестве первого аргумента, а все остальные параметры передаются замыканию:

<?php

class HelloWorld 
{
    private $greeting = "Hello";
}

$closure = function($whom) { 
    echo $this->greeting . ' ' . $whom; 
}

$obj = new HelloWorld();
$closure->call($obj, 'World'); // Hello World

Группировка объявлений

Наверняка, вы оценили возможность продвинутых IDE автоматически добавлять use объявления, если вам приходилось импортировать много классов в проект. Теперь PHP 7 позволяет использовать групповые объявления. Они помогут импортировать несколько классов в упрощенном виде:

<?php

// Original
use Framework\Component\SubComponent\ClassA;
use Framework\Component\SubComponent\ClassB as ClassC;
use Framework\Component\OtherComponent\ClassD;

// With Group Use
use Framework\Component\{
    SubComponent\ClassA,
    SubComponent\ClassB as ClassC,
    OtherComponent\ClassD
};

Такой подход применим не только при импортировании констант и функций, но также и при смешанных импортах:

<?php

use Framework\Component\{
    SubComponent\ClassA,
    function OtherComponent\someFunction,
    const OtherComponent\SOME_CONSTANT
};

Улучшение генераторов

Возвращаемое значение генератора

В генераторы было добавлено две новых функции. Первая - возвращаемое выражение генератора, которая указывает возвращаемое значение в случае удачного выполнения генератора.

До PHP 7, если вы пытались вернуть что-то из генератора, то возникала ошибка. А теперь вы можете вызвать метод $generator->getReturn() для этой цели.

Если генератор не успел завершить свою работу или его исполнение прервалось в силу возникшего исключения, то обращение к методу $generator->getReturn() также вызовет исключение.

Если же генератор удачно отработал, а возвращать ему нечего, то вернется null.

Пример:

<?php

function gen() {
   yield "Hello";
   yield " ";
   yield "World!";

   return "Goodbye Moon!";
}

$gen = gen();

foreach ($gen as $value) {
   echo $value; 
}

// Outputs "Hello" on iteration 1, " " on iterator 2, and "World!" on iteration 3

echo $gen->getReturn(); // Goodbye Moon!

Делегирование генератора

Следующая новая функция производит большее впечатление - делегирование генератора. Она позволяет вернуть другую итеративную структуру, элементы которой могут быть перебраны по очереди, будь то массив, итератор или другой генератор.

Следует отметить, что за итерацию подструктур отвечает внешний цикл, таком образом обработка происходит так, как-будто вы работает с простой структурой данных, а не рекурсивной.

Такой подход также действителен при отправке данных или исключений в генератор. Они передаются напрямую в подструктуру, как-будто они обрабатываются вызовом.

Достигается это использованием оператора yield from <выражение>, например:

<?php

function hello() {
    yield "Hello";
    yield " ";
    yield "World!";

    yield from goodbye();
}

function goodbye() {
    yield "Goodbye";
    yield " ";
    yield "Moon!";
}

$gen = hello();
foreach ($gen as $value) {
    echo $value;
}
В каждой итерации будет выведено следующее:

1. "Hello"
2. " "
3. "World!"
4. "Goodbye"
5. " "
6. "Moon!"

Следует помнить, что так как субструктуры могут отдавать свои ключи, то вполне возможно, что эти ключи будут повторятся в разных итерациях. Поэтому, если для вас ключи имеют значение, то следует принять некоторые меры для устранения такой проблемы.

Исключения

Обработка критичных и фатальных ошибок в PHP традиционно либо вообще не поддавалось обработке, либо было довольно затруднительно это сделать. Благодаря новому движку исключений много из таких ошибок теперь будут вызывать исключения.

То есть теперь при возникновении фатальных или улавливаемых ошибок будет вызвано исключение, которое вы можете легко обработать. Если же вы не обработаете его, то будет вызвана та же самая ошибка.

Такие исключения это объекты класса EngineExceptions, которые в отличии от всех остальных исключений не наследуют класс Exception. Это было сделано специально, чтобы старый код не начал отлавливать этот вид исключения, если, например, вы использовали отлавливание исключений типа \Exception, что помогает поддерживать обратную совместимость.

В будущем, если вы хотите отловить абсолютно все виды исключений, то вам следует использовать новый класс \BaseException.

В дополнение ко всему отметим, что код внутри eval() будет вызывать исключение типа \ParseException, а несоответствии типов вызовет `\TypeException.

Пример:

<?php

try {
   nonExistentFunction();
} catch (\EngineException $e) {
    var_dump($e);
}

object(EngineException)#1 (7) {
 ["message":protected]=>
 string(32) "Call to undefined function nonExistantFunction()"
 ["string":"BaseException":private]=>
 string(0) ""
 ["code":protected]=>
 int(1)
 ["file":protected]=>
 string(17) "engine-exceptions.php"
 ["line":protected]=>
 int(1)
 ["trace":"BaseException":private]=>
 array(0) {
 }
 ["previous":"BaseException":private]=>
 NULL
}

Скоро!

До выпуска PHP 7.0.0 осталось 8 месяцев. Таким образом эта версии может стать самой быстрой основной выпущенной версией PHP. Хотя она все еще в альфа стадии, набирает обороты довольно быстро.

И вы сами можете помочь PHP развиваться.

Тестирование собственного кода

Загрузите PHP 7 vagrant box от Rasmus и проведите тестирование своего проекта на нем. Сообщети о возможных проблемах и продолжайте регулярно тестировать.

Помогайте с GOPHP7-EXT

Одной из основных проблем остается совместимость всех расширений с новым Zend Engine 3. Если вы применяете какое либо мало известное расширение, или разработчики которого прекратили его поддержку, то обратите внимание на проект GoPHP7-ext. Он поможет сделать так, что все расширения будут работать с первого для выпуска нового релиза PHP.

Пишите документацию

Каждая новая функция в PHP имеет соответствующий RFC. Все их вы можете найти на PHP.net wiki, именно оттуда и стоит начинать писать новые участки документации. Вы можете это делать при помощи online GUI, делая комиты прямо оттуда, или передавать патчи на одобрение.


