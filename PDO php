<?php
Welcome to FindNerd.
Today we are going to discuss PHP PDO. It is not a new term in PHP but many of us want to work in old patterns. Most common extensions are MySql and MySqli. If you are using PHP then you should be familiar with these terms. Database management is most common part in web development. Without security your data will be  unsecure. To manage the database operations you need to use most secure extension that is PDO. PDO stands for PHP Data Objects. It provides us the ability to use the different database platforms such as mysql, sqlLite, IBM and many more.
If you want to check available database drivers then use this function.

$arr_drivers = PDO::getAvailableDrivers();
 
Very first step is the connection building. You need database driver of your choice. By creating the instance of the PDO class you can establish connection with database. Please have look.

try {
$db_user = "root";
$db_pass =  "";
$dbh = new PDO('mysql:host=localhost;dbname=findnerd', $db_user, $db_pass);
} catch(Exception $e){
    echo $e->getMessage();
}

In above we made connection with sql
You can also make connection with other database as well using their drivers. You are going to share the example for sqlLite
 
$dbh = new PDO("sqlite:my/database/path/sqlLite.db");

For error handling you need to use the try/catch block. There are three different error modes.
A) PDO::ERRMODE_SILENT : This default mode does not show error and you need to check the error.
B) PDO::ERRMODE_WARNING : It shows the warning and continue the execution.
C) PDO::ERRMODE_EXCEPTION : It shows exceptions and gives you the different ways for handling.
You can set the mode like this

$dbh->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION );

After making the connection you can write the database query in prepare statement. Prepare statements usually executes multiple times and reduce the chance of sqlInjection.
 
try {
$db_user = "root";
$db_pass =  "";
$dbh = new PDO('mysql:host=localhost;dbname=findnerd', $db_user, $db_pass);
$dbh->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION );
$data = array('messy', 'dark bill', 'rt');
 
$sth = $dbh->("INSERT INTO schole (name, addr, city) values (?, ?, ?);
$sth->execute($data);
}
catch(Exception $e){
    echo $e->getMessage();
}

In above example we are trying to insert the data in table. We are using unnamed placeholder in prepare statement. With the help of execute function we are inserting the data.
 
You can simply close the connection by using below statement

$dbh = null;

In next blog we will discuss the fetching process in PDO.
Tags
- See more at: http://findnerd.com/list/view/PHP-PDO/18706/#sthash.daZbjCWU.dpuf 
"


/////////////////////////////

You cannot compare them....

CMS is a type of application
MVC is a programming architecture

So you can create a Content Management System using the MVC architecture

........
CMS = is content management system, its system, its application, its software, you can't create your own rules or own code.
MVC = Model, View, Controller. You can create your own application, your own rule, your own design, your own system.

so CMS is like a car, MVC is the way to build your own car.
'
................https://phpdelusions.net/pdo
Connecting. DSN

PDO has a fancy connection method called DSN. It''s nothing complicated though - instead of one plain and simple list of options, PDO asks you to input different configuration directives in three different places:

-database driver, host, db (schema) name and charset, as well as less frequently used port and unix_socket go into DSN;
-username and password go to constructor;
-all other options go into options array.
where DSN is a semicolon-delimited string, consists of param=value pairs, that begins from the driver name and a colon:

      mysql:host=localhost;dbname=test;port=3306;charset=utf8
driver^    ^ colon         ^param=value pair    ^semicolon  

Note that it''s important to follow the proper format - no spaces or quotes or other decorations have to be used in DSN, but only parameters, values and delimiters, as shown in the manual.

Here goes an example for mysql:

$host = '127.0.0.1';
$db   = 'test';
$user = 'root';
$pass = '';
$charset = 'utf8';

$dsn = "mysql:host=$host;dbname=$db;charset=$charset";
$opt = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false,
];
$pdo = new PDO($dsn, $user, $pass, $opt);

With all aforementioned variables properly set, we will have proper PDO instance in $pdo variable.

Important notes for the late mysql extension users:

1.Unlike old mysql_* functions, which can be used anywhere in the code, PDO instance is stored in a regular variable, which means it can be inaccessible inside functions - so, one has to make it accessible, by means of passing it via function parameters or using more advanced techniques, such as IoC container.

2.The connection has to be made only once! No connects in every function. No connects in every class constructor. Otherwise, multiple connections will be created, which will eventually kill your database server. Thus, a sole PDO instance has to be created and then used through whole script execution.

3.It is very important to set charset through DSN - that''s the only proper way. Forget about running SET NAMES query manually, either via query() or PDO::MYSQL_ATTR_INIT_COMMAND. Only if your PHP version is unacceptably outdated (namely below 5.3.6), do you have to use SET NAMES query and always turn emulation mode off.
Error handling. Exceptions

Although there are several error handling modes in PDO, the only proper one is PDO::ERRMODE_EXCEPTION. So, one ought to always set it this way, either by adding this line after creation of PDO instance,

$dbh->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION );
or as a connection option, as demonstrated in the example above.

Note that despite a widespread delusion, you should never catch errors to report them. A module (like a database layer) should not report its errors. This function has to be delegated to an application-wide handler. All we need is to raise an error (in the form of exception) - which we already did. That''s all. Nor should you ""always wrap your PDO operations in a try/catch"" like the most popular tutorial from tutsplus recommends.

In fact, there is nothing special in PDO exceptions - they are errors all the same. Thus, you have to treat them exactly the same way as other errors. If you had an error handler before, you shouldn''t create a dedicated one for PDO. If you didn''t care - it''s all right too, as PHP is good with basic error handling and will conduct PDO exceptions all right.

Exception handling is one of the problems with PDO tutorials. Being acquainted with exceptions for the first time when starting with PDO, authors consider exceptions dedicated to this library, and start diligently (but improperly) handling exceptions for PDO only. This is utter nonsense. If one paid no special attention to any exceptions before, they shouldn''t have changed their habit for PDO. If one didn''t use try..catch before, they should keep with that, eventually learning how to use exceptions and when it is suitable to catch them.

So now you can tell that the PHP manual is wrong, stating that

If your application does not catch the exception thrown from the PDO constructor, the default action taken by the zend engine is to terminate the script and display a back trace. This back trace will likely reveal the full database connection details, including the username and password.
However, there is no such thing as ""the displaying of a back trace""! What zend engine really does is just convert an uncaught exception into a fatal error. And then this fatal error is treated like any other error - so it will be displayed only if appropriate php.ini directive is set. Thus, although you may or you may not catch an exception, it has absolutely nothing to do with displaying sensitive information, because it''s a totally different configuration setting in response to this. So, do not catch PDO exceptions to report them. Instead, configure your server properly:

On a development server just turn displaying errors on:

ini_set('display_errors', 1);
While on a production server turn displaying errors off while logging errors on:

ini_set('display_errors', 0);
ini_set('log_errors', 1);
keep in mind that there are other errors that shouldn''t be revealed to the user as well.
You may want to catch PDO errors only in two cases:

If you are writing a wrapper for PDO, and you want to augment the error info with some additional data, like query string. In this case, catch the exception, gather the required information, and re-throw another Exception.
If you have a certain scenario for handling errors in the particular part of code. Some examples are:
if the error can be bypassed, you can use try..catch for this. However, do not make it a habit. Empty catch in every aspect works as error suppression operator, and so equally evil it is.
if there is an action that has to be taken in case of failure, i.e. transaction rollback.
if you are waiting for a particular error to handle. In this case, catch the exception, see if the error is one you''re looking for, and then handle this one. Otherwise just throw it again - so it will bubble up to the handler in the usual way.
E.g.:

try {
    $pdo->prepare("INSERT INTO users VALUES (NULL,?,?,?,?)")->execute($data);
} catch (PDOException $e) {
    if ($e->getCode() == 1062) {
        // Take some action if there is a key constraint violation, i.e. duplicate name
    } else {
        throw $e;
    }
}
However, in general, no dedicated treatment for PDO exceptions is ever needed. In short, to have PDO errors properly reported:

Set PDO in exception mode.
Do not use try..catch to report errors.
Configure PHP for proper error reporting
on a live site set display_errors=off and log_errors=on
on a development site, you may want to set display_errors=on
of course, error_reporting has to be set to E_ALL in both cases
As a result, you will be always notified of all database errors without a single line of extra code! Further reading.

Running queries. PDO::query()

There are two ways to run a query in PDO. If no variables are going to be used in the query, you can use the PDO::query() method. It will run your query and return special object of PDOStatement class which can be roughly compared to a resource, returned by mysql_query(), especially in the way you can get actual rows out of it:

$stmt = $pdo->query('SELECT name FROM users');
while ($row = $stmt->fetch())
{
    echo $row['name'] . "\n";
}
Also, the query() method allows us to use a neat method chaining for SELECT queries, which will be shown below.

Prepared statements. Protection from SQL injections

This is the main and the only important reason why you were deprived from your beloved mysql_query() function and thrown into the harsh world of Data Objects: PDO has prepared statements support out of the box. Prepared statement is the only proper way to run a query, if any variable is going to be used in it. The reason why it is so important is explained in detail in The Hitchhiker''s Guide to SQL Injection prevention.

So, for every query you run, if at least one variable is going to be used, you have to substitute it with a placeholder, then prepare your query, and then execute it, passing variables separately.

Long story short, it is not as hard as it seems. In most cases, you need only two functions - prepare() and execute().

First of all, you have to alter your query, adding placeholders in place of variables. Say, a code like this

$sql = "SELECT * FROM users WHERE email = '$email' AND status='$status'";
will become

$sql = 'SELECT * FROM users WHERE email = ? AND status=?';
or

$sql = 'SELECT * FROM users WHERE email = :email AND status=:status';
Note that PDO supports positional (?) and named (:email) placeholders. Also note that no quotes have to be ever used around placeholders.

Having a query with placeholders, you have to prepare it, using the PDO::prepare() method. This function will return the same PDOStatement object we were talking about above, but without any data attached to it.

Finally, to get the query executed, you must run execute() method of this object, passing variables in it, in the form of array. And after that, you will be able to get the resulting data out of statement (if applicable):

$stmt = $pdo->prepare('SELECT * FROM users WHERE email = ?');
$stmt->execute([$email]);
$user = $stmt->fetch();
// or
$stmt = $pdo->prepare('SELECT * FROM users WHERE email = :email');
$stmt->execute(['email' => $email]);
$user = $stmt->fetch();
As you can see, for the positional placeholders, you have to supply a regular array with values, while for the named placeholders, it has to be an associative array, where keys have to match the placeholder names in the query. You cannot mix positional and named placeholders in the same query.

Please note that positional placeholders let you write shorter code, but are sensitive to the order of arguments (which have to be exactly the same as the order of the corresponding placeholders in the query). While named placeholders make your code more verbose, they allow random binding order.

Also note that despite a widespread delusion, no ":" in the keys is required.

Binding methods

Passing data into execute() should be considered default and most convenient method. When this method is used, all values will be bound as strings (save for NULL values, that will be sent to the query as is, i.e. as SQL NULL), but most of time it's all right and won't cause any problem. E.g.

However, sometimes it''s better to set the data type explicitly. Possible cases are:

LIMIT clause in emulation mode or any other SQL clause that just cannot accept a string operand.
complex queries with non-trivial query plan that can be affected by a wrong operand type
peculiar column types, like BIGINT or BOOLEAN that require an operand of exact type to be bound (note that in order to bind a BIGINT value with PDO::PARAM_INT you need a mysqlnd-based installation).
In such a case explicit binding have to be used, for which you have a choice of two functions, bindValue() and bindParam(). The former one have to be preferred, because, unlike bindParam() it has no side effects to deal with.

Query parts you can bind

It is very important to understand which query parts you can bind using prepared statements and which you cannot. In fact, the list is overwhelmingly short: only string and numeric literals can be bound. So you can tell that as long as your data can be represented in the query as a numeric or a quoted string literal - it can be bound. For all other cases you cannot use PDO prepared statements at all: neither an identifier, or a comma-separated list, or a part of a quoted string literal or whatever else arbitrary query part cannot be bound using a prepared statement.

Workarounds for the most frequent use cases can be found in the corresponding part of the article

Prepared statements. Multiple execution

Sometimes you can use prepared statements for the multiple execution of a prepared query. It is slightly faster than performing the same query again and again, as it does query parsing only once. This feature would have been more useful if it was possible to execute a statement prepared in another PHP instance. But alas - it is not. So, you are limited to repeating the same query only within the same instance, which is seldom needed in regular PHP scripts and which is limiting the use of this feature to repeated inserts or updates:

$data = [
    1 => 1000,
    5 =>  300,
    9 =>  200,
];
$stmt = $pdo->prepare('UPDATE users SET bonus = bonus + ? WHERE id = ?');
foreach ($data as $id => $bonus)
{
    $stmt->execute([$bonus, $id]);
}
Note that this feature is a bit overrated. Not only it is needed too seldom to talk about, but the performance gain is not that big - query parsing is real fast these times.

Running SELECT INSERT, UPDATE, or DELETE statements

Come on folks. There is absolutely nothing special in these queries. To PDO they all the same. It doesn''t matter which query you are running.

Just like it was shown above, what you need is to prepare a query with placeholders, and then execute it, sending variables separately. Either for DELETE and SELECT query the process is essentially the same. The only difference is (as DML queries do not return any data), that you can use the method chaining and thus call execute() right along with prepare():

$sql = "UPDATE users SET name = ? WHERE id = ?";
$pdo->prepare($sql)->execute([$name, $id]);
However, if you want to get the number of affected rows, the code will have to be the same boresome three lines:

$stmt = $pdo->prepare("DELETE FROM goods WHERE category = ?");
$stmt->execute([$cat]);
$deleted = $stmt->fetchColumn();
Getting data out of statement. foreach()

The most basic and direct way to get multiple rows from a statement would be foreach() loop. Thanks to Traversable interface, PDOStatement can be iterated over by using foreach() operator:

$stmt = $pdo->query('SELECT name FROM users');
foreach ($stmt as $row)
{
    echo $row['name'] . "\n";
}
Note that this method is memory-friendly, as it doesn't load all the resulting rows in the memory but delivers them one by one (though keep in mind this issue).

Getting data out of statement. fetch()

We have seen this function already, but let's take a closer look. It fetches a single row from database, and moves the internal pointer in the result set, so consequent calls to this function will return all the resulting rows one by one. Which makes this method a rough analogue to mysql_fetch_array() but it works in a slightly different way: instead of many separate functions (mysql_fetch_assoc(), mysql_fetch_row(), etc), there is only one, but its behavior can be changed by a parameter. There are many fetch modes in PDO, and we will discuss them later, but here are few for starter:

PDO::FETCH_NUM returns enumerated array
PDO::FETCH_ASSOC returns associative array
PDO::FETCH_BOTH - both of the above
PDO::FETCH_OBJ returns object
PDO::FETCH_LAZY allows all three (numeric associative and object) methods without memory overhead.
From the above you can tell that this function have to be used in two cases:

When only one row is expected - to get that only row. For example,

$row = $stmt->fetch(PDO::FETCH_ASSOC);
Will give you single row from the statement, in the form of associative array.

When we need to process the returned data somehow before use. In this case it have to be run through usual while loop, like one shown above.
Another useful mode is PDO::FETCH_CLASS, which can create an object of particular class

$news = $pdo->query('SELECT * FROM news')->fetchAll(PDO::FETCH_CLASS, 'News');
will produce an array filled with objects of News class, setting class properties from returned values. Note that in this mode

properties are set before constructor call
for all undefined properties __set magic method will be called
if there is no __set method in the class, then new property will be created
private properties will be filled as well, which is a bit unexpected but quite handy
Note that default mode is PDO::FETCH_BOTH, but you can change it using PDO::ATTR_DEFAULT_FETCH_MODE configuration option as shown in the connection example. Thus, once set, it can be omitted most of the time.

Return types.

Only when PDO is built upon mysqlnd and emulation mode is off, then PDO will return int and float values with respective types. Say, if we create a table

create table typetest (string varchar(255), `int` int, `float` float, `null` int);
insert into typetest values('foo',1,1.1,NULL);
And then query it from mysqlnd-based PDO with emulation turned off, the output will be

array(4) {
  ["string"] => string(3) "foo"
  ["int"]    => int(1)
  ["float"]  => float(1.1)
  ["null"]   => NULL
}
Otherwise familiar mysql_fetch_array() behavior will be followed - all values returned as strings with only NULL returned as NULL.

Getting data out of statement. fetchColumn()

A neat helper function that returns value of the singe field of returned row. Very handy when we are selecting only one field:

// Getting the name based on id
$stmt = $pdo->prepare("SELECT name FROM table WHERE id=?");
$stmt->execute([$id]);
$name = $stmt->fetchColumn();

// getting number of rows in the table utilizing method chaining
$count = $pdo->query("SELECT count(*) FROM table")->fetchColumn();
Getting data out of statement in dozens different formats. fetchAll()

That''s most interesting function, with most astonishing features. Mostly thanks to its existence one can call PDO a wrapper, as this function can automate many operations otherwise performed manually.

PDOStatement::fetchAll() returns an array that consists of all the rows returned by the query. From this fact we can make two conclusions:

This function should not be used, if many rows has been selected. In such a case conventional while loop ave to be used, fetching rows one by one instead of getting them all into array at once. "Many" means more than it is suitable to be shown on the average web page.
This function is mostly useful in a modern web application that never outputs data right away during fetching, but rather passes it to template.
You''d be amazed, in how many different formats this function can return data in (and how little an average PHP user knows of them), all controlled by PDO::FETCH_* variables. Some of them are:

Getting a plain array.

By default, this function will return just simple enumerated array consists of all the returned rows. Row formatting constants, such as PDO::FETCH_NUM, PDO::FETCH_ASSOC, PDO::FETCH_OBJ etc can change the row format.

$data = $pdo->query('SELECT name FROM users')->fetchAll();
var_export($data);
/*
array (
  0 => array('John'),
  1 => array('Mike'),
  2 => array('Mary'),
  3 => array('Kathy'),
)*/
Getting a column.

It is often very handy to get plain one-dimensional array right out of the query, if only one column out of many rows being fetched. Here you go:

$data = $pdo->query('SELECT name FROM users')->fetchAll(PDO::FETCH_COLUMN);
/* array (
  0 => 'John',
  1 => 'Mike',
  2 => 'Mary',
  3 => 'Kathy',
)*/
Getting key-value pairs.

Also extremely useful format, when we need to get the same column, but indexed not by numbers in order but by another field. Here goes PDO::FETCH_KEY_PAIR constant:

$data = $pdo->query('SELECT id, name FROM users')->fetchAll(PDO::FETCH_KEY_PAIR);
/* array (
  104 => 'John',
  110 => 'Mike',
  120 => 'Mary',
  121 => 'Kathy',
)*/
Note that you have to select only two columns for this mode, first of which have to be unique.

Getting rows indexed by unique field

Same as above, but getting not one column but full row, yet indexed by an unique field, thanks to PDO::FETCH_UNIQUE constant:

$data = $pdo->query('SELECT * FROM users')->fetchAll(PDO::FETCH_UNIQUE);
/* array (
  104 => array (
    'name' => 'John',
    'car' => 'Toyota',
  ),
  110 => array (
    'name' => 'Mike',
    'car' => 'Ford',
  ),
  120 => array (
    'name' => 'Mary',
    'car' => 'Mazda',
  ),
  121 => array (
    'name' => 'Kathy',
    'car' => 'Mazda',
  ),
)*/
Note that first column selected have to be unique (in this query it is assumed that first column is id, but to be sure better list it explicitly).

Getting rows grouped by some field

PDO::FETCH_GROUP will group rows into a nested array, where indexes will be unique values from the first columns, and values will be arrays similar to ones returned by regular fetchAll(). The following code, for example, will separate boys from girls and put them into different arrays:

$data = $pdo->query('SELECT sex, name, car FROM users')->fetchAll(PDO::FETCH_GROUP);
array (
  'male' => array (
    0 => array (
      'name' => 'John',
      'car' => 'Toyota',
    ),
    1 => array (
      'name' => 'Mike',
      'car' => 'Ford',
    ),
  ),
  'female' => array (
    0 => array (
      'name' => 'Mary',
      'car' => 'Mazda',
    ),
    1 => array (
      'name' => 'Kathy',
      'car' => 'Mazda',
    ),
  ),
)
So, this is the ideal solution for such a popular demand like "group events by date" or "group goods by category". Some real life use cases:

How to multiple query results in order to reduce the query number?
Other modes

Of course, there is a PDO::FETCH_FUNC for the functional programming fans.

More modes are coming soon.

Getting row count with PDO

You don''t needed it.

Although PDO offers a function for returning the number of rows found by the query, PDOstatement::rowCount(), you scarcely need it. Really.

If you think it over, you will see that this is a most misused function in the web. Most of time it is used not to count anything, but as a mere flag - just to see if there was any data returned. But for such a case you have the data itself! Just get your data, using either fetch() or fetchAll() - and it will serve as such a flag all right! Say, to see if there is any user with such a name, just select a row:

$stmt = $pdo->prepare("SELECT 1 FROM users WHERE name=?");
$stmt->execute([$name]);
$userExists = $stmt->fetchColumn();
Exactly the same thing with getting either a single row or an array with rows:

$data = $pdo->query("SELECT * FROM table")->fetchAll();
if ($data) {
    // You have the data! No need for the rowCount() ever!
}
Remember that here you don''t need the count, the actual number of rows, but rather a boolean flag. So you got it.

Not to mention that the second most popular use case for this function should never be used at all. One should never use the rowCount() to count rows in database! Instead, one have to ask a database to count them, and return the result in a single row:

$count = $pdo->query("SELECT count(1) FROM t")->fetchColumn();
is the only proper way.

In essence:

if you need to know how many rows in the table, use SELECT COUNT(*) query.
if you need to know whether your query returned any data - check that data.
if you still need to know how many rows has been returned by some query (though I hardly can imagine a case), then you can either use rowCount() or simply call count() on the array returned by fetchAll() (if applicable).
Thus you could tell that the top answer for this question on Stack Overflow is essentially pointless and harmful - a call to rowCount() could be never substituted with SELECT count(*) query - their purpose is essentially different, while running an extra query only to get the number of rows returned by other query makes absolutely no sense.

Affected rows and insert id

PDO is using the same function for returning both number of rows returned by SELECT statement and number of rows affected by DML queries - PDOstatement::rowCount(). Thus, to get the number of rows affected, just call this function after performing a query.

Another frequently asked question is caused by the fact that mysql won''t update the row, if new value is the same as old one. Thus number of rows affected could differ from the number of rows matched by the WHERE clause. Sometimes it is required to know this latter number.

Although you can tell rowCount() to return the number of rows matched instead of rows affected by setting PDO::MYSQL_ATTR_FOUND_ROWS option to TRUE, but, as this is a connection-only option and thus you cannot change it''s behavior during runtime, you will have to stick to only one mode for the application, which could be not very convenient.

Unfortunately, there is no PDO counterpart for the mysql(i)_info() function which output can be easily parsed and desired number found. This is one of minor PDO drawbacks.

An auto-generated identifier from a sequence or auto_inclement field in mysql can be obtained from the PDO::lastInsertId function. An answer to a frequently asked question, "whether this function is safe to use in concurrent environment?" is positive: yes, it is safe. Being just an interface to MySQL C API mysql_insert_id() function it''s perfectly safe.

Prepared statements and LIKE clause

Despite PDO''s overall ease of use, there are some gotchas anyway, and I am going to explain some.

One of them is using placeholders with LIKE SQL clause. At first one would think that such a query will do:

$stmt = $pdo->prepare("SELECT * FROM table WHERE name LIKE '%?%'");
but soon they will learn that it will produce an error. To understand its nature one have to understand that, like it was said above, a placeholder have to represent a complete data literal only - a string or a number namely. And by no means can it represent either a part of a literal or some arbitrary SQL part. So, when working with LIKE, we have to prepare our complete literal first, and then send it to the query the usual way:

$search = "%$search%";
$stmt  = $pdo->prepare("SELECT * FROM table WHERE name LIKE ?");
$stmt->execute([$search]);
$data = $stmt->fetchAll();
Prepared statements and IN clause

Just like it was said above, it is impossible to substitute an arbitrary query part with a placeholder. Thus, for a comma-separated placeholders, like for IN() SQL operator, one must create a set of ?s manually and put them into the query:

$arr = [1,2,3];
$in  = str_repeat('?,', count($arr) - 1) . '?';
$sql = "SELECT * FROM table WHERE column IN ($in)";
$stm = $db->prepare($sql);
$stm->execute($arr);
$data = $stm->fetchAll();
Not very convenient, but compared to mysqli it''s amazingly concise.

Prepared statements and table names

On Stack Overflow I''ve seen overwhelming number of PHP users implementing the most fatal PDO code, thinking that only data values have to be protected. But of course it is not.

Unfortunately, PDO has no placeholder for identifiers (table and field names), so a developer must manually format them.

For mysql to format an identifier, follow these two rules:

Enclose identifier in backticks.
Escape backticks inside by doubling them.
so the code would be:

$table = "`".str_replace("`","``",$table)."`";
After such formatting, it is safe to insert the $table variable into query.

For other databases rules will be different but it is essential to understand that using only delimiters is not enough - delimiters themselves should be escaped.

It is also important to always check dynamic identifiers against a list of allowed values. Here is a brief example:

$orders  = ["name","price","qty"]; //field names
$key     = array_search($_GET['sort'],$orders); // see if we have such a name
$orderby = $orders[$key]; //if not, first one will be set automatically. smart enuf :)
$query   = "SELECT * FROM `table` ORDER BY $orderby"; //value is safe
Or, extending this approach for the INSERT/UPDATE statements (as Mysql supports SET for both),

$data = ['name' => 'foo','submit' => 'submit']; // data for insert
$allowed = ["name","surname","email"]; // allowed fields
$values = [];
$set = "";
foreach ($allowed as $field) {
    if (isset($data[$field])) {
        $set.="`".str_replace("`","``",$field)."`". "=:$field, ";
        $values[$field] = $source[$field];
    }
}
$set = substr($set, 0, -2); 
This code will produce correct sequence for SET operator that will contain only allowed fields and placeholders:

`name`=:foo
as well as $values array for execute(), which can be used like this

$stmt = $pdo->prepare("INSERT INTO users SET $set");
$stmt->execute($values);
Yes, it looks extremely ugly, but that is all PDO can offer.

A problem with LIMIT clause

Another problem is related to the SQL LIMIT clause. When in emulation mode (which is on by default), PDO substitutes placeholders with actual data, instead of sending it separately. And with "lazy" binding (using array in execute()), PDO treats every parameter as a string. As a result, the prepared LIMIT ?,? query becomes LIMIT '10', '10' which is invalid syntax that causes query to fail.

There are two solutions:

One is turning emulation off (as MySQL can sort all placeholders properly). To do so one can run this code:

$conn->setAttribute( PDO::ATTR_EMULATE_PREPARES, false );
And parameters can be kept in execute():

$conn->setAttribute( PDO::ATTR_EMULATE_PREPARES, false );
$stmt = $pdo->prepare('SELECT * FROM table LIMIT ?, ?');
$stmt->execute([$offset, $limit]);
$data = $stmt->fetchAll();
Another way would be to bind these variables explicitly while setting the proper param type:

$stmt = $pdo->prepare('SELECT * FROM table LIMIT ?, ?');
$stmt->bindParam(1, $offset,PDO::PARAM_INT);
$stmt->bindParam(2, $limit,PDO::PARAM_INT);
$stmt->execute();
$data = $stmt->fetchAll();
One peculiar thing about PDO::PARAM_INT: for some reason it does not enforce the type casting. Thus, using it on a number that has a string type will cause the aforementioned error:

$stmt = $pdo->prepare("SELECT 1 LIMIT ?");
$stmt->bindValue(1, "1", PDO::PARAM_INT);
$stmt->execute();
But change "1" in the example to 1 - and everything will go smooth.

Calling stored procedures in PDO

There is one thing about stored procedures any programmer stumbles upon at first: every stored procedure always returns one extra result set: one (or many) results with actual data and one just empty. Which means if you try to call a procedure and then proceed to another query, then "Cannot execute queries while other unbuffered queries are active" error will occur, because you have to clear that extra empty result first. Thus, after calling a stored procedure that is intended to return only one result set, just call PDOStatement::nextRowset() once (of course after fetching all the returned data from statement, or it will be discarded):

$stmt = $pdo->prepare("CALL bar()");
$stmt->execute();
$data = $stmt->fetchAll();
$stmt->nextRowset();
While for the stored procedures returning many result sets the behavior will be the same as with multiple queries execution:

$stmt = $pdo->prepare("CALL foo()");
$stmt->execute();
do {
    $data = $stmt->fetchAll();
    var_dump($data);
} while ($stmt->nextRowset() && $stmt->columnCount());
However, as you can see here is another trick have to be used: remember that extra result set? It is so essentially empty that even an attempt to fetch from it will produce an error. So, we cannot use just while ($stmt->nextRowset()). Instead, we have to check also for empty result. For which purpose PDOStatement::columnCount() is just excellent.

This feature is one of essential differences between old mysql ext and modern libraries: after calling a stored procedure with mysql_query() there was no way to continue working with the same connection, because there is no nextResult() function for mysql ext. One had to close the connection and then open a new one again in order to run other queries after calling a stored procedure.

Calling a stored procedure is a rare case where bindParam() use is justified, as it''s the only way to handle OUT and INOUT parameters. The example can be found in the corresponding manual chapter. However, for mysql it doesn''t work. You have to resort to an SQL variable and an extra call.

Running multiple queries with PDO

When in emulation mode, PDO can run mutiple queries in the same statement, either via query() or prepare()/execute(). To access the result of consequent queries one have to use PDOStatement::nextRowset():

$stmt = $pdo->prepare("SELECT ?;SELECT ?");
$stmt->execute([1,2]);
do {
    $data = $stmt->fetchAll();
    var_dump($data);
} while ($stmt->nextRowset());
Within this loop you''ll be able to gather all the related information from the every query, like affected rows, auto-generated id or errors occurred.

It is important to understand that at the point of execute() PDO will report the error for the first query only. But if error occurred at any of consequent queries, to get that error one have to iterate over results. Despite some ignorant opinions, PDO can not and should not report all the errors at once. Some people just cannot grasp the problem at whole, and don''t understand that error message is not the only outcome from the query. There could be a dataset returned, or some metadata like insert id. To get these, one have to iterate over resultsets, one by one. But to be able to throw an error immediately, PDO would have to iterate automatically, and thus discard some results. Which would be a clear nonsense.

Unlike mysqli_multi_query() PDO doesn''t make an asynchronous call, so you can''t "fire and forget" - send bulk of queries to mysql and close connection, PHP will wait until last query gets executed.

Emulation mode. PDO::ATTR_EMULATE_PREPARES

One of the most controversial PDO configuration options is PDO::ATTR_EMULATE_PREPARES. What does it do? PDO can run your queries in two ways:

It can use a real or native prepared statement:
When prepare() is called, your query with placeholders gets sent to mysql as is, with all the question marks you put in (in case named placeholders are used, they are substituted with ?s as well), while actual data goes later, when execute() is called.
It can use emulated prepared statement, when your query is sent to mysql as proper SQL, with all the data in place, properly formatted. In this case only one roundtrip to database happens, with execute() call. For some drivers (including mysql) emulation mode is turned ON by default.
Both methods has their drawbacks and advantages but, and - I have to stress on it - both being equally secure, if used properly. Despite rather appealing tone of the popular article on Stack Overflow, in the end it says that if you are using supported versions of PHP and MySQL properly, you are 100% safe. All you have to do is to set encoding in the DSN, as it shown in the example above, and your emulated prepared statements will be as secure as real ones.

Note that when native mode is used, the data is never appears in the query, which is parsed by the engine as is, with all the placeholders in place. If you''re looking into Mysql query log for your prepared query, you have to understand that it''s just an artificial query that has been created solely for logging purpose, but not a real one that has been executed.

Other issues with emulation mode as follows:

When emulation mode is ON, one can use a handy feature of named prepared statements - a placeholder with same name could be used any number of times in the same query, while corresponding variable have to be bound only once. For some obscure reason this functionality is disabled when emulation mode is off:

	$stmt = $pdo->prepare("SELECT * FROM t WHERE foo LIKE :search OR bar LIKE :search");'             
	$stmt->execute(['search'] => "%$search%");'

Also, when emulation is ON, PDO is able to run multiple queries in one prepared statement.

Also, as native prepared statements support only certain query types, you can run some queries with prepared statements only when emulation is ON. The following code will return table names in emulation mode and error otherwise:

	$stmt = $pdo->prepare("SHOW TABLES LIKE ?");
	$stmt->execute(["%$name%"]);
	var_dump($stmt->fetchAll());

On the other hand, when emulation mode is OFF, one could bother not with parameter types, as mysql will sort all the types properly. Thus, even string can be bound to LIMIT parameters, as it was noted in the corresponding chapter.

It''s hard to decide which mode have to be preferred, but for usability sake I would rather turn it OFF, to avoid a hassle with LIMIT clause. Other issues could be considered negligible in comparison.

Mysqlnd and buffered queries. Huge datasets.

Recently all PHP extensions that work with mysql database were updated based on a low-level library called mysqlnd, which replaced old libmysql client. Thus some changes in the PDO behavior, mostly described above and one that follows:

There is one thing called buffered queries. Although you probably didn''t notice it, you were using them all the way. Unfortunately, here are bad news for you: unlike old PHP versions, where you were using buffered queries virtually for free, modern versions built upon mysqlnd driver won''t let you to do that anymore:

When using libmysqlclient as library PHP''s memory limit won''t count the memory used for result sets unless the data is fetched into PHP variables. With mysqlnd the memory accounted for will include the full result set.
The whole thing is about a resultset, which stands for all the data found by the query.

When your SELECT query gets executed, there are two ways to deliver the results in your script: buffered and unbuffered one. When buffered method is used, all the data returned by the query gets copied in the script''s memory at once. While in unbuffered mode a database server feeds the found rows one by one.

So you can tell that in buffered mode a resultset is always burdening up the memory on the server even if fetching weren''t started at all. Which is why it is not advisable to select huge datasets if you don''t need all the data from it.

Nonetheless, when old libmysql-based clients were used, this problem didn''t bother PHP uers too much, because the memory consumed by the resultset didn''t count in the the memory_get_usage() and memory_limit.

But with mysqlnd things got changed, and the resultset returned by the buffered query will be count towards both memory_get_usage() and memory_limit, no matter which way you choose to get the result:

$pdo->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, FALSE);
$stmt = $pdo->query("SELECT * FROM Board");
$mem = memory_get_usage();
while($row = $stmt->fetch());
echo "Memory used: ".round((memory_get_usage() - $mem) / 1024 / 1024, 2)."M\n";

$pdo->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, TRUE);
$stmt = $pdo->query("SELECT * FROM Board");
$mem = memory_get_usage();
while($row = $stmt->fetch());
echo "Memory used: ".round((memory_get_usage() - $mem) / 1024 / 1024, 2)."M\n";
will give you (for my data)

Memory used: 0.02M
Memory used: 2.39M
which means that with buffered query the memory is consumed even if you''re fetching rows one by one!

So, keep in mind that if you are selecting a really huge amount of data, always set PDO::MYSQL_ATTR_USE_BUFFERED_QUERY to FALSE.

Of course, there are some drawbacks, two minor ones:

With unbuffered query you can''t use rowCount() method (which is useless, as we learned above)
Moving (seeking) the current resultset internal pointer back and forth (which is useless as well).
And a rather important one:

While an unbufferered query is active, you cannot execute any other query. So, use this mode wisely.

////////////////////////////////////////////////////////////////////////
http://php.net/manual/ru/book.pdo.php
..................................
	PDO {
		public __construct ( string $dsn [, string $username [, string $password [, array $options ]]] )
		public bool beginTransaction ( void )
		public bool commit ( void )
		public mixed errorCode ( void )
		public array errorInfo ( void )
		public int exec ( string $statement )
		public mixed getAttribute ( int $attribute )
		public static array getAvailableDrivers ( void )
		public bool inTransaction ( void )
		public string lastInsertId ([ string $name = NULL ] )
		public PDOStatement prepare ( string $statement [, array $driver_options = array() ] )
		public PDOStatement query ( string $statement )
		public string quote ( string $string [, int $parameter_type = PDO::PARAM_STR ] )
		public bool rollBack ( void )
		public bool setAttribute ( int $attribute , mixed $value )
	}
...............................................

PDO::__construct — Создает экземпляр PDO, предоставляющий соединение с базой данных 
  public PDO::__construct ( string $dsn [, string $username [, string $password [, array $options ]]] )

dsn       -  Имя источника данных или DSN, содержащее информацию, необходимую для подключения к базе данных.(поддерживает три разные метода указания аргументов)
             В общем, DSN состоит из имени драйвера PDO, за которым следует двоеточие и специфический синтаксис подключения драйвера PDO. 
             Дополнительную информацию можно получить из раздела Документация по специфическим драйверам PDO.

  [database driver],  [host],  [db (schema(таблица)) name]    and    [charset],   as well as less frequently used    [port]   and    [unix_socket]    go into DSN

  DSN is a semicolon-delimited string, consists of param=value pairs, that begins from the driver name and a colon:

      mysql:host=localhost;    dbname=test;     port=3306;    charset=utf8
driver^    ^ colon              ^param=value      pair   ^semicolon  


username  - Имя пользователя для строки DSN. Этот параметр опционален для некоторых драйверов PDO.
password  - Пароль для строки DSN. Этот параметр опционален для некоторых драйверов PDO.
options   - Массив специфичных для драйвера настроек подключения ключ=>значение.

Возвращает объект PDO в случае успеха.

PDO::__construct() выбрасывает исключение PDOException, если попытка соединения с необходимой базой данных не удается.
<?//ПРИМЕР
$host = '127.0.0.1';
$db   = 'test';
$user = 'root';
$pass = '';
$charset = 'utf8';

$dsn = "mysql:host=$host;dbname=$db;charset=$charset";
$opt = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false,
];
$pdo = new PDO($dsn, $user, $pass, $opt);
.................................................
Connecting. DSN
Подключения и Управление подключениями 

Соединения устанавливаются автоматически при создании объекта PDO от его базового класса. Не имеет значения, какой драйвер вы хотите использовать; все что требуется, это имя базового класса. Конструктор класса принимает аргументы для задания источника данных (DSN), а также необязательные имя пользователя и пароль (если есть).
При успешном подключении к базе данных в скрипт будет возвращен созданный PDO объект. Соединение остается активным на протяжении всего времени жизни объекта. Чтобы закрыть соединение, необходимо уничтожить объект путем удаления всех ссылок на него (этого можно добиться, присваивая NULL всем переменным, указывающим на объект). Если не сделать этого явно, PHP автоматически закроет соединение по окончании работы скрипта.


Замечание:
Чтобы использовать постоянные соединения, необходимо добавить константу PDO::ATTR_PERSISTENT в массив параметров драйвера, который передается конструктору PDO. Если просто задать этот атрибут функцией PDO::setAttribute() уже после создания объекта, драйвер не будет использовать постоянные соединения.
Замечание:
Если вы используете PDO ODBC драйвер и ваши ODBC библиотеки поддерживают объединение подключений в пул (ODBC Connection Pooling) (unixODBC и Windows точно поддерживают, но могут быть и другие), то рекомендуется вместо постоянных соединений пользоваться этим пулом. Пул подключений ODBC доступен всем модулям текущего процесса; если PDO сам кэширует соединение, то это соединение будет недоступно другим модулям и не попадет в пул. В результате каждый модуль будет создавать дополнительные подключения для своих нужд.























